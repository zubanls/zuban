# Next up
testTypeVarTupleTypeApplicationOverload
testUnionOfNonIterableUnpacking
testPostInitIsNotAFunction
testOverloadPossibleOverlapWithArgsAndKwargs
testLiteralAndGenericsRespectsUpperBound
testNewRedefineForStatementIndexNarrowing
goto_doc_contains_stdlib_compiled

docs_alias

super_explicit_type_var_method
super_explicit_type_var_classmethod

# Regression from calculating nested functions in a different way
testLocalPartialTypesWithNestedFunction
testLocalPartialTypesWithNestedFunction2

# parser fails
avoid_bracket_slowdown

# regressions
testIncrementalInvalidNamedTupleInUnannotatedFunction
testOptionalTypeNarrowedByGenericCall3
# Regressions for Never-generics to Any-generics
testOverloadVarargsSelection
testOverloadingInferUnionReturnWithObjectTypevarReturn
testOverloadingInferUnionReturnWithBadObjectTypevarReturn

# callable matching should work correctly with the same definitions (currently emits an error log)
# strict_equality_class_generics_access

# callable matching regression
testNoCrashOnNestedGenericCallable

# WTF why is this base type not object/function?
testListLiteralWithNameOnlyArgsDoesNotEraseNames
# join of {1, *some_str_tuple} leads to int | str???
testUnpackInExpression2-only_when_nocache
# Join issues
testDeterminismFromJoinOrderingInSolver
# Self in multi inheritance matching needs intersection to satisfy if its fine
testTypingSelfOverrideVarMulti
testSelfInMultipleInheritance
# Self remapped, but it shouldn't
testTypingSelfInternalSafe
testTypingSelfClashInBodies
# Self callable matching missing type var matcher for Self
class_lookup_of_methods_with_generics
reassigning_with_self_types
# Any base class now matches everything for union simplification
testUnionSimplificationSpecialCases2
# Callable matching positional names ignored, but kwargs is there; mypy wrong?
testProtocolIncompatibilityWithUnionType
# dict questionable decisions
testDictWithStarStarExpr
testDictFromIterableAndStarStarArgs
testDictFromIterableAndStarStarArgs2
# Type variable "__main__.Ts" is invalid as target for type alias
testTypeVarTupleIsNotValidAliasTarget
testGenericTypeAliasesWrongAliases
# Type var used in bound, defined in class body, bound to that class / func
class_method_generics_with_type_var_in_class_scope
# Type var bound cycle
testNewAnalyzerDuplicateTypeVarImportCycle
testNewAnalyzerDuplicateTypeVarImportCycleWithAliases
# Import cycle issues
testNewAnalyzerAliasToNotReadyClassGeneric
testNewAnalyzerTrickyAliasInFuncDef
# Recursive aliases that fail to resolve because imports are calculating
check-incremental:testRecursiveAliasImported
check-recursive-types:testRecursiveAliasImported
testTypeAliasUpdateNonRecursiveToRecursiveFine
testTypeAliasUpdateNonRecursiveToRecursiveCoarse
testRecursiveNamedTupleTypedDict
# Recursive aliases with NewType, classes should be resolved first
testRecursiveAliasViaBaseClass2
# Mypy is probably wrong with this, let's wait for conformance tests to clarify
testSelfTypeClassMethodNotSilentlyErased

# param spec complex nested transitive tests
testParamSpecNestedApplyPosVsNamed
# list element context inference should probably ignore type vars
testInferenceAgainstGenericCallableGenericNonLinear
# Context for returns with or
testBinaryOpInferenceContext
# Recursive alias union type var inference where Nested[T] is checked before T
testRecursiveAliasWithRecursiveInstanceInference
# type var backtracking
testUnionInference
# type var with unions and fallback in case solving is not possible
testTypeVarTupleInvariant
unite_type_vars_mypy_issue_5874_no_join
# Invalid ParamSpec definitions
testParamSpecLocations
testRunParamSpecInsufficientArgs
testRunParamSpecConcatenateInsufficientArgs
testRunParamSpecConcatenateInsufficientArgsInDecorator
testRunParamSpecDuplicateArgsKwargs

# union math vs. type var
testOverloadDetectsPossibleMatchesWithGenerics
testOverloadsAndNoReturnNarrowWhenBlacklistingSubtype
testOverloadsAndNoReturnNarrowWhenBlacklistingSubtype2
testOverloadsAndNoReturnNarrowTypeNoStrictOptional2
testOverloadsAndNoReturnNarrowTypeWithStrictOptional2
testOverloadsAndNoReturnNarrowTypeNoStrictOptional3
testOverloadsAndNoReturnNarrowTypeWithStrictOptional3
# overload Any unclear why Mypy decides like this
testTypeVarTupleOverloadMatch
# overload x should be preferred over an *x alternative
testTupleOverloadZipAny
# Callable x: int should be a subtype of *args: int | str, **kw: int
testTypeCheckOverloadImplOverlapVarArgsAndKwargs
testTypeCheckOverloadImplOverlapVarArgsAndKwargsUnion

# [''] + [1] does not generate an error
testAssignmentSubtypes
testInWithInvalidArgs
# union order issues
testNarrowingEqualityDisabledForCustomEquality

# Class argument and __init__ as overloaded DbType
testOverloadedToGeneric
# object.__new__(cls) -> Self where object.__new__(int) leads to Never
testOverride__new__AndCallObject
# __new__ return types with Never
testNewAndInitNoReturn
testOverloadedNewAndInitNoReturn

# TypeGuard/TypeIs narrowing with Any
testTypeGuardNestedRestrictionAny
testTypeIsNestedRestrictionAny
# Inferred assignments are valid for Any, see also Mypy commit b50f3a1a44
testSubtypingWithAny
# or/and boolean logic over multiple terms with assignment in between
testRestrictedBoolAndOrWithGenerics
# isinstance intersections lead sometimes to never?
testIsInstanceAdHocIntersectionIncrementalIntersectionToUnreachable
testIsInstanceAdHocIntersectionIncrementalUnreachaableToIntersection
testIsInstanceAdHocIntersectionFineGrainedIncrementalIntersectionToUnreachable
testIsInstanceAdHocIntersectionFineGrainedIncrementalUnreachaableToIntersection
# TypeIs tuple materializations
testTypeIsTupleGeneric
# "Function "property_decorator_missing" could always be true in boolean context"
testUnreachableFlagMiscTestCaseMissingMethod
testWalrus
# --strict-equality strict equality "Non-overlapping equality check (left operand type: "int", right operand type: "str")"
testStrictEqualityNoPromotePy3
testStrictEqualityAllowlist
testNarrowingEqualityDisabledForCustomEqualityChain
testNarrowingEqualityFlipFlop
testStrictEqualitywithParamSpec
testCustomEqCheckStrictEqualityTuple
testDisableBytearrayPromotion
testStrictEqualityForNone
testInlineErrorCodesArentRuinedByOthersSe
# --strict enables --strict-bytes
testStrictBytesEnabledByStrict
# optional assignment within class
testLocalPartialTypesWithInheritance3
# formatting the wrong class in assignment to member of superclass of superclass
testClassOrderOfError
testClassIgnoreType_RedefinedAttributeAndGrandparentAttributeTypesNotIgnored
# Dynamic functions are ignored in classes and the super class is used?
testInferringTypesFromIterable
testMultipleAssignmentAndGenericSubtyping

# Make x an Optional if else contains `x = None` (mostly implemented, but slightly different in Mypy)
testOptionalBackwards1
testPerFileStrictOptionalBasic
testPerFileStrictOptionalBasicPyProjectTOML
optional_backwards_global
# needs error because only reassignments with other partial
testInferenceWithUninhabitedType

# Method binding should be ensured (advanced)
testMethodSelfArgumentChecks
testMethodSelfArgumentChecksConcatenate
testMethodSelfArgumentChecksInUntyped
testBoundMethodsAssignedInClassBody
testInstanceMethodBoundOnClass
testMethodMakeBoundIncremental
testMethodMakeBoundFineGrained

# --------------------------- Not first release ---------------------------

# --disallow-any-generics
testDisallowAnyGenericsForAliasesInRuntimeContext
testGenericTypedDictAlias
testNewAnalyzerDisallowAnyGenericsMessages

# Better functools.total_ordering support
testTotalOrderingLambda
testTotalOrderingReturnNotBool
testTotalOrderingAllowsAny

# with scoping is special (Does it need to be??)
testWithStmtScopeBasics
testWithStmtScopeNestedWith1
testWithStmtScopeNestedWith2
testWithStmtScopeInnerAndOuterScopes
testWithStmtScopeMultipleContextManagers
testWithStmtScopeMultipleAssignment
testWithStmtScopeAndClass
testWithStmtScopeAndLambda

# Self definitions different from parent
testSelfTypeOverrideCompatibility
# "Property "x" defined in "Base" is read-only" because of NamedTuple inheritance
testNewNamedTupleMethodInheritance
# Property setter with self types
testOverridePropertyGeneric
testSettablePropertyAlias
# Property setter with decorator and a different type
testPropertySetterDecorated
# Invalid property setter signatures
testPropertyAllowsDeleterBeforeSetter
# Property settter generic
testPropertyWithGenericSetter
# Inheritance ClassVar in parent of parent, overwritten in parent and therefore should still be a ClassVar but isn't
testOverrideClassVarManyBases
# Multi inheritance should check both sides
testMultipleInheritance_NestedVariableOverriddenWithIncompatibleType1
testGenericMultipleOverrideReplace
testUseSupertypeAsInferenceContextConflict
testMultipleInheritanceCompatibleTypeVar
# Redefinitions of star imports and builtins
testNewAnalyzerIdentityAssignment1
testNewAnalyzerIdentityAssignment2
testNewAnalyzerIdentityAssignment3

# "Cannot assign multiple types to name "b" without an explicit "Type[...]" annotation"
testAliasesInClassBodyNormalVsSubscripted
# type alias reassignments
testProhibitReassigningSubscriptedAliases
testProhibitReassigningGenericAliases
# overload statements between definitions
testRedefinedOverloadedFunction

# finally must be checked twice
testUnionTryFinally
testUnionTryFinally5
testUnionTryFinally6
testUnionSyntaxRecombined
testOrSyntaxRecombined
testAvoidFalseUnreachableInFinally
# while must be rechecked if type widens
testModifyLoop
testModifyLoopWhile4
testModifyLoopFor4
testModifyLoopLong
testComplicatedBlocks
testIsInstanceSubClassMemberHard
testRefinePartialTypeWithinLoop
testAvoidFalseUnreachableInLoop
testNewRedefineTryStatement
testNewRedefineWhileLoopOptional
testNewRedefineBreakAndContinue
testNarrowPromotionsInsideUnions2
testPersistentUnreachableLinesNestedInInpersistentUnreachableLines
testAvoidFalseRedundantCastInLoops
testAvoidFalseUnreachableInLoop1
testAvoidFalseUnreachableInLoop2
testAvoidFalseUnreachableInLoop3
# Narrowing len()
testNarrowingLenTypeVarTupleGreaterThan
testNarrowingLenBareExpressionTypeVarTuple
testNarrowingLenUnionWithUnreachable
testNarrowingLenAnyListElseNotAffected
testNarrowingLenMixWithAnyPrecise
testNarrowingLenMixWithAnyImprecise
# For Stmt Index Narrowing
testForStatementIndexNarrowing
# issubclass narrowing leads to Never entries instead of unreachable?
testIssubclassWithMetaclassesStrictOptional
# questionable implicit literal?
testEnumReachabilityChecksIndirect
# narrowing `in` weird overlapping. Mypy correct?
testTupleOverlapDifferentTuples
# isinstance error conditions
testLiteralErrorsWithIsInstanceAndIsSubclass
# isinstance with promotions will change outer types
testIntersectionUsingPromotion6
# type[any] issues
testIsInstanceWithUnknownType
testNarrowingWithTupleOfTypes
testNarrowingWithTupleOfTypesPy310Plus
# nonlocal
testNarrowedVariableInNestedFunctionMore1
# Narrowing keep out of function narrowings
testNarrowingOfFinalPersistsInFunctions
# TypeVar narrowing
testIsinstanceAndNarrowTypeVariable
testIsinstanceAndNegativeNarrowTypeVariableWithUnionBound1
testIsinstanceAndNegativeNarrowTypeVariableWithUnionBound2
testNarrowingUsingTypeVar
testNarrowTypeVarBoundType
testNarrowTypeVarBoundUnion
# Do not narrow to Never
testDoNotNarrowToNever
# Property setter narrowing?
testCustomSetterNarrowingReWidened

# partials: OrderedDict
testInferOrderedDictInitializedToEmpty
# partials: No "Need type annotation for "X"", because untyped update exists
testInferDictInitializedToEmptyAndUpdatedFromMethodUnannotated
testCheckUntypedDefsSelf2
# partial for `x: Final = []`
testLiteralFinalErasureInMutableDatastructures2
# self.x = None in class is not partial anymore after finishing scope
testInferAttributeInitializedToNoneAndAssignedClassBody
# Mypy treats a None partial that is then assigned to a function as the function?? Wrong?
testRedefineFunctionDefinedAsVariableInitializedToNone
testRedefineNestedFunctionDefinedAsVariableInitializedToNone
# ClassVar/Final changes
testFinalUsedWithClassVarAfterPy313
testNamedTupleFinalAndClassVar
# ClassVar binding of callable with union
testClassVarUnionBoundOnInstance
# Final not allowed in loop
testFinalNotInLoops
final_with_getitem_in_loop

# Disjoint bases
testSlotsCompatibility
testDisjointBase
testDisjointBaseSlots
testIsInstanceDisjointBase
testIsInstanceAdHocIntersectionWithStrAndBytes
testSlotsAssignmentWithMixin

# Cannot assign to a method when assigning `self.method = lambda: None`
testSlotsAssignmentWithMethodReassign

# "Value of type "A" must be used"
# "Value of type "Coroutine[Any, Any, None]" must be used"
# "Are you missing an await?"
# --enable-error-code unused-awaitable
testUnusedAwaitable
testForwardRefToBadAsyncShouldNotCrash_newsemanal
# Crazy types.coroutine types/async await matrix
testFullCoroutineMatrix

# "Cannot determine type of" probably fine
testAccessGlobalVarBeforeItsTypeIsAvailable
testMultipassAndTopLevelVariable
testForwardReferenceToDecoratedClassMethod
testAccessingClassAttributeWithTypeInferenceIssue
testClassObjectsNotUnpackableWithoutIterableMetaclass
testErrorCodeCannotDetermineType
testColumnCannotDetermineType
testWalrusUsedBeforeDef
# "Cannot determine type of "X" in base class"
testCannotDetermineTypeInMultipleInheritance
# subtyping arbitrary length unpacks
testVariadicTupleSubtyping

# Name defined in parent scope
testListAssignmentUnequalAmountToUnpack
# Builtin overrides (Exception = Exception)
testConditionalExceptionAliasOverride

# TypedDict --extra-checks
testTypedDictUnpackStrictMode
testTypedDictStrictUpdate
testTypedDictFlexibleUpdateUnionStrict
testParamSpecConcatenateNamedArgs
testParamSpecPrefixSubtypingInvalidStrict
# TypedDict |
testTypedDictWith__or__method
testTypedDictWith__or__method_error
testTypedDictWith__ror__method
testTypedDictWith__ior__method
testTypedDictReadOnlyMutate__ior__Statements
testTypedDictReadOnlyMutate__or__Statements
# TypedDict update readonly
testTypedDictReadOnlyMutateMethods
testTypedDictFromTypingExtensionsReadOnlyMutateMethods
testTypedDictFromMypyExtensionsReadOnlyMutateMethods
# Functional TypedDict in class def
testCanCreateClassWithFunctionBasedTypedDictBase
# TypedDict Unpack
testUnpackKwargsInference
testUnpackKwargsParamSpec
# TypedDict dict unpacking
testTypedDictUnpackFromUnion
testTypedDictUnpackUnionRequiredMissing
testTypedDictUnpackIncompatible
# TypedDict Lookups
testTypedDictAsStarStarArgCalleeKwargs
testTypedDictAsStarStarAndDictAsStarStar
testTypedDictNonMappingMethods
# Nested typed dict formatting
testSerializeTypedDictInMethod
# TypedDict unions
testTypedDictChainedGetWithEmptyDictDefault
# TypedDict/Dict context
testTypedDictAssignableToWiderContext

# InitVar set default
testDataclassInitVarCannotBeSet
# dataclass weird replace case
testReplaceIsDataclass
# dataclass_transform __set__ descriptor needs to be type checked
testDataclassTransformUnsupportedDescriptors
# dataclass __replace__
testDunderReplacePresent

# "Type aliases are prohibited in protocol bodies"
testTypeAliasInProtocolBody
# Overloaded descriptors in protocols
testProtocolClassObjectDescriptor
testProtocolClassValDescriptor
# Protocol join preference
testExplicitProtocolJoinPreference
testProtocolCheckDefersNode
# Weird and unsound mypy cases for x: typing.TypeAlias = ...
testClassLevelTypeAliasesInUnusualContexts
testMalformedTypeAliasRuntimeReassignments

# Metaclass instance vs. class members
testInferenceOfDunderDictOnClassObjects

# Star import override of local scope
testImportStarWithinFunction
# Star import check what we override
testAssignAndConditionalStarImport
testStarImportOverlappingMismatch
# Star import redefinitions
testNewAnalyzerImportStarForwardRef1
testNewAnalyzerImportStarForwardRef2
testNewAnalyzerImportOverExistingInCycleStar1
testNewAnalyzerImportOverExistingInCycleStar2
testUnreachableAfterToplevelAssertImportThirdParty
testUnreachableAfterToplevelAssertImportThirdParty2

# lambda with generics
testInferenceAgainstGenericLambdas
testGenericLambdaGenericMethodNoCrash
testUninferableLambda
testUninferableLambdaWithTypeError
# lambda inferred: Cannot use a covariant type variable as a parameter
testRejectCovariantArgumentInLambda
# lambda override inference fails because of context given an instance callable
testLambdaInOverrideInference

# match statement different error
testMatchSequencePatternWithInvalidClassPattern
# match statement type merging
testMatchMiscNonExhaustiveReturn
# tuple falsey side narrowing
testMatchSequencePatternNegativeNarrowing
# enum custom eq splitting
testMatchLiteralPatternEnumCustomEquals-skip
# starred sequence matching
testMatchNarrowDownWithStarred-skip
# match "Alternative patterns bind different names"
testMatchOrPatternCapturesMissing
# match "Multiple assignments to name "x" in pattern"
testMatchCapturePatternMultipleCaptures
# match patterns additional narrowings
testMatchSubjectAssignExprWithGuard
# self matching str subclass
testMatchClassPatternCaptureSelfSubtype
testMatchAndWithStatementScope
# generalized object unpacking leads to any for attributes
testMatchClassPatternNonexistentKeyword
# Overriding match args details
testOverrideMatchArgs

# Check for deprecated overloads
testDeprecatedOverloadedFunction
# Different deprecated error
testDeprecatedOverloadedFunctionAlreadyDecorated

# ""return" not allowed in except* block" / continue break
testReturnInExceptStarBlock1
testReturnInExceptStarBlock2
testLambdaInExceptStarBlock
testContinueInExceptBlockNestedInExceptStarBlock
testReturnInExceptBlockNestedInExceptStarBlock
testBreakContinueReturnInExceptStarBlock1
testBreakContinueReturnInExceptStarBlock2

# TypeVar Values in func
testErrorCodeInvalidTypeArg
testCheckGenericFunctionBodyWithTypeVarValues2
testTypeInferenceAndTypeVarValues
testTypeDeclaredBasedOnTypeVarWithValues
testGenericTypeWithTypevarValuesAndTypevarArgument
testGenericTypeBodyWithTypevarValues
testAttributeInGenericTypeWithTypevarValues*
testMultipleClassTypevarsWithValues1
testGenericFunctionWithNormalAndRestrictedTypevar
testDefineAttributeInGenericMethodUsingTypeVarWithValues
testGenericTypeAliasesTypeVarConstraints
testTypevarValuesWithOverloadedFunctionSpecialCase
testLiteralAndGenericsRespectsValueRestriction
testTypeVarValuesFunction
testTypeVarValuesMethod1
testTypeVarValuesMethod2
testTypingSelfWithValuesExpansion
testOverloadingInferUnionReturnWithTypevarsAndValueRestrictions
testColumnFunctionWithTypeVarValues
testSuperWithTypeVarValues1
testSuperWithTypeVarValues2
testInnerFunctionWithTypevarValues
testInnerFunctionMutualRecursionWithTypevarValues
testNestedDecoratedCoroutineAndTypeVarValues
testReverseOperatorTypeVar2b
testIsinstanceAndTypeVarValues*
testIsinstanceWithUserDefinedTypeAndTypeVarValues
testIsinstanceWithUserDefinedTypeAndTypeVarValues
testIsinstanceWithUserDefinedTypeAndTypeVarValues2
testNarrowingIsSubclassFinalSubclassWithTypeVar
testOperatorContainsNarrowsTypedDicts_total
testUnreachableFlagWithGenerics
testNarrowOnSelfInGeneric
testIsInstanceAdHocIntersectionGenericsWithValues
testIsInstanceAdHocIntersectionGenericsWithValuesDirectReturn
testCallableTypeVarUnion
testGenericFunctionAliasExpand
testGenericFunctionMemberExpand
testTypeVarValuesNarrowing
testConstrainedGenericSuper
testTypingSelfOnSuperTypeVarValues
testMatchValueConstrainedTypeVar
# type var values syntax
testPEP695ValueRestriction
testPEP695ValueRestrictionForwardReference

# ini config multiline
mypy_ini_exclude_multi_line_verbose_regex

# ------------- Additional unimportant, but would be nice -----------------

# Uses an environment variable in mypy.ini files=$MYPY_CONFIG_FILE_DIR/good.py
testEnvvar_MYPY_CONFIG_FILE_DIR

# "NamedTuple type as an attribute is not supported"
testAssignNamedTupleAsAttribute
testNoCrashUnsupportedNamedTuple
testNamedTupleAsClassMemberNoCrash
# "Enum type as attribute is not supported"
testAssignEnumAsAttribute
testEnumAsClassMemberNoCrash
# "TypedDict type as attribute is not supported"
testAssignTypedDictAsAttribute

# Tuple type comment definitions with list assignment
testMultipleAssignmentWithListsInInitialization
testAssignmentToStarAnnotation
# Tuple type comment with None should not be checked like x, y = None, None  # type: int, str
testMultipleAssignmentNoneClassVariableInInit
# star input for tuple
testTupleWithStarExpr
# List literal inference that works like a tuple? (x, y) = [1, ""]
testInferringLvarTypesInNestedListAssignment
testNestedListAssignment
testNestedListAssignmentToTuple
testMultiModuleAlias
# Tuple a, *li = ta: "List item 0 has incompatible type "A"; expected "int""
testAssignmentToStarFromTupleType
# empty tuple as iterator ("Need type annotation for "x"")
testAssignmentToStarMissingAnnotation
testForLoopOverEmptyTuple

# Type var constraints not enforced in type alias
testValidTypeAliasValues

# functools.partial
testFunctoolsPartialBasic
testFunctoolsPartialStar
testFunctoolsPartialGeneric
testFunctoolsPartialCallable
testFunctoolsPartialTypeGuard
testFunctoolsPartialType
testFunctoolsPartialTypeVarTuple
testFunctoolsPartialUnion
testFunctoolsPartialTypeObject
testFunctoolsPartialAbstractType
testFunctoolsPartialTypeVarValues
testBindPartial
testBindPartialConcatenate
testIncrementalFunctoolsPartial
testFunctoolsPartialTypedDictUnpack
testFunctoolsPartialExplicitType
testFunctoolsPartialNestedPartial
testFunctoolsPartialNestedGeneric
testFunctoolsPartialClassObjectMatchingPartial
testFineGrainedFunctoolsPartial
testFunctoolsPartialTypeVarErasure
testOtherVarArgs

# Forward name binder reference in class
testNewAnalyzerNamedTupleCallNested
testForwardNestedPrecedesForwardGlobal
# forwards references/type comments name binding of type definitions within function scopes
testForwardBoundFunctionScopeWorks
testIncrementalNestedTypeAlias
testSerializeNamedTupleInMethod4
testDeclarationReferenceToNestedClass
testNewAnalyzerNamedTupleCallNestedMethod
testGenericClassWithinFunction
testGenericClassWithInvalidTypevarUseWithinFunction
# Recursive alias forward reference in class scope
testRecursiveClassLevelAlias
# Name binder MYPY/platform/TYPE_CHECKING etc
testMypyFalseValuesInBinaryOps_no_empty

# Assignment like ac[b] += c with both __getitem__ and __setitem__ has same error twice
testOperatorAssignmentWithIndexLvalue1

# NotImplemented
testReturnAnyForNotImplementedInNormalMethods

# NewType in function "A@6" as qualified name
testNewTypeInLocalScope
# qualified name in function contains class path: __main__.Cls.FooEnum@4
testAnonymousFunctionalEnum
testNewAnalyzerIncrementalMethodNamedTuple
testNewAnalyzerNamedTupleClassNestedMethod
testNoIncrementalCrashOnTypedDictMethod
# Nicer Callable Errors
testCallableParsingFromExpr
testCallableParsing
testCallableTooManyVarArg
testCallableKindsOrdering
testCallableFastParseBadArgArgName
# Separate formatting for ambigous names???
testIncompatibleAssignmentAmbiguousShortnames
# for long tuples: "Expression tuple item 8 has type "str"; "int" expected;"
testAssigningWithLongTupleInitializer
testPropertyLongTupleReturnTypeMismatchUnion
testPropertyLongTupleReturnTypeMismatchUnionWiderExpected
# large union formatting like "Incompatible types in assignment (expression has type "C1 | C2 | C3 | C4 | C5 | <6 more items>", variable has type "int")"
testLargeUnionsShort
testLargeUnionsLongIfNeeded
testLargeUnionsNoneShown
# Formatting for callable mismatches
testDistinctFormatting
testDistinctFormattingUnion
testSubtypingFunctionsTrivialSuffixRequired
testSubtypingFunctionsTrivialSuffixOptional

# "Call to abstract method "meth" of "Proto" with trivial body via super() is unsafe"
testEmptyBodyUnsafeAbstractSuperOverloads
testEmptyBodyUnsafeAbstractSuperProperty
testSuperWithAbstractProperty
testIgnoreErrorsWithUnsafeSuperCall_no_empty
testMixinProtocolSuper
testAbstractOverloadsWithoutImplementationAllowed
# "Only concrete class can be given where "Type[C]" is expected"
testDedicatedErrorCodeTypeAbstract
testAbstractTypeInADict
testInstantiationAbstractsInTypeForFunctions
testInstantiationAbstractsInTypeForAliases
# "Can only assign concrete classes to a variable of type "Type[A]""
testInstantiationAbstractsInTypeForVariables
# Dictionary part of abstract class: "Cannot instantiate abstract class "C" with abstract attribute "f""
testSubclassOfABCFromDictionary
# Mapping[str, str](): "Cannot instantiate abstract class "Mapping" with abstract attribute "...""
testAbstractNewTypeAllowed

# Module <M> has no attribute <missing_name>; maybe <name>
testNewAnalyzerTypeAnnotationCycle3
testModuleAttributeTwoSuggestions
testModuleAttributeThreeSuggestions
testImportMisspellingSingleCandidate
testImportMisspellingMultipleCandidates
testImportMisspellingMultipleCandidatesTruncated
testColumnHasNoAttribute
testErrorCodeNoAttribute
testDequeWrongCase
# "C" has no attribute "__aenter__"; maybe "__enter__"?
testAsyncWithError
# Unexpected keyword argument "otter" for "f"; did you mean "other"?
testMultipleKeywordsForMisspelling
testKeywordMisspelling*
# "TypedDict "XXX" has no key "xxx" note: Did you mean "type"?"
testCannotGetItemOfTypedDictWithInvalidStringLiteralKey
# "Perhaps you need a type annotation for "x"? Suggestion: "List[str | int]""
testInferredTypeSubTypeOfReturnType

# `import a.b # type: ignore` means that the attribute is later Any without error
testAddedMissingStubsIgnorePackagePartial
testFineAddedMissingStubsIgnorePackagePartial
# ignore_missing_imports in Mypy overrides ignores import errors if those modules are not presents
testModuleGetattrInit10
testIgnoreErrorFromMissingStubs2
testModuleGetattrInit10PyProjectTOML
testMultipleModulesInOverridePyProjectTOML

# __init__ None needed
testInitReturnTypeError
# "Accessing "__init__" on an instance is unsound, since instance.__init__ could be from an incompatible subclass"
testAccessingInit
# "Unsupported decorated constructor type"
testDecoratedConstructorsBad
# type.__init__ where self is implicitly Any
testTypeEquivalentTypeAnyEdgeCase

# __init_subclass__
testNoClassKeywordsForNamedTuple
testTypedDictWithClassLevelKeywords

# - The implementation for an overloaded function must come last
testInconsistentOverload
testInconsistentOverload2
# Non consecutive overloads
testNonconsecutiveOverloads
testNonconsecutiveOverloadsMissingFirstOverload
testNonconsecutiveOverloadsMissingLaterOverload
# @overload: "Condition cannot be inferred, unable to merge overloads"
testOverloadIfSplitFunctionDef
testOverloadIfMixed
testOverloadIfUnconditionalFuncDef
testOverloadIfBasic
testOverloadIfNotMerging
testOverloadIfElse
testOverloadIfElse2
testOverloadIfElse3
testOverloadIfSkipUnknownExecution
testOverloadIfDontSkipUnrelatedOverload
testOverloadIfNotMergingDifferentNames
testOverloadIfNestedOk
testOverloadIfNestedFailure

# type ignore leads to "Revealed type is "A?""
testSerializeIgnoredInvalidType
# bad type: ignore
testErrorCodeBadIgnore
testErrorCodeBadIgnoreNoExtraComment
# --warn-unused-ignores
# "Unused "type: ignore" comment"
testErrorCodeWarnUnusedIgnores1
testErrorCodeWarnUnusedIgnores2
testErrorCodeWarnUnusedIgnores3
testErrorCodeWarnUnusedIgnores4
testErrorCodeWarnUnusedIgnores5
testErrorCodeWarnUnusedIgnores6_NoDetailWhenSingleErrorCode
testErrorCodeWarnUnusedIgnores7_WarnWhenErrorCodeDisabled
testMethodAssignCoveredByAssignmentUnused
testUnusedIgnoreTryExcept
testUnusedIgnoreEnableCode
testIgnoreDecoratedFunction1
testIgnoreScopeUnused1
testIgnoreScopeUnused2
testIgnoreScopeUnused3
testUnusedIgnoreVersionCheck
testUnusedTypeIgnore
testUnusedTypeIgnoreImport
testUnusedTypeIgnorePreservedAfterChange
testInlineConfigBaseCaseWui
testInlineConfigIsntRuinedByOthersInvalidWui
# --warn-unused-ignores whole module
testIgnoreWholeModule1
testImportUnusedIgnore2
# --enable-error-code ignore-without-code
testErrorCodeMissingWhenRequired
testErrorCodeMissingDoesntTrampleUnusedIgnoresWarning
testErrorCodeMissingWholeFileIgnores
testErrorCodeMissingMultiple
testInlineErrorCodes
testInlineErrorCodesMultipleCodes
testInlineErrorCodesOverrideConfig
testPerModuleErrorCodesOverride
testTypeIgnoreWithoutCodePreservedAfterChange
testConfigFileErrorCodesOnAndOff
# type: ignore blocking errors cannot be ignored: ""yield" outside function"
testCannotIgnoreBlockingError
# type: ignore on forward reference
testErrorCodeSyntaxErrorIgnoreNote
# type: ignore on call silences errors in call, even if not on same line?!
testMultiLineMethodOverridingWithIncompatibleTypesIgnorableAtDefinition
# Error code "literal-required" not covered by "type: ignore" comment
testNoteAboutChangedTypedDictErrorCode

# "mypy: "tmp/typing.py" shadows library module "typing""
testShadowTypingModule

# Invalid __all__
testAllMustBeSequenceStr
testAllMustBeSequenceStr2
testAllMustBeSequenceStr3
testModuleAllEmptyList
# Slots weird type inference
testSlotsEmptyList
testSlotsEmptySet


# --show-column-numbers and tuple targets
testColumnsAssignment

# --enable-error-code explicit-override "Method "prop" is not using @override but is overriding a method in class "__main__.A""
requireExplicitOverrideOverload
# @override untyped "Method "foo" is marked as an override, but no base method was found with this name"
testOverrideUntypedDef

# "Incompatible types in string interpolation (expression has type "str", placeholder has type "int")"
testErrorCodeFormatCall

# "Duplicate argument "x" in function definition"
testFastParserDuplicateNames
# Lambda inferred like (lambda x: x)(1)
testInferLambdaTypeUsingContext
# Generator in lambda
testNoCrashOnLambdaGenerator

# tuple type is not initializable (though it probably should)
testTypeUsingTypeCErrorUnsupportedType
testTypeUsingTypeCTuple

# ""break" outside loop" for untyped functions
testBreakOutsideLoop
testNoCrashOnBreakOutsideLoopFunction
testNoCrashOnBreakOutsideLoopClass
testContinueOutsideLoop

# --report-deprecated-as-note
testDeprecatedAsNoteWithErrorCode
# --deprecated-calls-exclude
testDeprecatedExclude

# "Maybe you forgot to use "await"?" (currently ignored)
#testAsyncForErrorNote
#testAwaitMissingNote
#testAsyncForErrorNote

# - (with type vars) Overloaded function signatures 2 and 3 overlap with incompatible return types
#testOverloadMultipleVarargDefinitionComplex
#testOverloadPartialOverlapWithUnrestrictedTypeVar
#testOverloadPartialOverlapWithUnrestrictedTypeVarNested
#testOverloadedPartiallyOverlappingTypeVarsAndUnion
# Overlapping general
#testManyUnionsInOverload
#testOverloadInferUnionReturnFunctionsWithKwargs
#testOverloadWithOverlappingItemsAndAnyArgument5
#testIntersectionTypesAndVarArgs
#testLiteralInferredInOverloadContextWithTypevars
#testLiteralSubtypeOverlap
#testOverloadsAndNoneWithoutStrictOptional
#testOverloadsAndNoneWithStrictOptional
#testTypeTypeOverlapsWithObjectAndType
#testTypeOverlapsWithObject
#testAccessingGenericDescriptorFromInferredClass
#testAccessingGenericDescriptorFromClass
#testOverloadWithNonGenericDescriptorLookalike
#testOverloadWithGenericDescriptor
#testUnpackIterableClassWithOverloadedIter2
testOverloadOverlapWithTypeVarsWithValues
testUnsafeOverlappingNotWithAny
# Overlap + "N: Flipping the order of overloads will fix this error"
#testTypeCheckOverloadImplementationTypeVarDifferingUsage2
#testOverloadPossibleOverlapMixingNamedArgsWithKwargs3
#testOverloadWithPartiallyOverlappingUnionsNested
#testOverloadedPartiallyOverlappingTypeVarsAndUnion
#testAwaitOverloadSpecialCase

# ------------------- priority? tests -----------------------

# All members in a union lead to the enum again
testEnumTypeCompatibleWithLiteralUnion
testTypeGuardedTypeDoesNotLeak
testLiteralUnionEnumAliasAssignable
# Enum Dict value inferred is int instead of Literal[1]
testFunctionalEnumListOfPairs
# "Detected enum "lib.D" in a type stub with zero members. There is a chance this is due to a recent change in the semantics of enum membership
testEnumNotFinalWithMethodsAndUninitializedValuesStub
# Enum value wrong order in lookup
testEnumAccessFromInstance
# Enum reachability with underscore member
testSingleUnderscoreNameEnumMember
# Enum _value_?
testSunderValueTypeEllipsis
testSunderValueTypeEllipsisNonStub

# "NoneType should not be used as a type, please use None instead"
testNoneTypeWarning

# Template strings
testTemplateString

# future imports (future is not part of stubs)
testNewAnalyzerMetaclassFuture1
testNewAnalyzerMetaclassFuture3
testNewAnalyzerMetaclassFuture4
testFutureMetaclass
testFromFutureMetaclass
testFutureMetaclassImportFrom
testFutureMetaclassImport
testFutureMetaclassAndBase
testFutureMetaclassGenerics
testFutureMetaclassErrors
testFutureMetaclassAny
# six imports
testNewAnalyzerMetaclassSix1
testNewAnalyzerMetaclassSix2
testNewAnalyzerMetaclassSix3
testNewAnalyzerMetaclassSix4
testSixMetaclassImportFrom
testSixMetaclassImport
testSixMetaclassAndBase
testSixMetaclassGenerics
testSixMetaclassErrors
testSixMetaclassAny
testSixMetaclass
testFromSixMetaclass
testSixMetaclassGenericBase
testIgnoreInsideClassDoesntAffectWhole
testMultipleMetaclasses
# import of typeshed stubs
testErrorFromGoogleCloud

# typing.assert_type in untyped functions
testAssertTypeUncheckedFunction
# "Only @runtime_checkable protocols can be used with instance and class checks" in untyped functions
testOverloadOnProtocol
# function type mismatch when untyped
testSubtypingFunctionsImplicitNames

# Probably fixed eventually by updating mypy or typeshed
testDecoratorTypeAfterReprocessing

# attrs
testAttrs*
updateMagicField
magicAttributeConsistency
magicAttributeConsistency2-only_when_cache
testDisallowIncompleteDefsAttrsNoAnnotations
testDisallowIncompleteDefsAttrsWithAnnotations
testDisallowIncompleteDefsAttrsPartialAnnotations

# ctypes
testCtypesArrayStandardElementType
testCtypesArrayCustomElementType
testCtypesArrayUnionElementType
testCtypesCharArrayAttrs
testCtypesWcharArrayAttrs
testCtypesCharUnionArrayAttrs
testCtypesAnyUnionArrayAttrs
testCtypesOtherUnionArrayAttrs
testCtypesOtherArrayAttrs

# singledispatch
testIncorrectDispatchArgumentWhenDoesntMatchFallback
testCheckNonDispatchArgumentsWithTypeAlwaysTheSame
testImplementationHasSameDispatchTypeAsFallback-xfail
testRegisterHasDifferentTypeThanTypeSignature-xfail
testTypePassedAsArgumentToRegister
testCustomClassPassedAsTypeToRegister
testOnePartOfUnionDoesNotHaveCorrespondingImplementation
testIncorrectArgumentsInSingledispatchFunctionDefinition
testDispatchTypeIsNotASubtypeOfFallbackFirstArgument
testAnyInConstructorArgsWithClassPassedToRegister
testIncorrectArgumentTypeWhenCallingRegisteredImplDirectly
testDontCrashWhenRegisteringAfterError

# OrderedDict = _Alias()
testTypingExtensionsOrderedDictAlias

# --enable-incomplete-feature=PreciseTupleTypes
testTupleWithStarExpr2Precise
testTupleWithStarExpr3Precise
testVariadicTupleConcatenation
testPackingVariadicTuplesHomogeneous
testVariadicTupleContextNoCrash
testVariadicTupleInTupleContext
# mypy: enable-incomplete-feature=NewGenericSyntax
testPEP695IncompleteFeatureIsAcceptedButHasNoEffect

# Not all modules are checked in mypy: `# cmd: mypy -m m`
testTypeCheckNamedModule4
testTypeCheckNamedModule5
testTypeCheckNamedModuleWithImportCycle
testStubImportNonStubWhileSilent
# cmd: mypy a.py
testErrorInReAddedModule
testFollowImportsNormalPackageInitFileStub
# Not all modules are checked even in default mypy
testPreferPackageOverFile
testPreferPackageOverFile2
testNotPreferPackageOverFileCase
testFollowImportsNormalDeleteFile4
testFollowImportsNormalDeleteFile5
testFollowImportsNormalDeleteFile6
testFollowImportsNormalDeleteFile7
testSubmoduleMixingImportFromAndImport
testSubmoduleImportFromDoesNotAddParents

# import missing --follow-imports=normal
testIncrementalNestedBrokenCascade
# --follow-imports=error
testImportSuppressedWhileAlmostSilent
testAncestorSuppressedWhileAlmostSilent
testErrorButDontIgnore1
testErrorButDontIgnore2
testErrorButDontIgnore3-skip
testErrorButDontIgnore4
testIncrementalFollowImportsError
testFollowImportsError
testFollowImportsSelective
# --follow-imports=silent
testIncrementalFollowImportsSilent
testIncrementalWithSilentImports
testFollowImportsSilent
# --follow-imports=skip
testIncrementalUnsilencingModule
testIncrementalWithSilentImportsAndIgnore
testIncrementalSilentImportsWithBlatantError
testIncrementalImportIsNewlySilenced
testIncrementalSilencedModuleNoLongerCausesError
testIncrementalFollowImportsSkip
testFollowImportSkipNotInvalidatedOnAddedStubOnFollowForStubs
testAddedSkippedStubsPackageFrom
testAddPackage6
testAddPackage7
testSkipImports
testSkipImportsWithinPackage
testSkipButDontIgnore1
testSkipButDontIgnore2
testFineFollowImportSkipInvalidatedOnAddedStub-skip
testFineAddedSkippedStubsPackageFrom
testFileAddedAndImported
testFileAddedAndImported2
testDeleteFileWithErrors
testDoNotFollowImportToNonStubFile
testFollowImportsSkip
testSubclassingAnySilentImports
testSubclassingAnySilentImports2
testIncrementalFollowImportsVariable
testIncrementalFollowImportsVariablePyProjectTOML
testClassScopeImportWithFollowImports
testMissingSubmoduleImportedWithIgnoreMissingImportsStub
# --no-site-packages
testTypedPkg_config_nositepackages
testTypedPkg_args_nositepackages
testTypedPkgNoSitePkgsIgnoredImports
# "Skipping analyzing "typedpkg_ns.b.bbb": module is installed, but missing library stubs or py.typed marker"
testNamespacePkgWStubs
testTypedNamespaceSubpackage
# __import__("pkg_resources").declare_namespace(__name__)
testNamespacePkgWStubsWithNamespacePackagesFlag
testTypedPkgNamespaceImportFrom
testTypedPkgNamespaceImportAs
testTypedPkgNamespaceRegImport

# --enable-error-code redundant-self
# "Redundant "Self" annotation for the first method argument"
testTypingSelfRedundantWarning
testTypingSelfRedundantWarning_pep585
# --enable-error-code redundant-expr
# "If condition is always false"
testRedundantExpressions
# flags: --enable-error-code truthy-bool
testTruthyBool
testTruthyFunctions
testTruthyIterable
testInlineErrorCodesOverrideConfigSmall2
testInlineErrorCodesOverrideConfigSmallBackward
testInlineOverrideConfig
# flags: --disable-error-code truthy-bool
testDisableEnableErrorCodesIncremental
# flags: --enable-error-code=mutable-override: "Covariant override of a mutable attribute (base class "C" defined the type as "float", expression has type "int")"
testCovariantMutableOverride
testOverrideCallableAttributeWithMethodMutableOverride
testOverrideCallableUnionAttributeWithMethodMutableOverride
testDunderReplaceCovariantOverride
# flags: --allow-untyped-globals
testPermissiveAttributeOverride1
testPermissiveAttributeOverride2

# "Method cannot have explicit self annotation and Self type"
testTypingSelfConflict

# 3.12 type alias name binding in Mypy is special (maybe not wanted)
testPEP695TypeAliasNotReadyClass
testPEP695TypeAliasRecursiveOuterClass
testPEP695TypeAliasRecursiveInvalid
# 3.12 Nested class Type Vars in bounds disallowed, in old-style classes this is possible
testPEP695CannotUseTypeVarFromOuterClass


# ------------------- start of low-prio/won't do tests -----------------------

# "Name "C" is used before definition"
testBanPathologicalRecursiveTuples
testDefinedDifferentBranchUsedBeforeDef
testUsedBeforeDefBuiltinsGlobal
testUsedBeforeDefBuiltinsMultipass
testUsedBeforeDefImplicitModuleAttrs
# --enable-error-code possibly-undefined "Name "x" may be undefined"
testPossiblyUndefinedWithAssignmentExpr
check-possibly-undefined:testDefinedInOneBranch
check-possibly-undefined:testElif
check-possibly-undefined:testUsedInIf
check-possibly-undefined:testOmittedElse
check-possibly-undefined:testUpdatedInIf
check-possibly-undefined:testNestedIf
check-possibly-undefined:testVeryNestedIf
check-possibly-undefined:testTupleUnpack
check-possibly-undefined:testIndexExpr
check-possibly-undefined:testFunction
check-possibly-undefined:testLambda
check-possibly-undefined:testUsedBeforeDefClass
check-possibly-undefined:testGenerator
check-possibly-undefined:testScope
check-possibly-undefined:testVarFromOuterScopeRedefined
check-possibly-undefined:testWhile
check-possibly-undefined:testForLoop
check-possibly-undefined:testReturn
check-possibly-undefined:testPossiblyUndefinedLoop
check-possibly-undefined:testAssert
check-possibly-undefined:testRaise
check-possibly-undefined:testContinue
check-possibly-undefined:testBreak
check-possibly-undefined:testTryBasic
check-possibly-undefined:testTryMultiExcept
check-possibly-undefined:testTryFinally
check-possibly-undefined:testTryElse
check-possibly-undefined:testDictComprehension
check-possibly-undefined:testUntypedDefCheckUntypedDefs
check-possibly-undefined:testClassBody
check-possibly-undefined:testUntypedDef
check-possibly-undefined:testNoReturn
check-python310:testPossiblyUndefinedMatch
check-python310:testPossiblyUndefinedMatchUnreachable

# Different but fine diagnostics
testTypedDictFinalAndClassVar

# `for ... in` type comment
testRefreshForWithTypeComment1
testRefreshForWithTypeComment2
testForStatementTypeComments
testForStatementMultipleTypeComments
testForIndex
testForIndexInClassBody
testErrorCodeSyntaxError3
testAsyncForTypeComments
# with type comment
testWithStmt
testWithStmtInClassBody
testWithStmtTypeComment
testWithStmtTupleTypeComment
testWithStmtComplexTypeComment
testAsyncWithTypeComments
testNewAnalyzerTypeArgBoundCheckDifferentNodes
testForwardRefsInWithStatement

# binder probably deferred issues
testLocalPartialTypesWithNestedFunction3

# "note: "f" is implicitly abstract because it has an empty function body. If it is not meant to be abstract, explicitly `return` or `return None`."
testEmptyBodyNoneCompatibleProtocol
# "note: Looks like the first special argument in a method is not named "self", "cls", or "mcs", maybe it is missing?"
testErrorMessageAboutSelf

# "unknown encoding: uft-8"
testInvalidEncoding
testInvalidEncoding2
testInvalidEncoding3
testDoubleEncoding
testDoubleEncoding2
# coding: ascii
testDecodeErrorBlocker1-posix
testDecodeErrorBlocker2-windows
testDecodeErrorBlockerOnInitialRun-posix

# "Syntax error in type annotation"
# Suggestion: Use tuple[T1, ..., Tn] instead of (T1, ..., Tn)
testImplicitTuple2
# "Suggestion: Use tuple[()] instead of () for an empty tuple, or None for a function without a return value"
testReturnEmptyTuple
# "Suggestion: Is there a spurious trailing comma?"
testColumnSyntaxErrorInTypeAnnotation
# Syntax error in type comment, because used `# type:` twice
testErrorCodeTypeIgnoreMisspelled2
# SyntaxError "Assignment expression within a comprehension cannot be used in a class body"
testNoCrashOnAssignmentExprClass

# invalid syntax, and therefore name errors, names should probably be Any
testModifyTwoFilesIntroduceTwoBlockingErrors

# All of these are really not important at all, because there are syntax
# errors, just not the fancy ones.
# Too many invalid syntax errors?
testInvalidFunction
testInvalidFuncDefArgs3
testInvalidFuncDefArgs4
testExceptCommaInPython3
# "unexpected indent"
testUnexpectedIndent
testInconsistentIndent
# "unindent does not match any outer indentation level"
testInconsistentIndent2
# "unexpected EOF while parsing"
testUnexpectedEof
testParseErrorInExtendedSlicing
testParseErrorInExtendedSlicing2
testParseErrorInExtendedSlicing3
# "positional argument follows keyword argument"
testInvalidKeywordArguments1
# "positional argument follows keyword argument unpacking"
testInvalidKeywordArguments2
# "named arguments must follow bare *"
testInvalidBareAsteriskAndVarArgs4
testInvalidBareAsterisk1
testInvalidBareAsterisk2
# "non-default argument follows default argument"
testInvalidFuncDefArgs1
# "invalid syntax. Perhaps you forgot a comma?"
testNotAsBinaryOp
testBinaryNegAsBinaryOp
testErrorCodeSyntaxError
testUpdateClassReferenceAcrossBlockingError
testAddFileWithBlockingError
testBlockingErrorRemainsUnfixed
testDeleteFileWithBlockingError-only_when_nocache
testDeleteFileWithBlockingError2-only_when_cache
testModifyFileWhileBlockingErrorElsewhere
testInitialBlocker
# "cannot delete function call"
testInvalidDel1
# "cannot delete expression"
testInvalidDel2
# "cannot assign to function call here. Maybe you meant '==' instead of '='?"
testInvalidLvalueWithExplicitType
testInvalidTypeDeclaration
# "Cannot assign to literal"
testInvalidWithTarget
# "cannot assign to literal here. Maybe you meant '==' instead of '='?"
testInvalidLvalues*
testInvalidTypeAnnotation2
# "cannot delete expression"
testDelMultipleThingsInvalid
# "Missing parentheses in call to 'print'. Did you mean print(1)?"
testPrintStatementInPython3
# "invalid character in identifier"
testSmartQuotes
# "expected ':'"
testParseError
testParseErrorMultipleTimes
testBlockingErrorWithPreviousError
# '(' was never closed
testMissingBracket

# Needs lib-stub/blocker.pyi
testImportBringsAnotherFileWithBlockingError1
testImportBringsAnotherFileWithSemanticAnalysisBlockingError
testFixingBlockingErrorBringsInAnotherModuleWithBlocker

# "Not all union combinations were tried because there are too many unions"
testTooManyUnionsException

# Note ""<Foo>.__call__" has type "Callable[[Arg(str, 'x'), VarArg(int)], None]"
# Curently ignored

# Additional questionable cases of "Signatures of "__ior__" and "__or__" are incompatible"
testGenericOperatorMethodOverlapping2
testOverloadedNormalAndInplaceOperatorMethod

# Final Literal[str] = "foo" is suddenly a Literal['foo']?
testEnumCreatedFromFinalValue

# "Access to generic class variables is ambiguous" (unimportant, because similar lint exists)
testClassVarWithGeneric
testClassVarWithNestedGeneric
# ""foo" is considered instance variable, to make it class variable use ClassVar[...]"
testSuggestClassVarOnTooFewArgumentsMethod

# Create a class with a base class based on Type[..] of self.foo
testNewAnalyzerUnsupportedBaseClassInsideFunction

# type checking ok, priority low "Cannot assign multiple modules to name "..." without explicit "types.ModuleType" annotation"
testModuleAliasRepeated
testModuleAliasRepeatedComplex
testModuleAliasToOtherModule
testModuleAliasToQualifiedImport2

# NameBinder questionable unreachable usages
testRaiseStatement
reachability_no_mypy_compatible

# My own hard/special tests
class_context_super_class
namedtuple__new__
generic_method_on_class_access_no_overload
generic_method_on_class_access_overload
type_type_alias_circular

# Weird native types of mypy like `from mypy_extensions import i64, i32`
testNativeIntTypes

# --enable-incomplete-feature=InlineTypedDict
testTypedDictInlineYesNewStyleAlias
testCannotCreateTypedDictInstanceWithInlineTypedDict
testTypedDictInlineNoOldStyleAlias
testTypedDictInlineYesMidStyleAlias
testTypedDictInlineNotRequired
testTypedDictInlineNestedSchema
testTypedDictInlineMergeAnother
testTypedDictInlineReadOnly

# Mypy plugins
testChangedPluginsInvalidateCache
testChangedPluginsInvalidateCache2
testAddedPluginsInvalidateCache
testRemovedPluginsInvalidateCache
testPluginConfigData
testIncrementalAddClassMethodPlugin
testIncrementalAddOverloadedMethodPlugin

# Won't support for now --show-error-code-links
testShowErrorCodeLinks

# --allow-redefinition
testReusingInferredForIndex2
testRedefineLocalWithinExceptStarTryClauses
testMatchSubjectRedefinition

# Type aliases should not be redefined
type_alias_redefine_with_var_not_possible
# --allow-redefinition-new
testNewRedefinePartialNoneEmptyList
testNewRedefinePartialTypeForUnderscore
# --allow-redefinition-new global/nonlocal
testNewRedefineGlobalVariableSimple
testNewRedefineGlobalVariableNoneInit
testNewRedefineNestedFunctionBasics
# --allow-redefinition-new are list redefinitions ok? questionable
testNewRedefinePartialGenericTypes
# --alow-redefinition-new implementation details, that are probably not important
testNewRedefineWithoutLocalPartialTypes
testNewRedefineImportFrom-xfail
# Multiple different flags in test
testNewRedefineAffectsCache
# module __getattr__ is considered a redefinition
testModuleLevelGetattrImportFromAsTwice

# --no-strict-optional details
testUnreachableWhenSuperclassIsAnyNoStrictOptional
testUnreachableWithStdlibContextManagersNoStrictOptional
testInitializationWithMultipleValues
testNamedTupleAsConditionalStrictOptionalDisabled
testMeetOfIncompatibleProtocols
testIssubclassWithMetaclasses
testImportAndAssignToModule
testSerializeDummyType

# --untyped-calls-exclude=bar.A
testDisallowUntypedCallsAllowListFlags
testDisallowUntypedCallsAllowListConfig

# --disallow-any-expr
testDoNotLimitErrorVolumeIfNotImportErrors
testDisallowAnyExprIncremental
testDisallowAnyExprUnannotatedFunction
testDisallowAnyExprSimple
testDisallowAnyExprExplicitAnyParam
testDisallowAnyExprAllowsAnyInCast
testDisallowAnyExprAllowsAnyInVariableAssignmentWithExplicitTypeAnnotation
testDisallowAnyExprGeneric

# --disallow-any-unimported
testErrorCodeAnyFromUnfollowedImport
testDisallowImplicitTypesIgnoreMissingTypes
testDisallowImplicitTypes
testDisallowImplicitAnyVariableDefinition
testDisallowImplicitAnyGeneric
testDisallowImplicitAnyInherit
testDisallowImplicitAnyAlias
testDisallowImplicitAnyCast
testDisallowImplicitAnyNamedTuple
testDisallowImplicitAnyTypeVarConstraints
testDisallowImplicitAnyNewType
testDisallowImplicitAnyCallableAndTuple
testDisallowImplicitAnySubclassingExplicitAny
testDisallowImplicitAnyVarDeclaration
testDisallowUnimportedAnyTypedDictSimple
testDisallowUnimportedAnyTypedDictGeneric
testNoCrashOnUnImportedAnyNotRequired
testRecursiveAliasesWithAnyUnimported
testTypedDictRequiredUnimportedAny

# --no-namespace-packages
testClassicNotPackage
testPackageWithoutInitFile
testDeletePackage4
testDeletePackage5
testDeletePackage6

# --soft-error-limit
testLimitLegacyStubErrorVolume

# --show-error-context
testNewAnalyzerTypeArgBoundCheckWithContext
testShowErrorContextFunction
testShowErrorContextClass
testShowErrorContextMember
testShowErrorContextModule
testShowErrorContextTopLevel
testShowErrorContextFromHere
testCheckFunctionErrorContextDuplicateDeferred

# --pretty
testReprocessMethodShowSource
testGenericTypeAliasesWithNestedArgs
testPrettyMessageSorting
testParseErrorShowSource
testDictExpressionErrorLocations
testEndColumnsWithTooManyTypeVars
testPropertyNameAndAttributeIsCheckedPretty

# --no-silence-site-packages
testAddFileWhichImportsLibModuleWithErrors

# Won't support for now: "t" is a type variable and only valid in type context
testExpressionRefersToTypeVariable

# Won't support for now: "Use `from typing_extensions import _FutureFeatureFixture` instead"
testTypingExtensionsSuggestion

# Probably won't support: invalid version numbers for # flags: --python-version 3.99
testFeatureVersionSuggestion

# Probably won't support: NamedTuple subclass narrowing, this won't be
# supported, once PreciseTupleTypes is a complete feature.
testNarrowingLenTupleSubclass

# Probably won't support: typing._promote
testListWithDucktypeCompatibility
testListWithDucktypeCompatibilityAndTransitivity
testSimpleDucktypeDecorator
testDucktypeTransitivityDecorator
testOverloadingAndDucktypeCompatibility

# Probably won't support: Type comments for params
testFastParsePerArgumentAnnotations
testFastParsePerArgumentAnnotationsWithReturn
testFastParsePerArgumentAnnotationsWithAnnotatedBareStar
testFastParsePerArgumentAnnotationsWithReturnAndBareStar

# Tuple comment syntax: Incompatible number of tuple items
testVariableDeclWithInvalidNumberOfTypes
testVariableDeclWithInvalidNumberOfTypesNested
testVariableDeclWithInvalidNumberOfTypesNested2
testVariableDeclWithInvalidNumberOfTypesNested4
# Tuple comment syntax: tuple type expected for multiple variables
testVariableDeclWithInvalidType
testVariableDeclWithInvalidNumberOfTypesNested3
testVariableDeclWithInvalidNumberOfTypesNested5
# Won't support: Signature Comments
testIncompatibleSignatureInComment
testFunctionSignatureAsComment
testMethodSignatureAsComment
testVarArgsAndCommentSignature
testKeywordArgumentAndCommentSignature
testKeywordArgumentAndCommentSignature2
testKeywordVarArgsAndCommentSignature
testWrongNumberOfArguments
testNestedFunctionInMethodWithTooFewArgumentsInTypeComment
testDeepNestedFunctionWithTooFewArgumentsInTypeComment
testDeepNestedMethodInTypeComment
testEllipsisWithArbitraryArgsOnBareFunctionWithKwargs
testEllipsisWithArbitraryArgsOnBareFunctionWithVarargs
testEllipsisWithSomethingAfterItFails
testEllipsisWithSomethingBeforeItFails
testMethodDefaultArgumentsAndSignatureAsComment
testDefaultArgumentsAndSignatureAsComment
testLiteralInsideOtherTypesTypeCommentsPython3
testLiteralInvalidTypeComment
testLiteralInvalidTypeComment2
testInferOptionalFromDefaultNoneComment
testNoInferOptionalFromDefaultNoneComment
testCheckUntypedDefsSelf1
testOperatorDoubleUnionDivision
testFasterParseTooManyArgumentsAnnotation
testFasterParseTooFewArgumentsAnnotation
testFastParserShowsMultipleErrors
testFastParserConsistentFunctionTypes
testErrorCodeInvalidCommentSignature
testErrorCodeIgnoreAfterArgComment
testColumnsMethodDefaultArgumentsAndSignatureAsComment
testColumnTypeSignatureHasTooFewArguments
testInvalidSignatureInComment*
testDuplicateSignatures1
testDuplicateSignatures2
testTooManyTypes
testTooFewTypes
testCommentFunctionAnnotationVarArgMispatch-skip
testCommentFunctionAnnotationVarArgMispatch2-skip
testErrorCodeSyntaxError2
testFastParseFunctionAnnotationSyntaxError
testFastParseFunctionAnnotationSyntaxErrorSpaces
testFastParseInvalidFunctionAnnotation

# --scripts-are-modules
testScriptsAreModules

# --custom-typeshed-dir 
testIgnoreErrorsFromTypeshed

# cmd: mypy ...
testNonExistentFileOnCommandLine1
testNoCrashOnDeletedWithCacheOnCmdline
testFollowImportsNormalSearchPathUpdate-only_when_nocache
testFollowImportsNormalSearchPathUpdate2-only_when_cache
testAddNonPackageSubdir
testAddPackage5

# Won't do Invalid Mypy TypeVars according to conformance tests:
testDeterminismCommutativityWithJoinInvolvingProtocolBaseAndPromotableType

# Won't do: Type Vars qualified names -> comes from visit_Attribute and is not really qualified, but the expr name
testQualifiedTypeVariableName
testPartiallyQualifiedTypeVariableName
testSerializeSimpleTypeVar
testSerializeBoundedTypeVar
testSerializeTypeVarWithValues
testSerializeTypeVarInClassBody

# Won't support: __eq__ called directly with a keyword argument (which is actually legal)
testMagicMethodPositionalOnlyArg
testMagicMethodPositionalOnlyArgFastparse

# Won't support: reveal_locals
testRevealLocalsFunction
testRevealLocalsOnClassVars
testRevealLocals
testUnimportedRevealLocals

# Won't support: Warning about wrong usage of type var values
testObsoleteTypevarValuesSyntax

# Won't support ever: Union Pipe "|" not allowed in 3.9
testUnionOrSyntaxWithinRuntimeContextNotAllowed
testUnionOrSyntaxWithinRuntimeContextNotAllowed2
testUnionOrSyntaxMissingFutureImport
testTypeAliasNotSupportedWithNewStyleUnion

# Probably won't support `# flags2: ` in tests
testInlineIncremental2
# Won't support ever: Mypy test case details
testNewAnalyzerIncompleteFixture

# Won't support Python 3.9 specialities
testDataclassWithMatchArgsOldVersion
testTypeAliasWithOldUnionIsInstancePython39

# Won't support list/dict/tuple "is not subscriptable" (python <3.10)
testDataclassWithSlotsArgBefore310

# Won't support --disable-recursive-aliases
testNewAnalyzerAliasToNotReadyDirectBase
testNewAnalyzerNewTypeForwardClassAliasDirect
testNewAnalyzerForwardTypeAliasInBase
testRecursiveForwardReferenceInUnion
testRecursiveAliasesErrors1
testRecursiveAliasesErrors2
testJSONAliasApproximation
testCrashOnSelfRecursiveNamedTupleVar
testSimpleSelfReferentialNamedTuple
testSelfRefNT1
testSelfRefNT2
testSelfRefNT3
testSelfRefNT4
testSelfRefNT5
testRecursiveNamedTupleInBases
testSubclassOfRecursiveNamedTuple
testSelfRecursiveTypedDictInheriting
testSubclassOfRecursiveTypedDict
testCorrectJoinOfSelfRecursiveTypedDicts

# Won't support --force-union-syntax
testLiteralUnionErrorSyntax

# Are generics in self types always bound to the function?
# https://github.com/python/typing/discussions/1340
# https://github.com/python/mypy/issues/14729
testSelfTypeRestrictedMethodOverloadInit
# Callable override https://github.com/python/mypy/issues/16549
testClassSpecError
# Mypy test case issues
# https://github.com/python/mypy/issues/13102
testNewAnalyzerMoreInvalidTypeVarArgumentsDeferred
testNoConfigFile

# Not working in interpreter
# Recursive class inheritance
testNewAnalyzerAliasToNotReadyNestedClass

# "Recursive types are not allowed at function scope"
testNoRecursiveTuplesAtFunctionScope
testRecursiveBoundFunctionScopeNoCrash
testNewAnalyzerReportLoopInMRO2

# Won't do, because too many differences because of different stubs
testDivmod
# xfail
testTypeGuardMultipleCondition-xfail
# Skips
testSubtypingWithTypeImplementingGenericABCViaInheritance2-skip
testOverloadInferringArgumentsUsingContext2-skip
testUnionTwoPassInference-skip
testWeirdRecursiveInferenceForProtocols-skip
testPartiallyInitializedToNoneAndThenToIncompleteType-skip
