[case unreachable_var_definition]
import mod
mod.foo  # E: Module has no attribute "foo"
mod.bar  # E: Module has no attribute "bar"
[file mod.py]
import sys
if sys.platform == 'lol':
    foo = 3
    def bar() -> None: ...

foo  # E: Name "foo" is not defined
bar  # E: Name "bar" is not defined

[case unreachable_var_definition_with_assert]
# flags: --mypy-compatible
import mod
mod.foo  # E: Module has no attribute "foo"
mod.bar  # E: Module has no attribute "bar"
mod.undefined  # E: Module has no attribute "undefined"
[file mod.py]
import sys
assert sys.platform == 'lol'
foo = 3
def bar() -> None: ...

foo
bar
undefined

[case unreachable_var_definition_with_return]
# flags: --warn-unreachable
def func() -> None:
    if bool():
        return
        foo = 3  # E: Statement is unreachable
        def bar() -> None: ...

    foo  # E: Name "foo" is not defined
    bar  # E: Name "bar" is not defined
    undefined  # E: Name "undefined" is not defined

[case unreachable_var_definition_with_raise]
# flags: --warn-unreachable
def func() -> None:
    if bool():
        raise; foo = 3  # E: Statement is unreachable
        def bar() -> None: ...

    foo  # E: Name "foo" is not defined
    bar  # E: Name "bar" is not defined
    undefined  # E: Name "undefined" is not defined

[case unreachable_var_after_assert_false]
# flags: --warn-unreachable
from typing import Literal, TYPE_CHECKING
x: Literal[False]
def func1() -> None:
    assert False; undefined1  # E: Statement is unreachable
    undefined2
def func2() -> None:
    assert x; undefined1  # E: Statement is unreachable
    undefined2
def func3() -> None:
    assert not TYPE_CHECKING; undefined1  # E: Statement is unreachable
    undefined2

[case conjunction_partial_inference_combination_issue]
# This was an issue, because flow analysis for conjunction can lead to
# multiple times trying to infer partials (which are not even used here).
import os
def foo() -> None:
    x = 1 and os.path.islink("").conjugate(1)  # E: Too many arguments for "conjugate" of "int"

[case avoid_type_computation_recursion]

[file foo.py]
from typing import Generic
from bar import X
class Foo(Generic[X]): ...
[file bar.py]
from typing import TypeVar
import foo

if bool():  # Causes flow analysis to happen
    X = TypeVar("X")

def here() -> None:
    reveal_type(foo.Foo())  # N: Revealed type is "foo.Foo[Any]"

[case flow_analysis_should_be_avoided_for_simple_imports]
import foo
for x in [1]:
    foo.bar  # This used to cause "Cannot use Final inside a loop" in foo.py

[file foo.py]
from typing import Final
bar: Final = 1

[case flow_analysis_circular_dependency]
# flags: --warn-unreachable
import foo
[file foo.py]
from bar import X
if bool(): # Causes flow analysis
    def foo() -> X: ...

class Y: ...
[file bar.py]
from foo import Y
if bool(): # Causes flow analysis
    def bar() -> Y: ...

class X: ...

[case flow_analysis_global_context_should_not_be_loop_context]
# flags: --mypy-compatible
import foo

def f(x: foo.X) -> None:
    x.abc

[file foo.py]
from typing import Final

bar: Final = 1

class X:
    def __init__(self) -> None:
        for x in (1,):
            self.abc = bar

[case flow_analysis_circular_import_but_simple_assign_is_fine]
# flags: --warn-unreachable
import foo
[file foo.py]
from bar import x1, x2, x3  # E: Cannot determine type of "x1"
if bool(): # Causes flow analysis
    ...

y1 = str()
y2 = 1
y3: int = 1
[file bar.py]
from foo import y1, y2, y3
if bool(): # Causes flow analysis
    ...

x1 = str()
x2 = 1
x3: int = 1

[case flow_analysis_circular_import_but_import_is_fine]
# flags: --warn-unreachable
import foo
[file foo.py]
from bar import x1, x2
if bool(): # Causes flow analysis
    ...

import other as y1
from other import something as y2

[file bar.py]
from foo import y1, y2
if bool(): # Causes flow analysis
    ...

class X: ...

import other as x1
from other import something as x2

[file other.py]
something = 1

[case flow_analysis_avoid_final_loop_issue_in_simple_case]
# flags: --warn-unreachable
import foo

[file foo.py]
from typing import Final
from bar import X

for _ in [1]:
    X.member

y = str()

[file bar.py]
from typing import Final
from foo import y

x = str()
class X:
    member: Final = 1

[case flow_analysis_member_loops]
from foo import C
C().definition

[file foo.py]
class P:
    def __init__(self) -> None:
        self.x: int = 1

    def foo(self, other: C) -> None:
        other.y

class C:
    def __init__(self) -> None:
        P().x
        self.y = int()
        self.definition = 1

[case flow_analysis_base_class_calculation_should_not_lead_to_recursion]
from x import X
class C(X): ...

[file x.py]
from y import Z
class X(Z): ...

[file y.py]
from z import Z
from z import Z
from x import X
class Y(X): ...

[file z.py]
class Z: ...

[case star_import_overwrite_regression1]
from f import C

[file f.py]
from h import C
from g import *

[file g.py]
from h import C
[file h.py]
class C: ...

[case star_import_overwrite_regression2]
from f import C

[file f.py]
from g import *
from h import C

[file g.py]
from h import C
[file h.py]
class C: ...

[case star_import_overwrite_regression3]
from f import C

[file f.py]
from h import C
from g import *

[file g.py]
class C: ...
[file h.py]
class C: ...

[case avoid_crash_on_aug_assign_access1]
class C:
    x: int
class D(C):
    def f(self) -> None:
        self.x *= 3

reveal_type(D().x)  # N: Revealed type is "int"

[case avoid_crash_on_aug_assign_access2_mypy_compatible]
# flags: --mypy-compatible
class C:
    x: int
class D(C):
    def f(self) -> None:
        self.x *= ""  # E: Incompatible types in assignment (expression has type "str", variable has type "int")

reveal_type(D().x)  # N: Revealed type is "int"

[case avoid_crash_on_aug_assign_access2_no_mypy_compatible]
# flags: --no-mypy-compatible
class C:
    x: int
class D(C):
    def f(self) -> None:
        self.x *= ""  # E: Incompatible types in assignment (expression has type "LiteralString", variable has type "int")

reveal_type(D().x)  # N: Revealed type is "int"

[case avoid_walrus_crash_when_variable_is_used_in_closure]
a = 1

def f() -> None:
    def g() -> None:
        y

    if y := a: ...

[case alias_complicated_definition_because_of_flow_analysis]
from m import ScalarResult
def Trade() -> ScalarResult: ...

[file m.py]
from typing import Iterator, Union
from n import Row
if bool(): ... # Enable flow analysis

KeyType = str
RowData = Union[str, Row]
R = undefined(RowData)  # E: Name "undefined" is not defined

class Result:
    def f(self) -> Iterator[RowData]: ...
class IteratorResult(Result):
    def f(self) -> Iterator[RowData]: ...
class ScalarResult(list[R]): ...  # E: Variable "m.R" is not valid as a type \
                                  # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#variables-vs-type-aliases

[file n.py]
from m import KeyType
class Row(list["KeyType"]): ...

[case star_import_should_not_crash]
from o import foo
reveal_type(foo())  # N: Revealed type is "Any"

[file m.py]
def foo() -> int: ...
[file n.py]
foo = undefined()  # E: Name "undefined" is not defined
[file o.py]
from m import *
from n import foo

[case flow_analysis_with_final_statement_as_type_should_not_crash]
from m import D

class C:
    def x(self, d: D) -> None:
        reveal_type(d.x)  # N: Revealed type is "Any"

[file m.py]
from typing import Final

ccc: Final = 1

class D:
    x: ccc  # E: Variable "m.ccc" is not valid as a type \
            # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#variables-vs-type-aliases

[case flow_analysis_with_class_var_as_type_should_not_crash]
from m import D

class C:
    def x(self, d: D) -> None:
        reveal_type(d.x)  # N: Revealed type is "Any"

[file m.py]
from typing import ClassVar

class D:
    c: ClassVar = 1
    x: c  # E: Variable "m.c" is not valid as a type \
          # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#variables-vs-type-aliases

[case flow_analysis_not_needed_for_annotated_vars]
import n
n.C

[file n.py]
from m import C
C("").x  # E: Cannot determine type of "x"
reveal_type(C("").y)  # N: Revealed type is "int"

if bool():
    z = C("").z

[file m.py]
import n
class C:
    def __init__(self, x: str):
        # Ensure flow analysis is triggered
        def f() -> int | None: ...
        optional = f()
        if optional:
            n.z
            self.x = x
            self.y: int = int()
            self.z: int = optional
            self.a: int = n.z

[case self_variable_complex_case_should_not_crash]
from m import C

def f(x: C[int]):
    x._coro

[file m.py]
from typing import TypeVar, Generic

_RetType = TypeVar("_RetType")

class C(Generic[_RetType]):
    def __init__(self, coro: _RetType) -> None:
        self._coro: _RetType = coro

[case no_crash_on_forward_reference_and_weird_imports]
def f() -> None:
    from m import APP

[file m/__init__.py]
from .inner import *

[file m/inner.py]
APP = bool()

[case avoid_crash_when_using_issubclass_in_decorator_comprehension]
from typing import Any

C: set[type[Any]] = {
    list,
    set,
}

@foo(c if issubclass(c, dict) else c for c in C)  # E: Name "foo" is not defined
def f(): ...

[case avoid_crash_when_using_issubclass_and_walrus_in_decorator]
@foo(2 if issubclass(c:=1, dict) else 1)  # E: Name "foo" is not defined
def f(): ...

[case avoid_crash_on_never_return_in_decorator]
from typing import Callable, Never

def dec() -> Callable[[Callable], Never]: ...

@dec()
def foo(): ...

[case global_final_unfinished_using_flow_analysis]
import m
reveal_type(m.x)  # N: Revealed type is "Literal[2] | Literal[3]"

[file m.py]
from typing import Final, Literal

y: Literal[1, 2, 3] = 1
if y == 1:
    y = 2
else:
    y = 3

x: Final = y

[case class_final_unfinished_using_flow_analysis]
import m
reveal_type(m.C.x)  # N: Revealed type is "Literal[2] | Literal[3]"

[file m.py]
from typing import Final, Literal

class C:
    y: Literal[1, 2, 3] = 1
    if y == 1:
        y = 2
    else:
        y = 3

    x: Final = y

[case func_final_unfinished_using_flow_analysis]
from typing import Final, Literal

def f() -> None:
    reveal_type(x)  # E: Name "x" is used before definition \
                    # N: Revealed type is "Literal[1] | Literal[2] | Literal[3]"
    y: Literal[1, 2, 3] = 1
    if y == 1:
        y = 2
    else:
        y = 3
    x: Final = y
    reveal_type(x)  # N: Revealed type is "Literal[1] | Literal[2] | Literal[3]"

def g() -> None:
    y: Literal[1, 2, 3] = 1
    if y == 1:
        y = 2
    else:
        y = 3
    x: Final = y
    reveal_type(x)  # N: Revealed type is "Literal[2] | Literal[3]"

[case classvar_unfinished_using_flow_analysis]
import m
reveal_type(m.C.x)  # N: Revealed type is "Literal[2] | Literal[3]"

[file m.py]
from typing import ClassVar, Literal

class C:
    y: Literal[1, 2, 3] = 1
    if y == 1:
        y = 2
    else:
        y = 3

    x: ClassVar = y

[case protocol_matching_class_should_not_crash]
from typing import Protocol
import m

class P(Protocol):
    x: int

Transformer: type["P"]
Transformer = m.C

[file m.py]
class C:
    x: int

[case fix_unreachable_false_positive]
# flags: --no-mypy-compatible

def fetch_url(url: str) -> dict[str, int]: ...

def test_func():
    offset = None
    for _ in range(10):
        url = "http://example/com/"

        if offset: # <- This part
            url += f"?offset={offset}"

        data = fetch_url(url)
        if data["next"]:
            offset = data["next"]
        else:
            break

[case file_flow_analysis]
from h import H

def blubb(self, h: H):
    h.asdf

[file h.py]
x = undefined  # E: Name "undefined" is not defined

class H:
    asdf = x
