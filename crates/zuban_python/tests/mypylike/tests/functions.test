[case function_subtyping_of_keyword_params]
# flags: --mode mypy
def f(*, x: int, y: str) -> None: pass
def g(x: int, y: str) -> None: pass
def h(x: int, y: str = "") -> None: pass
def i(x: int, y: int = 3) -> None: pass
def j(y: str, x: int = 3) -> None: pass
f = g
f = h
f = i # E: Incompatible types in assignment (expression has type "Callable[[int, int], None]", variable has type "Callable[[NamedArg(int, 'x'), NamedArg(str, 'y')], None]")
f = j

[case subtyping_of_kwargs_with_defaults]
from typing import Any

class A:
    def a(self, **kwargs: int) -> Any: ...
class B(A):
    def a(self, *, x: str = "", **kwargs: int) -> Any: ...  # E: Signature of "a" incompatible with supertype "A" \
                                                     # N:      Superclass: \
                                                     # N:          def a(self, **kwargs: int) -> Any \
                                                     # N:      Subclass: \
                                                     # N:          def a(self, *, x: str = ..., **kwargs: int) -> Any
class C(A):
    def a(self, *, x: int = 1, **kwargs: int) -> Any: ...

[case infer_unannotated_star_args]
def foo(*args, **kwargs) -> None:
    reveal_type(args)  # N: Revealed type is "tuple[Any, ...]"
    reveal_type(kwargs)  # N: Revealed type is "dict[str, Any]"

[case staticmethod_unannotated_types]
class Foo:
    @staticmethod
    def foo(x, y) -> None:
        reveal_type(x)  # N: Revealed type is "Any"
        reveal_type(y)  # N: Revealed type is "Any"

[case global_with_late_type_defs]
# flags: --no-check-untyped-defs
# Like testGlobalWithoutInitialization, but without type comments
from typing import List

def foo1() -> None:
    global bar1  # E: Name "bar1" is not defined
    bar1: List[str] = []  # E: Name "bar1" already defined on line 6
    reveal_type(bar1)  # N: Revealed type is "Any"

def foo2():
    global bar2
    bar2: List[str] = []  # N: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs

[case assigning_in_unannotated_funcs_should_not_generate_errors]
# flags: --no-check-untyped-defs
def foo():
    [1][1()] = 1
    [1][1()].x = 1
    str(1()).x = 1
    (1().x, b) = 1, 1
    (1().x, c) = 1, 1  # type: (int, int)  # N: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs

[case union_iter_star_unpacking]
from typing import TypeVar
S = TypeVar("S")
T = TypeVar("T")
U = TypeVar("U")
def bar(x: T, y: U) -> tuple[T, U]: ...
def baz(x: T, y: U, z: S) -> tuple[T, U, S]: ...

def foo(x: tuple[int, str] | list[bytes]) -> None:
    reveal_type(bar(*x))  # N: Revealed type is "tuple[int | bytes, str | bytes]"
    reveal_type(baz(*x))  # E: Missing positional argument "z" in call to "baz" \
                          # N: Revealed type is "tuple[int | bytes, str | bytes, Any]"

[case avoid_wrong_inference_for_overload_when_generic]
from typing import Callable, TypeVar, overload
T = TypeVar("T")

@overload
def over(x: None) -> None: ...
@overload
def over(x: int) -> int: ...
def over(x: object) -> int | None: ...

def foo(x: Callable[[T], T], y: T): ...
def bar(x: Callable[[T], T], y: list[T]): ...

foo(over, 1)
foo(over, None)

bar(over, [1])
bar(over, [None])

[case type_var_constraint_with_any_input]
from typing import TypeVar, Any
T = TypeVar("T", int, str)

def f(x: T) -> T: ...

def foo(x: int | Any) -> None:
    reveal_type(f(x))  # N: Revealed type is "int"

[case arg_after_kwargs_normal]
def foo1(x: int, y: int) -> None: ...
def foo2(x: str, y: int) -> None: ...

def bar(**kwargs: int) -> None:
    foo1(**kwargs, x=1)
    foo2(**kwargs, x="")
    foo2(**kwargs)  # E: Argument 1 to "foo2" has incompatible type "**dict[str, int]"; expected "str"

    foo1(**kwargs, y=1)

def baz(**kwargs: str) -> None:
    foo2(**kwargs, y=1)
    foo2(**kwargs, y="")  # E: Argument "y" to "foo2" has incompatible type "str"; expected "int"

[case arg_after_kwargs_keyword_only]
def foo1(*, x: int, y: int) -> None: ...
def foo2(*, x: str, y: int) -> None: ...

def bar(**kwargs: int) -> None:
    foo1(**kwargs, x=1)
    foo2(**kwargs, x="")
    foo2(**kwargs)  # E: Argument 1 to "foo2" has incompatible type "**dict[str, int]"; expected "str"

    foo1(**kwargs, y=1)

def baz(**kwargs: str) -> None:
    foo2(**kwargs, y=1)
    foo2(**kwargs, y="")  # E: Argument "y" to "foo2" has incompatible type "str"; expected "int"

[case simple_type_var_getitem_and_execute]
from typing import TypeVar
T = TypeVar("T")
# It's debatable that this is allowed. specialtypes_type.py in conformance
# tests allows this so we should as well.
def foo(x: T, y: type[T]) -> None:
    x[1]  # E: Value of type "T" is not indexable
    x()  # E: "T" not callable

    y[1]  # E: Type application is only supported for generic classes
    y()

[case param_spec_kwargs_getitem]
from typing import ParamSpec, Callable
P = ParamSpec("P")
def foo(x: Callable[P, int], *args: P.args, **kwargs: P.kwargs) -> None:
    args["x"]  # E: No overload variant of "__getitem__" of "tuple" matches argument type "str" \
               # N: Possible overload variants: \
               # N:     def __getitem__(self, SupportsIndex, /) -> object \
               # N:     def __getitem__(self, slice[Any, Any, Any], /) -> tuple[object, ...]
    args[1]
    kwargs["x"]
    kwargs[1]  # E: Invalid index type "int" for "dict[str, object]"; expected type "str"

[case with_unpack_arg_vs_arbitary_len_param]
def foo(*args: int): ...

def f(x: tuple[int, *tuple[int, ...]],
      y: tuple[int, *tuple[str, ...]],
      z: tuple[str, *tuple[int, ...]]):
    foo(*x)
    foo(*y)  # E: Argument 1 to "foo" has incompatible type "*tuple[Unpack[Tuple[str, ...]]]"; expected "int"
    foo(*z)  # E: Argument 1 to "foo" has incompatible type "*tuple[str, Unpack[Tuple[int, ...]]]"; expected "int"

[case param_spec_matching_with_unpack]
from typing import ParamSpec, Generic, Callable
P = ParamSpec('P')

def foo(*args: P.args, **kwargs: P.kwargs) -> Callable[P, None]: ...

def f(with_unpack: tuple[str, *tuple[str, ...]],  # E: ParamSpec "P" is unbound
      arbitrary_len: tuple[int, ...],
      dct: dict[str, int],
      *args: P.args,
      **kwargs: P.kwargs):
    reveal_type(foo(*with_unpack))  # N: Revealed type is "def (str, *Unpack[Tuple[str, ...]])"
    reveal_type(foo(*with_unpack, 1))  # N: Revealed type is "def (str, *Unpack[tuple[Unpack[Tuple[str, ...]], Literal[1]?]])"
    reveal_type(foo(*with_unpack, *with_unpack))  # N: Revealed type is "def (*Any, **Any)"
    reveal_type(foo(*with_unpack, *arbitrary_len))  # N: Revealed type is "def (*Any, **Any)"
    reveal_type(foo(*with_unpack, *args, **kwargs))  # N: Revealed type is "def (*Any, **Any)"
    reveal_type(foo(1, *args, **kwargs))  # N: Revealed type is "def (Literal[1]?, *P.args, **P.kwargs)"
    reveal_type(foo(*with_unpack, **dct))  # N: Revealed type is "def (str, *Unpack[Tuple[str, ...]], **int)"

[case type_var_tuple_context_from_func]
from typing import TypeVarTuple, Generic
Ts = TypeVarTuple('Ts')

class A(Generic[*Ts]):
    def f(self, *a: *Ts) -> None: pass

a: A[int, str]

a.f(1) # E: Argument 1 to "f" of "A" has incompatible type "tuple[int]"; expected "tuple[int, str]"
a.f(2, '')

x: A[list[int]]
x.f([""]) # E: List item 0 has incompatible type "str"; expected "int"
x.f([])

y: A[*tuple[list[int], ...]]
y.f([], [""]) # E: List item 0 has incompatible type "str"; expected "int"
y.f([], [])

z: A[int, *tuple[list[int], ...], str]
z.f(1, [""])  # E: Argument 1 to "f" of "A" has incompatible type "tuple[int, list[str]]"; expected "tuple[int, Unpack[Tuple[list[int], ...]], str]"
z.f(1, [1], "")

[case param_spec_context_from_func]
from typing import ParamSpec, Generic, Callable, Any
P = ParamSpec('P')

class A(Generic[P]):
    def f(self, x: Callable[P, Any]) -> None: pass
    def g(self, *args: P.args, **kwargs: P.kwargs) -> None: pass

a: A[int, str]

def f(x: int) -> None: ...
def g(x: int, y: str) -> None: ...
a.f(f) # E: Argument 1 to "f" of "A" has incompatible type "Callable[[int], None]"; expected "Callable[[int, str], Any]" 
a.f(g)

a.g(1)  # E: Too few arguments for "g" of "A"
a.g(1, "")

x: A[list[int]]
x.f(lambda y: reveal_type(y))  # N: Revealed type is "list[int]"

x.g([])
x.g([1])
x.g([2])

[case func_arbitrary_len_args_vs_unpack]
def f(*args: int) -> None: ...

def b1(*args: *tuple[*tuple[int, ...], int]) -> None: ...
def b2(*args: *tuple[*tuple[str, ...], int]) -> None: ...
def b3(*args: *tuple[*tuple[int, ...], str]) -> None: ...

f = b1
f = b2  # E: Incompatible types in assignment (expression has type "Callable[[VarArg(Unpack[tuple[Unpack[Tuple[str, ...]], int]])], None]", variable has type "Callable[[VarArg(int)], None]")
f = b3  # E: Incompatible types in assignment (expression has type "Callable[[VarArg(Unpack[tuple[Unpack[Tuple[int, ...]], str]])], None]", variable has type "Callable[[VarArg(int)], None]")

[case func_unpack_with_type_var_tuple_vs_arbitrary_len]
from typing import TypeVarTuple, Callable
Ts = TypeVarTuple('Ts')
def a1(*args: *tuple[*Ts, int]) -> None: ...
def a2(*args: *tuple[*Ts, str]) -> None: ...

def b(*args: int) -> None: ...

if bool():
    b = a1
    b = a2  # E: Incompatible types in assignment (expression has type "Callable[[VarArg(Unpack[tuple[Unpack[Ts], str]])], None]", variable has type "Callable[[VarArg(int)], None]")
a1 = b  # E: Incompatible types in assignment (expression has type "Callable[[VarArg(int)], None]", variable has type "Callable[[VarArg(Unpack[Tuple[Unpack[Ts], int]])], None]")

def foo1(x: Callable[[*tuple[*Ts, int]], None]) -> tuple[*Ts]: ...
def foo2(x: Callable[[*tuple[*Ts, str]], None]) -> tuple[*Ts]: ...
reveal_type(foo1(b))  # N: Revealed type is "tuple[int, ...]"
reveal_type(foo2(b))  # E: Argument 1 to "foo2" has incompatible type "Callable[[VarArg(int)], None]"; expected "Callable[[VarArg(Unpack[Tuple[Unpack[Tuple[int, ...]], str]])], None]" \
                      # N: Revealed type is "tuple[int, ...]"

[case any_call_with_invalid_args_kwargs_mypy_compatible]
# flags: --mode mypy
from typing import Any

def f(x: Any) -> None:
    x(*1)
    x(**1)
    x(*1, **1)
    x(*undefined)  # E: Name "undefined" is not defined
    x(**undefined)  # E: Name "undefined" is not defined

[case any_call_with_invalid_args_kwargs_no_mypy_compatible]
# flags: --mode default
from typing import Any

def f(x: Any) -> None:
    x(*1)  # E: Expected iterable as variadic argument
    x(**1) # E: Argument after ** must be a mapping, not "int"
    x(*1, **1)  # E: Expected iterable as variadic argument \
                # E: Argument after ** must be a mapping, not "int"
    x(*undefined)  # E: Name "undefined" is not defined
    x(**undefined)  # E: Name "undefined" is not defined

[case callable_return_same_type_should_not_recurse]
from typing import Callable, Any
import sys
R = Callable[[], 'R']

def f() -> Any: ...
def g(y: R): ...
g(f)

[case func_generator_return_annotation_should_not_crash]
from typing import Generator
def f() -> Generator[dict[str, str]]:
    yield {'': ''}

[case conditional_function_definition_with_decorator]
from typing import Any
def dec(fun) -> Any: ...

if bool():
    def f() -> int: ...
else:
    @dec
    def f() -> None: ...

[case conditional_function_is_the_same]
from typing import Sequence, Any
if bool():
    def f(errors: Sequence[Any]): ...
else:
    def f(errors: Sequence[Any]): ...

[case invalid_keyword_arguments_position_mypy_compatible]
# flags: --mode mypy
def foo(x: int, y: int): ...

foo( # type: ignore[call-arg]
    x="",  # E: Argument "x" to "foo" has incompatible type "str"; expected "int"
    z=1,
)
foo(  # E: Unexpected keyword argument "z" for "foo"
    x="",  # E: Argument "x" to "foo" has incompatible type "str"; expected "int"
    z=1,
)

[case invalid_keyword_arguments_position_no_mypy_compatible]
# flags: --mode default
def foo(x: int, y: int): ...

foo( # type: ignore[call-arg]
    x="",  # E: Argument "x" to "foo" has incompatible type "str"; expected "int"
    z=1,  # E: Unexpected keyword argument "z" for "foo"
)
foo(
    x="",  # E: Argument "x" to "foo" has incompatible type "str"; expected "int"
    z=1,  # E: Unexpected keyword argument "z" for "foo"
)

[case avoid_lambda_crash_when_variable_is_used_in_lambda_again]
from typing import Final, ClassVar
from collections import defaultdict

w: Final = defaultdict(lambda: len(w))
x: dict[str, int] = defaultdict(lambda: len(x))
y = defaultdict(lambda: len(y))
z: list[z] = [] # E: Name "z" is not defined \
                # E: Variable "__main__.z" is not valid as a type \
                # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#variables-vs-type-aliases

class C:
    a: Final = defaultdict(lambda: len(a)) # E: Name "a" is not defined
    b: ClassVar = defaultdict(lambda: len(b)) # E: Name "b" is not defined
    c: dict[str, int] = defaultdict(lambda: len(x))

[case assert_type_allows_none]
from typing import assert_type
def takes_None(x: None) -> None:
    ...

assert_type(takes_None(None), None)

[case generator_invalid_send_type]
from typing import Generator
def generator21() -> Generator[None, int, None]:
    x: float = yield


def generator22() -> Generator[None, str, None]:
    yield from generator21()  # E: Incompatible send types in yield from (actual type "int", expected type "str")

# contravariant matching, so object is not fine
def generator23() -> Generator[None, object, None]:
    yield from generator21()  # E: Incompatible send types in yield from (actual type "int", expected type "object")

class IntSub(int): ...

def generator24() -> Generator[None, IntSub, None]:
    yield from generator21()

[case callable_type_subtyping]
from typing import Callable, Any
# From conformance tests specialtypes_type.py
def func13(v: type):
    x1: Callable[..., Any] = v  # OK
    x2: Callable[[int, int], int] = v  # OK
    x3: object = v  # OK
    x4: type = v  # OK
    x5: type[int] = v  # OK
    x6: type[Any] = v  # OK

[case decorator_that_returns_none_is_ok]
from typing import Concatenate, Callable, ParamSpec
P = ParamSpec("P")
# From conformance tests (generics_paramspec_semantics.py)
def expects_int_first(x: Callable[Concatenate[int, P], int]) -> None:
    ...

@expects_int_first  # E: Argument 1 to "expects_int_first" has incompatible type "Callable[[str], int]"; expected "Callable[[int], int]"
def one(x: str) -> int: ...
@expects_int_first  # OK
def four(*args: int) -> int: ...

[case function_no_return_should_not_result_in_any_no_mypy_compatible]
# flags: --mode default
# From GH #150, see also the discussion there, Mypy returns Any, Pyright None
from typing import assert_type, Callable, Generator, Iterator

def foo() -> None: ...

def bar(c: Callable[[], None]):
    val = c()  # E: Function does not return a value (it only ever returns None)
    assert_type(val, None)

async def asyn(depth: int) -> None:
    if depth > 0:
        val = await asyn(depth - 1)  # E: Function does not return a value (it only ever returns None)
        assert_type(val, None)

def generator():
    def gen() -> Iterator[int]:
        yield 1
        return None

    val = yield from gen()  # E: Function does not return a value (it only ever returns None)
    assert_type(val, None)


val = foo()  # E: "foo" does not return a value (it only ever returns None)
assert_type(val, None)

[case function_does_not_return_value_mypy_compatible]
# flags: --mode mypy
from collections.abc import Callable

def get(fn: Callable[[], None] | Callable[[], str]) -> None:
    ret = fn()
    reveal_type(ret)  # N: Revealed type is "None | str"

def get2(fn: Callable[[float], None] | Callable[[int], None]) -> None:
    ret = fn(1)  # E: Function does not return a value (it only ever returns None) \
                 # E: Function does not return a value (it only ever returns None)
    reveal_type(ret)  # N: Revealed type is "Any"

[case function_does_not_return_value_no_mypy_compatible]
# flags: --mode default
# From GH #124
from collections.abc import Callable

def get(fn: Callable[[], None] | Callable[[], str]) -> None:
    ret = fn()
    reveal_type(ret)  # N: Revealed type is "None | str"

def get2(fn: Callable[[float], None] | Callable[[int], None]) -> None:
    ret = fn(1)  # E: Function does not return a value (it only ever returns None) \
                 # E: Function does not return a value (it only ever returns None)
    reveal_type(ret)  # N: Revealed type is "None"

[case annotations_generator_unreachable_yield]
# flags: --mode default
# From conformance tests (annotations_generators.py)
from typing import AsyncIterable, AsyncIterator, Iterable
def generator23() -> Iterable[str]:  # OK
    return
    yield ""  # Unreachable, but fine, because it's an empty generator


async def generator24() -> AsyncIterable[str]:  # OK
    return
    yield ""  # Unreachable, but fine, because it's an empty generator

async def generator30() -> AsyncIterator[int]:
    raise NotImplementedError
    yield

[case historical_positional_conformance_tests]
# From conformance tests (historical_positional.py)

def f2(x: int, __y: int) -> None: ...  # E: A positional only param starting with two underscores is not allowed after a positional or keyword param
def f3(x: int, *args: int, __y: int) -> None: ...  # OK

f3(3, __y=3)  # OK

class A:
    def m1(self, __x: int, __y__: int = 0) -> None: ...
    def m2(self, x: int, __y: int) -> None: ...  # E: A positional only param starting with two underscores is not allowed after a positional or keyword param

a = A()
a.m1(3, __y__=1)  # OK
a.m1(__x=3)  # E: Unexpected keyword argument "__x" for "m1" of "A"

# The historical mechanism should not apply when new-st
# syntax is used.

def f4(x: int, /, __y: int) -> None: ...  # OK

f4(3, __y=4)  # OK
