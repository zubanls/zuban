[case final_in_generic_class_attr]
from typing import Final, Generic, TypeVar
T = TypeVar("T")

class Foo(Generic[T]):
    x: Final = 1

Foo.x = 3  # E: Cannot assign to final attribute "x"

[case final_reassignment_inferred]
from typing import Final

fin: Final = 1
other = fin
if bool():
    fin = 2   # E: Cannot assign to final name "fin"
    other = 2

class Foo:
    x = fin
    y = fin
    def __init__(self) -> None:
        self.y = 2
        self.z = fin

        self.member1: Final = 1
        self.member2 = self.member1

foo = Foo()
foo.x = 3
foo.y = 3
foo.z = 3
foo.member1 = 2  # E: Cannot assign to final attribute "member1"
foo.member2 = 2

[case final_reassignment_defined]
# Should not cause final assignment issues if it is reassigned
from typing import Final

fin: Final[int] = 1
other = fin
if bool():
    fin = 2   # E: Cannot assign to final name "fin"
    other = 2

class Foo:
    x = fin
    y = fin
    def __init__(self) -> None:
        self.y = 2
        self.z = fin

        self.member1: Final = 1
        self.member2 = self.member1

foo = Foo()
foo.x = 3
foo.y = 3
foo.z = 3
foo.member1 = 2  # E: Cannot assign to final attribute "member1"
foo.member2 = 2

[case final_reassignment_indirect_final]
from typing import Final

class Foo:
    x: Final = 1
    y: Final[int] = 1
    z: Final[int]  # E: Final name must be initialized with a value

class Bar(Foo):
    x = 2  # E: Cannot assign to final name "x"
    y = 2  # E: Cannot assign to final name "y"
    in_bar1 = x
    in_bar2 = y
    def __init__(self):
        self.z = 2
        self.in_bar3 = self.z

bar = Bar()
bar.in_bar1 = 3
bar.in_bar2 = 3
bar.in_bar3 = 3

[case final_class_init_conditional_initialization]
# Partially Copied from conformance tests (qualifiers_final_annotation.py)
from typing import Final
class ClassA:
    ID6: Final[int]
    other1: Final[int]
    other2: Final[int]
    wrong: Final[int]

    def __init__(self, cond: bool) -> None:
        if cond:
            self.ID6 = 1
            self.other1 = 1
            self.other2 = ""
            self.wrong = 1
            self.wrong = 1  # E: Cannot assign to final attribute "wrong"
        else:
            self.ID6 = 2
            self.other1 = ""  # E: Incompatible types in assignment (expression has type "str", variable has type "int")
            self.other2 = 1

[case final_class_init_nested_conditional_initialization]
from typing import Final
class ClassA:
    x: Final[int]
    y: Final[int]
    z: Final[int]
    wrong: Final[int]

    def __init__(self) -> None:
        if bool():
            self.x = 1
            if bool():
                self.y = 1
            else:
                self.y = 2
                self.wrong = 1
                if bool():
                    self.z = 1
            self.wrong = 2  # E: Cannot assign to final attribute "wrong"
        elif bool():
            self.x = 2
            self.y = 3
        else:
            self.z = 1
            self.x = 3
