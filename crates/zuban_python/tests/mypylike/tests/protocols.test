[case protocol_class_access_with_self_type_check_without_ignoring_params_names]
-- From testProtocolTypeTypeSelfTypeInstanceMethod
from typing import Protocol, Type, TypeVar, Union

T = TypeVar("T")
class P(Protocol):
    def foo(ob, self: T) -> T: ...

class B:
    def foo(self: T) -> T: ...
class C:
    def foo(self: T) -> Union[T, int]: ...

def test(arg: P) -> None: ...
b: Type[B]
c: Type[C]
test(b)  # OK
test(c)  # E: Argument 1 to "test" has incompatible type "type[C]"; expected "P" \
         # N: Following member(s) of "C" have conflicts: \
         # N:     Expected: \
         # N:         def [T] foo(self: T) -> T \
         # N:     Got: \
         # N:         def [T] foo(self: T) -> Union[T, int]

[case protocol_with_ellipsis_default]
from typing import Protocol
class Foo(Protocol):
    def foo(self, x: int = ...) -> None: ...

[case protocol_class_object_callable_possible]
-- testProtocolClassObjectCallableError a bit modified
from typing import Protocol, Any, Callable

class P(Protocol):
    def __call__(self, app: int) -> Callable[[str], None]:
        ...

class Q(Protocol):
    def __call__(self, app: str) -> Callable[[str], None]:
        ...

class R(Protocol):
    def __call__(self, app: str) -> Callable[[int], None]:
        ...

class C:
    def __init__(self, app: str) -> None:
        pass

    def __call__(self, el: str) -> None:
        return None

p: P = C  # E: Incompatible types in assignment (expression has type "type[C]", variable has type "P") \
          # N: Following member(s) of "C" have conflicts: \
          # N: "C" has constructor incompatible with "__call__" of "P" \
          # N:     Expected: \
          # N:         def __call__(app: int) -> Callable[[str], None] \
          # N:     Got: \
          # N:         def __init__(app: str) -> C
q: Q = C
r: R = C  # E: Incompatible types in assignment (expression has type "type[C]", variable has type "R") \
          # N: Following member(s) of "C" have conflicts: \
          # N: "C" has constructor incompatible with "__call__" of "R" \
          # N:     Expected: \
          # N:         def __call__(app: str) -> Callable[[int], None] \
          # N:     Got: \
          # N:         def __init__(app: str) -> C

[case supports_keys_and_getitem_propagation]
from typing import TypeVar, Tuple
from _typeshed import SupportsKeysAndGetItem

S = TypeVar('S')
T = TypeVar('T')
def foo(x: SupportsKeysAndGetItem[S, T]) -> Tuple[S, T]: ...

x: Tuple[int, str] = foo(reveal_type({}))  # N: Revealed type is "dict[int, str]"

[case iterable_propagation]
from typing import TypeVar, Tuple, Iterable

T = TypeVar('T')

def foo(x: Iterable[T]) -> T: ...
def bar(x: Iterable[T]) -> Tuple[T]: ...

x: int = foo(reveal_type([]))  # N: Revealed type is "list[int]"
y: Tuple[int] = bar(reveal_type([]))  # N: Revealed type is "list[int]"

[case join_protocol_both_sides]
# Like testJoinProtocolWithProtocol, but with additional tests
from typing import Protocol

class P(Protocol):
    attr: int
class P2(Protocol):
    attr: int
    attr2: str

x: P
y: P2

l0 = [x, x]
l1 = [y, y]
l = [x, y]
k = [y, x]
reveal_type(l0) # N: Revealed type is "list[__main__.P]"
reveal_type(l1) # N: Revealed type is "list[__main__.P2]"
reveal_type(l) # N: Revealed type is "list[__main__.P]"
reveal_type(k) # N: Revealed type is "list[__main__.P]"

[case protocol_recursive]
from typing import Protocol
class Foo(Protocol):
    def foo(self) -> Foo: ...

class GoodImpl1:
    def foo(self) -> GoodImpl1: return self
class GoodImpl2:
    def foo(self) -> GoodImpl1: raise NotImplementedError
class BadImpl1:
    def foo(self) -> str: return ''
class BadImpl2:
    def foo(self) -> BadImpl1: raise NotImplementedError

def check(x: Foo) -> None: ...
check(GoodImpl1())
check(GoodImpl2())
check(BadImpl1())
check(BadImpl2())

[out]
__main__:17: error: Argument 1 to "check" has incompatible type "BadImpl1"; expected "Foo"
__main__:17: note: Following member(s) of "BadImpl1" have conflicts:
__main__:17: note:     Expected:
__main__:17: note:         def foo(self) -> Foo
__main__:17: note:     Got:
__main__:17: note:         def foo(self) -> str
__main__:18: error: Argument 1 to "check" has incompatible type "BadImpl2"; expected "Foo"
__main__:18: note: Following member(s) of "BadImpl2" have conflicts:
__main__:18: note:     Expected:
__main__:18: note:         def foo(self) -> Foo
__main__:18: note:     Got:
__main__:18: note:         def foo(self) -> BadImpl1

[case protocol_recursive_with_param]
from typing import Protocol
class Foo(Protocol):
    def foo(self, x: Foo) -> Foo: ...

class GoodImpl1:
    def foo(self, x: GoodImpl1) -> GoodImpl1: return self
class GoodImpl2:
    def foo(self, x: GoodImpl2) -> GoodImpl1: raise NotImplementedError
class BadImpl1:
    def foo(self, x: BadImpl1) -> str: return ''
class BadImpl2:
    def foo(self, x: BadImpl2) -> BadImpl1: raise NotImplementedError

def check(x: Foo) -> None: ...
check(GoodImpl1())
check(GoodImpl2())
check(BadImpl1())
check(BadImpl2())

[out]
__main__:15: error: Argument 1 to "check" has incompatible type "GoodImpl1"; expected "Foo"
__main__:15: note: Following member(s) of "GoodImpl1" have conflicts:
__main__:15: note:     Expected:
__main__:15: note:         def foo(self, x: Foo) -> Foo
__main__:15: note:     Got:
__main__:15: note:         def foo(self, x: GoodImpl1) -> GoodImpl1
__main__:16: error: Argument 1 to "check" has incompatible type "GoodImpl2"; expected "Foo"
__main__:16: note: Following member(s) of "GoodImpl2" have conflicts:
__main__:16: note:     Expected:
__main__:16: note:         def foo(self, x: Foo) -> Foo
__main__:16: note:     Got:
__main__:16: note:         def foo(self, x: GoodImpl2) -> GoodImpl1
__main__:17: error: Argument 1 to "check" has incompatible type "BadImpl1"; expected "Foo"
__main__:17: note: Following member(s) of "BadImpl1" have conflicts:
__main__:17: note:     Expected:
__main__:17: note:         def foo(self, x: Foo) -> Foo
__main__:17: note:     Got:
__main__:17: note:         def foo(self, x: BadImpl1) -> str
__main__:18: error: Argument 1 to "check" has incompatible type "BadImpl2"; expected "Foo"
__main__:18: note: Following member(s) of "BadImpl2" have conflicts:
__main__:18: note:     Expected:
__main__:18: note:         def foo(self, x: Foo) -> Foo
__main__:18: note:     Got:
__main__:18: note:         def foo(self, x: BadImpl2) -> BadImpl1

[case protocol_contravariant]
from typing import Protocol

class X(Protocol):
    def m(self) -> None: ...
    def n(self) -> None: ...
    def o(self) -> None: ...
class P(Protocol):
    def m(self) -> None: ...
    def n(self) -> None: ...
class Q(Protocol):
    def m(self) -> None: ...

class Bar:
    def foo(self, other: P) -> None: ...
    def bar(self, other: P) -> None: ...
class Baz(Bar):
    def foo(self, other: Q) -> None: ...
    def bar(self, other: X) -> None: ...  # E: Argument 1 of "bar" is incompatible with supertype "Bar"; supertype defines the argument type as "P" \
                                          # N: This violates the Liskov substitution principle \
                                          # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides

[case protocol_contravariant_against_class]
from typing import Protocol

class X():
    def m(self) -> None: ...
    def n(self) -> None: ...
    def o(self) -> None: ...
class P(Protocol):
    def m(self) -> None: ...
    def n(self) -> None: ...
class Q():
    def m(self) -> None: ...

class Bar:
    def foo(self, other: P) -> None: ...
    def bar(self, other: P) -> None: ...
class Baz(Bar):
    def foo(self, other: Q) -> None: ...  # E: Argument 1 of "foo" is incompatible with supertype "Bar"; supertype defines the argument type as "P" \
                                          # N: This violates the Liskov substitution principle \
                                          # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
    def bar(self, other: X) -> None: ...  # E: Argument 1 of "bar" is incompatible with supertype "Bar"; supertype defines the argument type as "P" \
                                          # N: This violates the Liskov substitution principle \
                                          # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides

[case protocol_match_avoid_exponential_blowup]
# This was an issue in PyTorch, where this code takes extremely long to
# typecheck, because of an exponential blowup.
from typing import Protocol, Union, TypeVar, Iterator

T_co = TypeVar("T_co", covariant=True)

class NestedSequence(Protocol[T_co]):
    def __getitem__(self, index: int) -> T_co | NestedSequence[T_co]: ...
    # Every additional method here doubled the time it takes to finish
    def x_method(self) -> Iterator[T_co | NestedSequence[T_co]]: ...
    def y_method(self) -> Iterator[T_co | NestedSequence[T_co]]: ...
    def z_method(self) -> Iterator[T_co | NestedSequence[T_co]]: ...

class Base:
    def __getitem__(self, indices: NestedSequence[Base | None]) -> Base: ...

def foo(x: Base) -> None:
    x[::1, ::2]  # E: Invalid index type "tuple[slice[None, None, int], slice[None, None, int]]" for "Base"; expected type "NestedSequence[Base | None]"

[case protocol_self_types_on_both_sides]
from typing import Protocol, TypeVar, Generic
T = TypeVar('T')
class Proto(Protocol):
    def foo(self) -> int: ...
    def bar(self) -> str: ...

class Foo(Generic[T]):
    def foo(self: Foo[int]) -> T: ...
    def bar(self) -> str: ...

class Bar(Generic[T]):
    def foo(self: Bar[str]) -> T: ...
    def bar(self) -> str: ...

def check(foo: Foo[int], foo2: Foo[str], bar: Bar[int], bar2: Bar[str]) -> Proto:
    if bool():
        return foo
    elif bool():
        return foo2 # E: Incompatible return value type (got "Foo[str]", expected "Proto") \
                    # N: Invalid self argument "Foo[str]" to attribute function "foo" with type "Callable[[Foo[int]], T]"
    elif bool():
        return bar # E: Incompatible return value type (got "Bar[int]", expected "Proto") \
                   # N: Invalid self argument "Bar[int]" to attribute function "foo" with type "Callable[[Bar[str]], T]"
    else:
        return bar2 # E: Incompatible return value type (got "Bar[str]", expected "Proto") \
                    # N: Following member(s) of "Bar[str]" have conflicts: \
                    # N:     Expected: \
                    # N:         def foo(self: Proto) -> int \
                    # N:     Got: \
                    # N:         def foo(self: Bar[str]) -> str

[case protocols_concrete_vs_abstract_subtyping]
# Copied from conformance tests (protocols_class_objects.py)
# > Variables and parameters annotated with Type[Proto] accept only concrete
# (non-protocol) subtypes of Proto.

from abc import abstractmethod
from typing import Any, ClassVar, Protocol

class Proto(Protocol):
    @abstractmethod
    def meth(self) -> int: ...

class Concrete:
    def meth(self) -> int:
        return 42

def fun(cls: type[Proto]) -> int:
    return cls().meth()  # OK

fun(Proto)  # E: Only concrete class can be given where "type[Proto]" is expected
fun(Concrete)  # OK

var: type[Proto]
var = Proto  # E: Can only assign concrete classes to a variable of type "type[Proto]"
var = Concrete  # OK
var().meth()  # OK

[case protocols_frozen_dataclass_assignment]
# Copied from conformance tests (protocols_definition.py)
from typing import Protocol, Sequence
from dataclasses import dataclass
class Template6(Protocol):
    @property
    def val1(self) -> Sequence[float]:
        ...

    @val1.setter
    def val1(self, val: Sequence[float]) -> None:
        ...

@dataclass(frozen=False)
class Concrete6_Good3:
    val1: Sequence[float] = [0]

@dataclass(frozen=True)
class Concrete6_Bad3:
    val1: Sequence[float] = [0]


v6_good3: Template6 = Concrete6_Good3()  # OK
v6_bad3: Template6 = Concrete6_Bad3()  # E: Incompatible types in assignment (expression has type "Concrete6_Bad3", variable has type "Template6") \
                                       # N: Protocol member Template6.val1 expected settable variable, got read-only attribute

[case protocols_bad_overrides_due_to_different_param_names_in_conformance_tests]
# flags: --mode default
# Partially copied from conformance tests (protocols_definition.py)
from typing import Protocol, Sequence

class Template5(Protocol):
    def method1(self, a: int, b: int) -> float:
        ...

class Concrete5_Bad1:
    def method1(self, a, c) -> int:
        return 0

class Concrete5_Bad2:
    def method1(self, a: int, c: int) -> int:
        return 0

class Concrete5_Bad3:
    def method1(self, *, a: int, b: int) -> float:
        return 0

class Concrete5_Bad4:
    def method1(self, a: int, b: int, /) -> float:
        return 0

class Concrete5_Bad5:
    @staticmethod
    def method1(self, a: int, b: int) -> float:
        return 0

v5_bad1: Template5 = Concrete5_Bad1()  # E: Incompatible types in assignment (expression has type "Concrete5_Bad1", variable has type "Template5") \
                                       # N: Following member(s) of "Concrete5_Bad1" have conflicts: \
                                       # N:     Expected: \
                                       # N:         def method1(self, a: int, b: int) -> float \
                                       # N:     Got: \
                                       # N:         def method1(self, a: Any, c: Any) -> int

v5_bad2: Template5 = Concrete5_Bad2()  # E: Incompatible types in assignment (expression has type "Concrete5_Bad2", variable has type "Template5") \
                                       # N: Following member(s) of "Concrete5_Bad2" have conflicts: \
                                       # N:     Expected: \
                                       # N:         def method1(self, a: int, b: int) -> float \
                                       # N:     Got: \
                                       # N:         def method1(self, a: int, c: int) -> int

v5_bad3: Template5 = Concrete5_Bad3()  # E: Incompatible types in assignment (expression has type "Concrete5_Bad3", variable has type "Template5") \
                                       # N: Following member(s) of "Concrete5_Bad3" have conflicts: \
                                       # N:     Expected: \
                                       # N:         def method1(self, a: int, b: int) -> float \
                                       # N:     Got: \
                                       # N:         def method1(self, *, a: int, b: int) -> float

v5_bad4: Template5 = Concrete5_Bad4()  # E: Incompatible types in assignment (expression has type "Concrete5_Bad4", variable has type "Template5") \
                                       # N: Following member(s) of "Concrete5_Bad4" have conflicts: \
                                       # N:     Expected: \
                                       # N:         def method1(self, a: int, b: int) -> float \
                                       # N:     Got: \
                                       # N:         def method1(self, int, int, /) -> float

v5_bad5: Template5 = Concrete5_Bad5()  # E: Incompatible types in assignment (expression has type "Concrete5_Bad5", variable has type "Template5") \
                                       # N: Following member(s) of "Concrete5_Bad5" have conflicts: \
                                       # N:     Expected: \
                                       # N:         def method1(self: Template5, a: int, b: int) -> float \
                                       # N:     Got: \
                                       # N:         def method1(self: Any, a: int, b: int) -> float


[case protocols_runtime_checkable_issubclass]
# Copied from conformance tests (protocols_runtime_checkable.py)
from typing import Protocol, runtime_checkable, Any
@runtime_checkable
class DataProtocol(Protocol):
    name: str

    def method1(self) -> int:
        ...

@runtime_checkable
class NonDataProtocol(Protocol):
    def method1(self) -> int:
        ...

def func2(a: Any):
    if issubclass(a, (NonDataProtocol, DataProtocol)):  # E: Only protocols that don't have non-method members can be used with issubclass() \
                                                        # N: Protocol "DataProtocol" has non-method member(s): name
        return

[case protocols_runtime_checkable_invalid_overlap]
# flags: --warn-unreachable
# Copied from conformance tests (protocols_runtime_checkable.py)
from typing import Protocol, runtime_checkable

@runtime_checkable
class Proto2(Protocol):
    name: str

@runtime_checkable
class NonDataProtocol(Protocol):
    def method1(self) -> int: ...

@runtime_checkable
class Proto3(Protocol):
    def method1(self, a: int) -> int: ...

class Concrete3A:
    def method1(self, a: str) -> None: ...

class Concrete3B:
    method1: int = 1

def func3() -> None:
    if isinstance(Concrete3A(), Proto2):  # OK
        pass

    if isinstance(Concrete3A(), Proto3):  # E: Subclass of "Concrete3A" and "Proto3" cannot exist: would have incompatible method signatures
        pass

    if isinstance(
        Concrete3B(), (Proto3, NonDataProtocol)  # E: Subclass of "Concrete3B" and "Proto3" cannot exist: would have incompatible method signatures \
                                                 # E: Subclass of "Concrete3B" and "NonDataProtocol" cannot exist: would have incompatible method signatures
    ):
        pass

    if issubclass(Concrete3A, (Proto3, NonDataProtocol)):  # E: Subclass of "Concrete3A" and "Proto3" cannot exist: would have incompatible method signatures \
                                                           # E: Subclass of "Concrete3A" and "NonDataProtocol" cannot exist: would have incompatible method signatures
        pass

[case protocols_not_instantiated]
# Copied from conformance tests (protocols_explicit.py)
from abc import ABC, abstractmethod
from typing import ClassVar, Protocol

class PColor(Protocol):
    @abstractmethod
    def draw(self) -> str:
        ...

    def complex_method(self) -> int:
        return 1

class NiceColor(PColor):
    def draw(self) -> str:
        return "deep blue"

class BadColor(PColor):
    def draw(self) -> str:
        return super().draw()  # E: Call to abstract method "draw" of "PColor" with trivial body via super() is unsafe

v1: PColor = NiceColor()

[case protocol_assign_to_classvar]
# Copied from conformance tests (protocols_explicit.py)
from typing import ClassVar, Protocol
class Proto1(Protocol):
    cm1: ClassVar[int]
    cm2: ClassVar[int] = 0

    im1: int
    im2: int = 2
    im3: int

    def __init__(self):
        self.im3 = 3


class Proto2(Protocol):
    cm10: int


class Proto3(Proto2, Protocol):
    cm11: int


class Concrete1(Proto1):
    def __init__(self) -> None:
        self.cm1 = 1
        self.im1 = 1
        self.im3 = 3

[case protocol_callable_matching_precise_types]
# flags: --allow-redefinition
from typing import Any, Callable, ParamSpec, Protocol, TypeVar, cast, overload

class Proto1(Protocol):
    def __call__(self, *vals: bytes, max_len: int | None = None) -> list[bytes]:
        ...

def cb1_good1(*vals: bytes, max_len: int | None = None) -> list[bytes]:
    return []

def cb1_bad1(*vals: bytes, max_items: int | None) -> list[bytes]:
    return []

def cb1_bad2(*vals: bytes) -> list[bytes]:
    return []

def cb1_bad3(*vals: bytes, max_len: str | None) -> list[bytes]:
    return []

cb1: Proto1 = cb1_good1  # OK
cb1 = cb1_bad1  # E: Incompatible types in assignment (expression has type "Callable[[VarArg(bytes), NamedArg(int | None, 'max_items')], list[bytes]]", variable has type "Proto1")
cb1 = cb1_bad2  # E: Incompatible types in assignment (expression has type "Callable[[VarArg(bytes)], list[bytes]]", variable has type "Proto1")
cb1 = cb1_bad3  # E: Incompatible types in assignment (expression has type "Callable[[VarArg(bytes), NamedArg(str | None, 'max_len')], list[bytes]]", variable has type "Proto1")

[case protocol_callable_any_matching]
# Copied from conformance tests (callables_annotation.py)
from typing import Protocol, Any, Callable, Concatenate, ParamSpec, TypeVar

T_contra = TypeVar("T_contra", contravariant=True)
P = ParamSpec("P")

class Proto1(Protocol):
    def __call__(self, *args: Any, **kwargs: Any) -> None: ...

class Proto2(Protocol):
    def __call__(self, a: int, /, *args, **kwargs) -> None: ...

class Proto3(Protocol):
    def __call__(self, a: int, *args: Any, **kwargs: Any) -> None: ...

class Proto4(Protocol[P]):
    def __call__(self, a: int, *args: P.args, **kwargs: P.kwargs) -> None: ...

class Proto5(Protocol[T_contra]):
    def __call__(self, *args: T_contra, **kwargs: T_contra) -> None: ...

class Proto6(Protocol):
    def __call__(self, a: int, /, *args: Any, k: str, **kwargs: Any) -> None:
        pass

class Proto7(Protocol):
    def __call__(self, a: float, /, b: int, *, k: str, m: str) -> None:
        pass

class Proto8(Protocol):
    def __call__(self) -> None: ...

def func5(
    p1: Proto1,
    p2: Proto2,
    p3: Proto3,
    p4: Proto4[...],
    p5: Proto5[Any],
    p7: Proto7,
    p8: Proto8,
    c1: Callable[..., None],
    c2: Callable[Concatenate[int, ...], None],
):
    ok1: Callable[..., None] = p1  # OK
    ok2: Proto1 = c1  # OK
    ok3: Callable[..., None] = p5  # OK
    ok4: Proto5[Any] = c1  # OK
    ok5: Callable[Concatenate[int, ...], None] = p2  # OK
    ok6: Proto2 = c2  # OK
    ok7: Callable[..., None] = p3  # OK
    ok8: Proto3 = c1  # OK
    ok9: Proto4[...] = p3  # OK
    ok10: Proto3 = p4  # OK
    ok11: Proto6 = p7  # OK

    err1: Proto5[Any] = p8  # E: Incompatible types in assignment (expression has type "Proto8", variable has type "Proto5[Any]") \
                            # N: Following member(s) of "Proto8" have conflicts: \
                            # N:     Expected: \
                            # N:         def __call__(self, *args: Any, **kwargs: Any) -> None \
                            # N:     Got: \
                            # N:         def __call__(self) -> None

[case protocol_object_attr_access]
# From GH #271
from typing import Protocol

class FooProtocol(Protocol):
    def foo(self) -> None:
        pass

class Fooer:
    def foo(self) -> None:
        pass

class DocProto(Protocol):
    def __str__(self) -> str: ...
    __doc__: str | None

fooer: FooProtocol = Fooer()
fooer.__doc__
fooer.__str__
fooer.__hash__

doc_proto: DocProto = fooer
