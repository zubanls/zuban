[case imports_dunder_all_imports_modified1]
from m1 import *
C()
D  # E: Name "D" is not defined
E  # E: Name "E" is not defined
[file m1.pyi]
from m2 import *
from m2 import __all__ as __all__
__all__.remove("D")
[file m2.pyi]
__all__ = ['C', 'D']
class C: pass
class D: pass
class E: pass

[case imports_dunder_all_imports_modified2]
from m1 import C
from m1 import D
from m1 import E  # E: Module "m1" has no attribute "E"
C()
[file m1.pyi]
from m2 import *
from m2 import __all__ as __all__
__all__.append("D")
class D: pass
[file m2.pyi]
__all__ = ['C']
class C: pass
class E: pass

[case import_no_reexport_if_importing_submodule]
# A bit like testReExportChildStubs, but without relative imports
from mod import submod
reveal_type(submod.C().a)  # N: Revealed type is "str"

[file mod/__init__.pyi]
from mod import submod

[file mod/submod.pyi]
class C:
    a: str

[case import_no_reexport_if_importing_submodule_with_import_as]
# A bit like testReExportChildStubs, but without relative imports
from mod import submod
reveal_type(submod.C().a)  # N: Revealed type is "str"

[file mod/__init__.pyi]
import mod.submod as submod

[file mod/submod.pyi]
class C:
    a: str

[case use_context_of_star_import]
from foo import *

x = [""]
y = []
z = [""]  # E: List item 0 has incompatible type "str"; expected "int"
[file foo.py]
x: list[object]
y: list[int]
z: list[int]

[case import_recursion_usage1]
# A bit like testCyclicUndefinedImportWithName, but with a usage
import a
[file a.py]
from b import no_such_export
reveal_type(no_such_export)  # N: Revealed type is "Any"
[file b.py]
from a import no_such_export  # E: Cannot resolve name "no_such_export" (possible cyclic definition)

[case import_recursion_usage2]
import a
[file a.py]
from b import no_such_export
[file b.py]
from a import no_such_export  # E: Cannot resolve name "no_such_export" (possible cyclic definition)
reveal_type(no_such_export)  # N: Revealed type is "Any"

[case import_recursion_usage3]
import a
reveal_type(a.no_such_export)  # N: Revealed type is "Any"
[file a.py]
from b import no_such_export
[file b.py]
from a import no_such_export  # E: Cannot resolve name "no_such_export" (possible cyclic definition)

[case inference_context_with_star_import]
import module3
from module1 import *
class X:
    def foo(self) -> None:
        from module2 import *
        m1
        m2
    from module3 import *  # E: Unsupported class scoped import
    m3

[file module1.py]
from typing import Self
def m1() -> Self: ...  # E: Self type is only allowed in annotations within class definition
[file module2.py]
from typing import Self
def m2() -> Self: ...  # E: Self type is only allowed in annotations within class definition
[file module3.py]
from typing import Self
def m3() -> Self: ...  # E: Self type is only allowed in annotations within class definition

[case import_from_module_with_empty_all]
import foo
foo.X

[file foo.pyi]
__all__ = ()
class X: ...

[case import_code]
# flags: --show-error-codes
import lxml  # E: Library stubs not installed for "lxml"  [import-untyped] \
             # N: Hint: "python3 -m pip install lxml-stubs" \
             # N: (or run "mypy --install-types" to install all missing stub packages)
import undefined   # E: Cannot find implementation or library stub for module named "undefined"  [import-not-found]

[case inference_with_star_import_in_def]
def f() -> None:
    from foo import *
    y = x
    reveal_type(y)  # N: Revealed type is "int"
    def x() -> int: ...


[file foo.py]
x = 1

[case underscored_reexport_import_with__all__]
import foo
import bar

[file foo.py]
from m import _C  # E: Module "m" does not explicitly export attribute "_C"
from m import _D  # E: Module "m" does not explicitly export attribute "_D"
from k import _C as C2
from k import _D as D2

x: _C
reveal_type(x)  # N: Revealed type is "n.C"

[file bar.pyi]
from m import _C  # E: Module "m" does not explicitly export attribute "_C"
from m import _D  # E: Module "m" does not explicitly export attribute "_D"
from k import _C as C2
from k import _D as D2

[file k.py]
__all__ = ()
from n import C as _C
from o import D as _D

[file m.pyi]
__all__ = ()
from n import C as _C
from o import D as _D

[file n.pyi]
class C: ...

[file o.py]
class D: ...

[case module_finding_with_py_typed]
# pkgs: modulefinder-site-packages
# flags: --mypy-compatible

# Test copied from test__packages_with_ns, some parts omitted, because they are not really relevant
# The results are slightly different. Namespace imports are considered OK.

# Namespace package with py.typed
def ns_pkg_typed() -> None:
    import ns_pkg_typed
    import ns_pkg_typed.a as a
    import ns_pkg_typed.b as b
    import ns_pkg_typed.b.c as c
    import ns_pkg_typed.a.a_var as d  # E: Cannot find implementation or library stub for module named "ns_pkg_typed.a.a_var"

    reveal_type(ns_pkg_typed)  # N: Revealed type is "types.ModuleType"
    reveal_type(a)  # N: Revealed type is "types.ModuleType"
    reveal_type(b)  # N: Revealed type is "types.ModuleType"
    reveal_type(c)  # N: Revealed type is "types.ModuleType"
    reveal_type(d)  # N: Revealed type is "Any"

# Namespace package without py.typed
def ns_pkg_untyped() -> None:
    import ns_pkg_untyped
    import ns_pkg_untyped.a as a
    import ns_pkg_untyped.b as b
    import ns_pkg_untyped.b.c as c
    import ns_pkg_untyped.a.a_var as d

    reveal_type(ns_pkg_untyped)  # N: Revealed type is "types.ModuleType"
    reveal_type(a)  # N: Revealed type is "Any"
    reveal_type(b)  # N: Revealed type is "types.ModuleType"
    reveal_type(c)  # N: Revealed type is "Any"
    reveal_type(d)  # N: Revealed type is "Any"

# Namespace package without stub package
def ns_pkg_w_stubs() -> None:
    import ns_pkg_w_stubs
    import ns_pkg_w_stubs.typed as a
    import ns_pkg_w_stubs.typed_inline as b
    import ns_pkg_w_stubs.untyped as c

    reveal_type(ns_pkg_w_stubs)  # N: Revealed type is "types.ModuleType"
    reveal_type(a)  # N: Revealed type is "types.ModuleType"
    reveal_type(b)  # N: Revealed type is "types.ModuleType"
    reveal_type(c)  # N: Revealed type is "Any"

# Regular package with py.typed
def pkg_typed() -> None:
    import pkg_typed
    import pkg_typed.a as a
    import pkg_typed.b as b
    import pkg_typed.b.c as c
    import pkg_typed.a.a_var as d  # E: Cannot find implementation or library stub for module named "pkg_typed.a.a_var"

    reveal_type(pkg_typed)  # N: Revealed type is "types.ModuleType"
    reveal_type(a)  # N: Revealed type is "types.ModuleType"
    reveal_type(b)  # N: Revealed type is "types.ModuleType"
    reveal_type(c)  # N: Revealed type is "types.ModuleType"
    reveal_type(d)  # N: Revealed type is "Any"

# Regular package without py.typed
def pkg_untyped() -> None:
    import pkg_untyped
    import pkg_untyped.a as a
    import pkg_untyped.b as b
    import pkg_untyped.b.c as c
    import pkg_untyped.a.a_var as d

    reveal_type(pkg_untyped)  # N: Revealed type is "Any"
    reveal_type(a)  # N: Revealed type is "Any"
    reveal_type(b)  # N: Revealed type is "Any"
    reveal_type(c)  # N: Revealed type is "Any"
    reveal_type(d)  # N: Revealed type is "Any"


# Top-level Python file in site-packages
def standalone() -> None:
    import standalone
    import standalone.standalone_var as s
    reveal_type(standalone)  # N: Revealed type is "Any"
    reveal_type(s)  # N: Revealed type is "Any"

# Something that doesn't exist
import does_not_exist  # E: Cannot find implementation or library stub for module named "does_not_exist"

[case type_def_with_with_site_package_without_py_typed]
# pkgs: modulefinder-site-packages

import ns_pkg_w_stubs

a: ns_pkg_w_stubs.untyped
b: ns_pkg_w_stubs.untyped.A
c: ns_pkg_w_stubs.typed  # E: Module "ns_pkg_w_stubs.typed" is not valid as a type \
                         # N: Perhaps you meant to use a protocol matching the module structure?
d: ns_pkg_w_stubs.typed.A  # E: Name "ns_pkg_w_stubs.typed.A" is not defined

reveal_type(a)  # N: Revealed type is "Any"
reveal_type(b)  # N: Revealed type is "Any"
reveal_type(c)  # N: Revealed type is "Any"
reveal_type(d)  # N: Revealed type is "Any"

[case namespace_attributes]
# pkgs: modulefinder-site-packages

import ns_pkg_w_stubs

reveal_type(ns_pkg_w_stubs.untyped)  # N: Revealed type is "Any"
reveal_type(ns_pkg_w_stubs.typed)  # N: Revealed type is "types.ModuleType"
reveal_type(ns_pkg_w_stubs.typed_inline)  # N: Revealed type is "types.ModuleType"

from ns_pkg_w_stubs import untyped
from ns_pkg_w_stubs import typed
from ns_pkg_w_stubs import typed_inline
reveal_type(untyped)  # N: Revealed type is "Any"
reveal_type(typed)  # N: Revealed type is "types.ModuleType"
reveal_type(typed_inline)  # N: Revealed type is "types.ModuleType"

[case namespace_star_attributes_should_not_error]
# pkgs: modulefinder-site-packages

def untyped() -> None:
    from ns_pkg_w_stubs.untyped import *
    ZubanCls  # E: Name "ZubanCls" is not defined
    z: ZubanCls  # E: Name "ZubanCls" is not defined

def typed() -> None:
    from ns_pkg_w_stubs.typed import *
    ZubanCls
    z: ZubanCls

def typed_inline() -> None:
    from ns_pkg_w_stubs.typed_inline import *
    ZubanCls
    z: ZubanCls

[case invalidation_of_relative_paths1]
from foo import bar

[file foo/__init__.py]
a = 1
[file foo/__init__.py.2]
a = ""

[file foo/bar.py]
from . import a
reveal_type(a)

[out]
foo/bar.py:2: note: Revealed type is "int"
[out2]
foo/bar.py:2: note: Revealed type is "str"

[case invalidation_of_relative_paths2]
from foo import bar

[file foo/__init__.py.2]
a = ""

[file foo/a.py]

[file foo/bar.py]
from . import a
reveal_type(a)

[out]
foo/bar.py:2: note: Revealed type is "types.ModuleType"
[out2]
foo/bar.py:2: note: Revealed type is "str"

[case invalidation_of_relative_paths3]
from foo import bar

[file foo/__init__.py]
a = ""

[delete foo/__init__.py.2]

[file foo/a.py]

[file foo/bar.py]
from . import a
reveal_type(a)

[out]
foo/bar.py:2: note: Revealed type is "str"
[out2]
foo/bar.py:2: note: Revealed type is "types.ModuleType"

[case star_import_with_import_overwrite]
from typing import *

def f() -> None:
    from typing import Union

    def g() -> Union[int, str]: ...

[case star_import_with_same_overwrite_should_not_crash]
from m import x, y

[file m.py]
from n import *
from n import x, y

[file n.py]
x = undefined()  # E: Name "undefined" is not defined
y = 1

[case star_import_circular1]
from m import x
reveal_type(x)  # N: Revealed type is "Any"

[file m.py]
from m import *
foo  # E: Name "foo" is not defined
x = str()

[case star_import_circular2]
from m import x
reveal_type(x)  # N: Revealed type is "Any"

[file m.py]
from n import *
foo  # E: Name "foo" is not defined
x = str()

[file n.py]
from m import *

[case star_import_circular3]
from m import x
reveal_type(x)  # N: Revealed type is "Any"

[file m.py]
from n import *
foo  # E: Name "foo" is not defined
x = str()

[file n.py]
from l import *

[file l.py]
from m import *

[case star_import_with_module_and_types]
# flags: --disallow-redefinition
import x
y: x.m  # E: Module "m" is not valid as a type  # N: Perhaps you meant to use a protocol matching the module structure?
reveal_type(x.m)  # N: Revealed type is "def () -> n.m"

[file m.py]
[file n.py]
class m: ...

[file x.py]
from n import *
import m  # E: Incompatible import of "m" (imported name has type Module, local name has type "type[m]")
import m  # E: Incompatible import of "m" (imported name has type Module, local name has type "type[m]")

[case importing_dunder_file]
reveal_type(__file__)  # N: Revealed type is "str"
from m import __file__ as f
reveal_type(f)  # N: Revealed type is "str"

[file m.py]

[case import_name_at_end]
x: mm.C
y: m.C

reveal_type(x)  # N: Revealed type is "m.C"
reveal_type(y)  # N: Revealed type is "m.C"

import m
import m as mm

[file m.py]
class C: ...

[case import_twice_at_end]
x: C
y: n
z: nn

x2: C
y2: n
z2: nn

reveal_type(x)  # N: Revealed type is "Any"
reveal_type(y)  # N: Revealed type is "Any"
reveal_type(z)  # N: Revealed type is "Any"

from m import C  # E: Module "m" has no attribute "C"
from m import C  # E: Module "m" has no attribute "C" \
                 # E: Name "C" already defined (possibly by an import)
import n  # E: Cannot find implementation or library stub for module named "n"
import n  # E: Cannot find implementation or library stub for module named "n" \
          # E: Name "n" already defined (possibly by an import)
import m.undefined as nn  # E: Cannot find implementation or library stub for module named "m.undefined"
import m.undefined as nn  # E: Cannot find implementation or library stub for module named "m.undefined" \
                          # E: Name "nn" already defined (possibly by an import)

[file m/__init__.py]

[case type_ignore_can_be_on_start_of_import_mypy_compatible]
# flags: --mypy-compatible
from m import (  # type: ignore[attr-defined]
    undefined
)
from m import (  # E: Module "m" has no attribute "undefined2"
    undefined2
)

[file m.py]

[case type_ignore_not_possible_on_start_of_import_no_mypy_compatible]
# flags: --no-mypy-compatible
from m import (  # type: ignore[attr-defined]
    undefined  # E: Module "m" has no attribute "undefined"
)
from m import (
    undefined2  # E: Module "m" has no attribute "undefined2"
)

[file m.py]


[case type_ignore_for_redefinition_can_be_on_start_of_import_mypy_compatible]
# flags: --mypy-compatible --show-error-codes
if bool():
    class C: ...
    class D: ...
else:
    from m import (  # type: ignore[no-redef,attr-defined]
        C
    )
    from m import (  # E: Module "m" has no attribute "D"  [attr-defined] \
                     # E: Name "D" already defined on line 4  [no-redef]
        D
    )

[file m.py]

[case type_ignore_for_redefinition_not_possible_on_start_of_import_no_mypy_compatible]
# flags: --no-mypy-compatible --show-error-codes
if bool():
    class C: ...
    class D: ...
else:
    from m import (  # type: ignore[no-redef,attr-defined]
        C  # E: Module "m" has no attribute "C"  [attr-defined] \
           # E: Name "C" already defined on line 3  [no-redef]
    )
    from m import (
        D  # E: Module "m" has no attribute "D"  [attr-defined] \
           # E: Name "D" already defined on line 4  [no-redef]
    )

[file m.py]

[case type_alias_overrides_star_import]
from m import *
type X = str  # E: Incompatible types in assignment (expression has type "TypeAliasType", variable has type "type[C]")

reveal_type(X)  # N: Revealed type is "def () -> m.C"
def f(x: X) -> None:
    reveal_type(x)  # N: Revealed type is "str"

[file m.py]
class C: ...
X = C

[case func_star_import]
def g() -> None:
    from m import *
    reveal_type(a)  # N: Revealed type is "int | None"

[file m.py]
if bool():
    a = None
else:
    a = 1

[case relative_import_many_dots_without_namespace]

[file outer.py]
x = 1

[file bar/inner.py]
y = ""

[file bar/__init__.py]

[file bar/foo.py]
def f() -> None:
    from . import outer  # E: Module "bar" has no attribute "outer"
    from . import inner
    from .outer import x  # E: Cannot find implementation or library stub for module named "bar.outer"
    from .inner import y
    reveal_type(x)  # N: Revealed type is "Any"
    reveal_type(y)  # N: Revealed type is "str"

def g() -> None:
    from .. import outer  # E: No parent module -- cannot perform relative import
    from .. import inner  # E: No parent module -- cannot perform relative import
    from ..outer import x  # E: No parent module -- cannot perform relative import
    from ..inner import y  # E: No parent module -- cannot perform relative import \
                           # E: Cannot find implementation or library stub for module named "inner"
    reveal_type(x)  # N: Revealed type is "int"
    reveal_type(y)  # N: Revealed type is "Any"

def h() -> None:
    from ... import outer  # E: No parent module -- cannot perform relative import
    from ... import inner  # E: No parent module -- cannot perform relative import
    from ...outer import x  # E: No parent module -- cannot perform relative import
    from ...inner import y  # E: No parent module -- cannot perform relative import
    reveal_type(x)  # N: Revealed type is "Any"
    reveal_type(y)  # N: Revealed type is "Any"

def i() -> None:
    from .... import outer  # E: No parent module -- cannot perform relative import
    from .... import inner  # E: No parent module -- cannot perform relative import

[case relative_import_many_dots_with_namespace]

[file outer.py]
x = 1

[file bar/inner.py]
y = ""

[file bar/foo.py]
def f() -> None:
    from . import inner
    from . import outer  # E: Module "bar" has no attribute "outer"
    from .outer import x  # E: Cannot find implementation or library stub for module named "bar.outer"
    from .inner import y
    reveal_type(x)  # N: Revealed type is "Any"
    reveal_type(y)  # N: Revealed type is "str"

def g() -> None:
    from .. import inner  # E: No parent module -- cannot perform relative import
    from .. import outer  # E: No parent module -- cannot perform relative import
    from ..outer import x  # E: No parent module -- cannot perform relative import
    from ..inner import y  # E: No parent module -- cannot perform relative import \
                           # E: Cannot find implementation or library stub for module named "inner"
    reveal_type(x)  # N: Revealed type is "int"
    reveal_type(y)  # N: Revealed type is "Any"

def h() -> None:
    from ... import inner  # E: No parent module -- cannot perform relative import
    from ... import outer  # E: No parent module -- cannot perform relative import
    from ...outer import x  # E: No parent module -- cannot perform relative import
    from ...inner import y  # E: No parent module -- cannot perform relative import
    reveal_type(x)  # N: Revealed type is "Any"
    reveal_type(y)  # N: Revealed type is "Any"

def i() -> None:
    from .... import inner  # E: No parent module -- cannot perform relative import
    from .... import outer  # E: No parent module -- cannot perform relative import

[case name_on_import_correct_error_code]
# flags: --show-error-codes
import pathlib

test: pathlib.NonExistentType  # E: Name "pathlib.NonExistentType" is not defined  [name-defined]
_  # E: Name "_" is not defined  [name-defined]

[case no_crash_on_syntax_error_import]
# flags: --no-mypy-compatible
from typing import Union, List,  # E: Invalid syntax

class Foo:
    groups: List[str]  # E: Invalid type comment or annotation

[case untyped_imports_default]
# pkgs: typedpkg_ns_b
# flags: --no-mypy-compatible
import typedpkg_ns.b.bbb as b
b.bf("foo", "bar")  # E: Too many arguments for "bf"
