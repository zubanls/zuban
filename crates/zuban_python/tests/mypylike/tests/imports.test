[case imports_dunder_all_imports_modified1]
from m1 import *
C()
D  # E: Name "D" is not defined
E  # E: Name "E" is not defined
[file m1.pyi]
from m2 import *
from m2 import __all__ as __all__
__all__.remove("D")
[file m2.pyi]
__all__ = ['C', 'D']
class C: pass
class D: pass
class E: pass

[case imports_dunder_all_imports_modified2]
from m1 import C
from m1 import D
from m1 import E  # E: Module "m1" has no attribute "E"
C()
[file m1.pyi]
from m2 import *
from m2 import __all__ as __all__
__all__.append("D")
class D: pass
[file m2.pyi]
__all__ = ['C']
class C: pass
class E: pass

[case import_no_reexport_if_importing_submodule]
# A bit like testReExportChildStubs, but without relative imports
from mod import submod
reveal_type(submod.C().a)  # N: Revealed type is "builtins.str"

[file mod/__init__.pyi]
from mod import submod

[file mod/submod.pyi]
class C:
    a: str

[case import_no_reexport_if_importing_submodule_with_import_as]
# A bit like testReExportChildStubs, but without relative imports
from mod import submod
reveal_type(submod.C().a)  # N: Revealed type is "builtins.str"

[file mod/__init__.pyi]
import mod.submod as submod

[file mod/submod.pyi]
class C:
    a: str

[case use_context_of_star_import]
from foo import *

x = [""]
y = []
z = [""]  # E: List item 0 has incompatible type "str"; expected "int"
[file foo.py]
x: list[object]
y: list[int]
z: list[int]

[case import_recursion_usage1]
# A bit like testCyclicUndefinedImportWithName, but with a usage
import a
[file a.py]
from b import no_such_export  # E: Module "b" has no attribute "no_such_export"
reveal_type(no_such_export)  # N: Revealed type is "Any"
[file b.py]
from a import no_such_export

[case import_recursion_usage2]
import a
[file a.py]
from b import no_such_export  # E: Module "b" has no attribute "no_such_export"
[file b.py]
from a import no_such_export
reveal_type(no_such_export)  # N: Revealed type is "Any"

[case import_recursion_usage3]
import a
reveal_type(a.no_such_export)  # N: Revealed type is "Any"
[file a.py]
from b import no_such_export  # E: Module "b" has no attribute "no_such_export"
[file b.py]
from a import no_such_export

[case inference_context_with_star_import]
import module3
from module1 import *
class X:
    def foo(self) -> None:
        from module2 import *
        m1
        m2
    from module3 import *  # E: Unsupported class scoped import
    m3

[file module1.py]
from typing import Self
def m1() -> Self: ...  # E: Self type is only allowed in annotations within class definition
[file module2.py]
from typing import Self
def m2() -> Self: ...  # E: Self type is only allowed in annotations within class definition
[file module3.py]
from typing import Self
def m3() -> Self: ...  # E: Self type is only allowed in annotations within class definition

[case import_from_module_with_empty_all]
import foo
foo.X

[file foo.pyi]
__all__ = ()
class X: ...

[case import_code]
# flags: --show-error-codes
import lxml  # E: Library stubs not installed for "lxml"  [import-untyped] \
             # N: Hint: "python3 -m pip install lxml-stubs" \
             # N: (or run "mypy --install-types" to install all missing stub packages)
import undefined   # E: Cannot find implementation or library stub for module named "undefined"  [import-not-found]

[case inference_with_star_import_in_def]
def f() -> None:
    from foo import *
    y = x
    reveal_type(y)  # N: Revealed type is "int"
    def x() -> int: ...


[file foo.py]
x = 1

[case underscored_reexport_import_with__all__]
import foo
import bar

[file foo.py]
from m import _C  # E: Module "m" does not explicitly export attribute "_C"
from m import _D  # E: Module "m" does not explicitly export attribute "_D"
from k import _C as C2
from k import _D as D2

x: _C
reveal_type(x)  # N: Revealed type is "n.C"

[file bar.pyi]
from m import _C  # E: Module "m" does not explicitly export attribute "_C"
from m import _D  # E: Module "m" does not explicitly export attribute "_D"
from k import _C as C2
from k import _D as D2

[file k.py]
__all__ = ()
from n import C as _C
from o import D as _D

[file m.pyi]
__all__ = ()
from n import C as _C
from o import D as _D

[file n.pyi]
class C: ...

[file o.py]
class D: ...

[case module_finding_with_py_typed]
# pkgs: modulefinder-site-packages

# Test copied from test__packages_with_ns, some parts omitted, because they are not really relevant
# The results are slightly different. Namespace imports are considered OK.

# Namespace package with py.typed
def ns_pkg_typed() -> None:
    import ns_pkg_typed
    import ns_pkg_typed.a as a
    import ns_pkg_typed.b as b
    import ns_pkg_typed.b.c as c
    import ns_pkg_typed.a.a_var as d  # E: Cannot find implementation or library stub for module named "ns_pkg_typed.a.a_var"

    reveal_type(ns_pkg_typed)  # N: Revealed type is "types.ModuleType"
    reveal_type(a)  # N: Revealed type is "types.ModuleType"
    reveal_type(b)  # N: Revealed type is "types.ModuleType"
    reveal_type(c)  # N: Revealed type is "types.ModuleType"
    reveal_type(d)  # N: Revealed type is "Any"

# Namespace package without py.typed
def ns_pkg_untyped() -> None:
    import ns_pkg_untyped
    import ns_pkg_untyped.a as a
    import ns_pkg_untyped.b as b
    import ns_pkg_untyped.b.c as c
    import ns_pkg_untyped.a.a_var as d

    reveal_type(ns_pkg_untyped)  # N: Revealed type is "types.ModuleType"
    reveal_type(a)  # N: Revealed type is "Any"
    reveal_type(b)  # N: Revealed type is "types.ModuleType"
    reveal_type(c)  # N: Revealed type is "Any"
    reveal_type(d)  # N: Revealed type is "Any"

# Namespace package without stub package
def ns_pkg_w_stubs() -> None:
    import ns_pkg_w_stubs
    import ns_pkg_w_stubs.typed as a
    import ns_pkg_w_stubs.typed_inline as b
    import ns_pkg_w_stubs.untyped as c

    reveal_type(ns_pkg_w_stubs)  # N: Revealed type is "types.ModuleType"
    reveal_type(a)  # N: Revealed type is "types.ModuleType"
    reveal_type(b)  # N: Revealed type is "types.ModuleType"
    reveal_type(c)  # N: Revealed type is "Any"

# Regular package with py.typed
def pkg_typed() -> None:
    import pkg_typed
    import pkg_typed.a as a
    import pkg_typed.b as b
    import pkg_typed.b.c as c
    import pkg_typed.a.a_var as d  # E: Cannot find implementation or library stub for module named "pkg_typed.a.a_var"

    reveal_type(pkg_typed)  # N: Revealed type is "types.ModuleType"
    reveal_type(a)  # N: Revealed type is "types.ModuleType"
    reveal_type(b)  # N: Revealed type is "types.ModuleType"
    reveal_type(c)  # N: Revealed type is "types.ModuleType"
    reveal_type(d)  # N: Revealed type is "Any"

# Regular package without py.typed
def pkg_untyped() -> None:
    import pkg_untyped
    import pkg_untyped.a as a
    import pkg_untyped.b as b
    import pkg_untyped.b.c as c
    import pkg_untyped.a.a_var as d

    reveal_type(pkg_untyped)  # N: Revealed type is "Any"
    reveal_type(a)  # N: Revealed type is "Any"
    reveal_type(b)  # N: Revealed type is "Any"
    reveal_type(c)  # N: Revealed type is "Any"
    reveal_type(d)  # N: Revealed type is "Any"


# Top-level Python file in site-packages
def standalone() -> None:
    import standalone
    import standalone.standalone_var as s
    reveal_type(standalone)  # N: Revealed type is "Any"
    reveal_type(s)  # N: Revealed type is "Any"

# Something that doesn't exist
import does_not_exist  # E: Cannot find implementation or library stub for module named "does_not_exist"

[case type_def_with_with_site_package_without_py_typed]
# pkgs: modulefinder-site-packages

import ns_pkg_w_stubs

a: ns_pkg_w_stubs.untyped
b: ns_pkg_w_stubs.untyped.A
c: ns_pkg_w_stubs.typed  # E: Module "ns_pkg_w_stubs-stubs.typed" is not valid as a type \
                         # N: Perhaps you meant to use a protocol matching the module structure?
d: ns_pkg_w_stubs.typed.A  # E: Name "ns_pkg_w_stubs.typed.A" is not defined

reveal_type(a)  # N: Revealed type is "Any"
reveal_type(b)  # N: Revealed type is "Any"
reveal_type(c)  # N: Revealed type is "Any"
reveal_type(d)  # N: Revealed type is "Any"

[case namespace_attributes]
# pkgs: modulefinder-site-packages

import ns_pkg_w_stubs

reveal_type(ns_pkg_w_stubs.untyped)  # N: Revealed type is "Any"
reveal_type(ns_pkg_w_stubs.typed)  # N: Revealed type is "types.ModuleType"
reveal_type(ns_pkg_w_stubs.typed_inline)  # N: Revealed type is "types.ModuleType"

from ns_pkg_w_stubs import untyped
from ns_pkg_w_stubs import typed
from ns_pkg_w_stubs import typed_inline
reveal_type(untyped)  # N: Revealed type is "Any"
reveal_type(typed)  # N: Revealed type is "types.ModuleType"
reveal_type(typed_inline)  # N: Revealed type is "types.ModuleType"

[case namespace_star_attributes_should_not_error]
# pkgs: modulefinder-site-packages

def untyped() -> None:
    from ns_pkg_w_stubs.untyped import *
    ZubanCls  # E: Name "ZubanCls" is not defined
    z: ZubanCls  # E: Name "ZubanCls" is not defined

def typed() -> None:
    from ns_pkg_w_stubs.typed import *
    ZubanCls
    z: ZubanCls

def typed_inline() -> None:
    from ns_pkg_w_stubs.typed_inline import *
    ZubanCls
    z: ZubanCls

[case invalidation_of_relative_paths1]
from foo import bar

[file foo/__init__.py]
a = 1
[file foo/__init__.py.2]
a = ""

[file foo/bar.py]
from . import a
reveal_type(a)

[out]
foo/bar.py:2: note: Revealed type is "int"
[out2]
foo/bar.py:2: note: Revealed type is "str"

[case invalidation_of_relative_paths2]
from foo import bar

[file foo/__init__.py.2]
a = ""

[file foo/a.py]

[file foo/bar.py]
from . import a
reveal_type(a)

[out]
foo/bar.py:2: note: Revealed type is "types.ModuleType"
[out2]
foo/bar.py:2: note: Revealed type is "str"

[case invalidation_of_relative_paths3]
from foo import bar

[file foo/__init__.py]
a = ""

[delete foo/__init__.py.2]

[file foo/a.py]

[file foo/bar.py]
from . import a
reveal_type(a)

[out]
foo/bar.py:2: note: Revealed type is "str"
[out2]
foo/bar.py:2: note: Revealed type is "types.ModuleType"
