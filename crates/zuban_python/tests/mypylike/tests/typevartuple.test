[case invalid_unpack_type_var_tuple]
from typing import TypeVarTuple, Unpack

Ts = TypeVarTuple("Ts")
def foo(*args: Unpack[Ts]) -> None:
    x: Unpack[Ts]  # E: Unpack is only valid in a variadic position
    reveal_type(x)  # N: Revealed type is "Any"

[case unknown_unpack]
from typing import Unpack
def foo(*args: Unpack[Unknown]) -> None: ...  # E: Name "Unknown" is not defined

[case type_var_tuple_type_application_should_not_crash]
from typing import TypeVarTuple, TypeVar, Generic, Unpack
Ts = TypeVarTuple('Ts')
T1 = TypeVar('T1')
T2 = TypeVar('T2')

class E(Generic[*Ts, T1, T2]): pass
E[int, str]
E[int, str, float]
E[int, str, float, bool]

class F(Generic[Unpack[Ts], T1, T2]): pass
F[int, str]
F[int, str, float]
F[int, str, float, bool]

[case type_var_tuple_aliases]
# flags: --mode typed
# From conformance tests (generics_typevartuple_specialization.py)
from typing import TypeVarTuple, TypeVar
T = TypeVar("T")
Ts = TypeVarTuple("Ts")
Ts1 = TypeVarTuple("Ts1")
Ts2 = TypeVarTuple("Ts2")

IntTupleVar = tuple[int, *Ts1]  # OK
IntFloatTupleVar = IntTupleVar[float, *Ts2]  # OK
IntFloatsTupleVar = IntTupleVar[*tuple[float, ...]]  # OK

IntTupleGeneric = tuple[int, T]

IntTupleGeneric[str]  # OK
IntTupleGeneric[*Ts]  # E: Unpack is only valid in a variadic position  # E: TypeVarTuple "Ts" is unbound
IntTupleGeneric[*tuple[float, ...]]  # E: Unpack is only valid in a variadic position

[case two_typevartuples_in_class_not_allowed_even_with_invalid_definitions]
from typing import Generic, TypeVarTuple
Ts1 = TypeVarTuple("Ts1", int, str)  # E: Too many positional arguments for "TypeVarTuple"
Ts2 = TypeVarTuple("Ts2", bound=int)  # E: Unexpected keyword argument "bound" for "TypeVarTuple"

class Array3(Generic[*Ts1, *Ts2]):  # E: Can only use one type var tuple in a class def
    ...

[case typevartuple_match_length]
# flags: --mode typed
# Copied from conformance tests (generics_typevartuple_basic.py)
from typing import assert_type

def func2[*Ts](arg1: tuple[*Ts], arg2: tuple[*Ts]) -> tuple[*Ts]: ...

assert_type(func2((0,), (1,)), tuple[int])  # OK
func2((0,), (0.0,))  # OK
func2((0.0,), (0,))  # OK
func2((0,), (1,))  # OK

func2((0,), ("0",))  # E: Argument 2 to "func2" has incompatible type "tuple[Literal['0']]"; expected "tuple[int]"
func2((0, 0), (0,))  # E: Argument 2 to "func2" has incompatible type "tuple[Literal[0]]"; expected "tuple[int, int]"

[case typevartuple_non_unpacked_error]
# flags: --mode typed
# Copied from conformance tests (generics_typevartuple_basic.py)
from typing import Generic, TypeVarTuple

Shape = TypeVarTuple("Shape")

class ClassA(Generic[Shape]):  # E: Free type variable expected in Generic[...]
    def __init__(self, shape: tuple[Shape]):  # E: TypeVarTuple "Shape" is only valid with an unpack
        self._shape: tuple[*Shape] = shape

    def get_shape(self) -> tuple[Shape]:  # E: TypeVarTuple "Shape" is only valid with an unpack
        return self._shape

    def method1(*args: Shape) -> None:  # E: TypeVarTuple "Shape" is only valid with an unpack
        ...

[case copied_testAliasToCallableWithUnpack]
# We want to ensure this does not fail for no-mypy-compatible mode, because
# *args/**kwargs handling is a bit specialized for those two modes.
from typing import Any, Callable, Tuple, Unpack

_CallableValue = Callable[[Unpack[Tuple[Any, ...]]], Any]
def higher_order(f: _CallableValue) -> None: ...

def good1(*args: int) -> None: ...
def good2(*args: str) -> int: ...

# These are special-cased for *args: Any (as opposite to *args: object)
def ok1(a: str, b: int, /) -> None: ...
def ok2(c: bytes, *args: int) -> str: ...

def bad1(*, d: str) -> int: ...
def bad2(**kwargs: None) -> None: ...

higher_order(good1)
higher_order(good2)

higher_order(ok1)
higher_order(ok2)

higher_order(bad1)  # E: Argument 1 to "higher_order" has incompatible type "Callable[[NamedArg(str, 'd')], int]"; expected "Callable[[VarArg(Any)], Any]"
higher_order(bad2)  # E: Argument 1 to "higher_order" has incompatible type "Callable[[KwArg(None)], None]"; expected "Callable[[VarArg(Any)], Any]"

[case type_var_tuple_param_spec_interaction_should_not_crash]
# From GH #265
from typing import Unpack
from typing_extensions import ParamSpec, TypeVarTuple, Callable

_P = ParamSpec("_P")
_Ts = TypeVarTuple("_Ts")

def foo(*args: Unpack[_Ts]):
    pass

def foo2(*args: Unpack[_Ts], **kwargs):
    pass

def bar(c: Callable[_P, None], *args: _P.args, **kwargs: _P.kwargs):
    foo(*args)  # E: ParamSpec arguments must be of types "*_P.args, **_P.kwargs"  # E: Passing a ParamSpec to a tuple unpack is not possible
    foo2(*args, **kwargs)  # E: Passing a ParamSpec to a tuple unpack is not possible
