[case invalid_unpack_type_var_tuple]
from typing import TypeVarTuple, Unpack

Ts = TypeVarTuple("Ts")
def foo(*args: Unpack[Ts]) -> None:
    x: Unpack[Ts]  # E: Unpack is only valid in a variadic position
    reveal_type(x)  # N: Revealed type is "Any"

[case unknown_unpack]
from typing import Unpack
def foo(*args: Unpack[Unknown]) -> None: ...  # E: Name "Unknown" is not defined

[case type_var_tuple_type_application_should_not_crash]
from typing import TypeVarTuple, TypeVar, Generic, Unpack
Ts = TypeVarTuple('Ts')
T1 = TypeVar('T1')
T2 = TypeVar('T2')

class E(Generic[*Ts, T1, T2]): pass
E[int, str]
E[int, str, float]
E[int, str, float, bool]

class F(Generic[Unpack[Ts], T1, T2]): pass
F[int, str]
F[int, str, float]
F[int, str, float, bool]

[case type_var_tuple_aliases]
# flags: --no-mypy-compatible
# From conformance tests (generics_typevartuple_specialization.py)
from typing import TypeVarTuple, TypeVar
T = TypeVar("T")
Ts = TypeVarTuple("Ts")
Ts1 = TypeVarTuple("Ts1")
Ts2 = TypeVarTuple("Ts2")

IntTupleVar = tuple[int, *Ts1]  # OK
IntFloatTupleVar = IntTupleVar[float, *Ts2]  # OK
IntFloatsTupleVar = IntTupleVar[*tuple[float, ...]]  # OK

IntTupleGeneric = tuple[int, T]

IntTupleGeneric[str]  # OK
IntTupleGeneric[*Ts]  # E: Unpack is only valid in a variadic position  # E: TypeVarTuple "Ts" is unbound
IntTupleGeneric[*tuple[float, ...]]  # E: Unpack is only valid in a variadic position

[case two_typevartuples_in_class_not_allowed_even_with_invalid_definitions]
from typing import Generic, TypeVarTuple
Ts1 = TypeVarTuple("Ts1", int, str)  # E: Too many positional arguments for "TypeVarTuple"
Ts2 = TypeVarTuple("Ts2", bound=int)  # E: Unexpected keyword argument "bound" for "TypeVarTuple"

class Array3(Generic[*Ts1, *Ts2]):  # E: Can only use one type var tuple in a class def
    ...

[case typevartuple_match_length]
# flags: --no-mypy-compatible
# Copied from conformance tests (generics_typevartuple_basic.py)
from typing import assert_type

def func2[*Ts](arg1: tuple[*Ts], arg2: tuple[*Ts]) -> tuple[*Ts]: ...

assert_type(func2((0,), (1,)), tuple[int])  # OK
func2((0,), (0.0,))  # OK
func2((0.0,), (0,))  # OK
func2((0,), (1,))  # OK

func2((0,), ("0",))  # E: Argument 2 to "func2" has incompatible type "tuple[Literal['0']]"; expected "tuple[int]"
func2((0, 0), (0,))  # E: Argument 2 to "func2" has incompatible type "tuple[Literal[0]]"; expected "tuple[int, int]"

[case typevartuple_non_unpacked_error]
# Copied from conformance tests (generics_typevartuple_basic.py)
from typing import Generic, TypeVarTuple

Shape = TypeVarTuple("Shape")

class ClassA(Generic[Shape]):  # E: Free type variable expected in Generic[...]
    def __init__(self, shape: tuple[Shape]):  # E: TypeVarTuple "Shape" is only valid with an unpack
        self._shape: tuple[*Shape] = shape

    def get_shape(self) -> tuple[Shape]:  # E: TypeVarTuple "Shape" is only valid with an unpack
        return self._shape

    def method1(*args: Shape) -> None:  # E: TypeVarTuple "Shape" is only valid with an unpack
        ...
