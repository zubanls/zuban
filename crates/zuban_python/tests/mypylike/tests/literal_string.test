[case literal_string_definitions]
# Copied from conformance tests (literals_literalstring.py)
from typing import LiteralString, TypeVar, Literal
variable_annotation: LiteralString

def my_function(literal_string: LiteralString) -> LiteralString:
    ...

class Foo:
    my_attribute: LiteralString = ""

type_argument: list[LiteralString]

T = TypeVar("T", bound=LiteralString)

bad_union: Literal["hello", LiteralString]  # E: Parameter 2 of Literal[...] is invalid
bad_nesting: Literal[LiteralString]  # E: Parameter 1 of Literal[...] is invalid

[case literal_string_simple_matching_no_mypy_compatible]
# flags: --mode typed
from typing import Literal, LiteralString
def func1(a: Literal["one"], b: Literal["two"], c: str):
    x1: LiteralString = a
    x2: Literal[""] = b  # E: Incompatible types in assignment (expression has type "Literal['two']", variable has type "Literal['']")
    x3: LiteralString = c  # E: Incompatible types in assignment (expression has type "str", variable has type "LiteralString")

[case literal_string_simple_matching_mypy_compatible]
# flags: --mode mypy
from typing import Literal, LiteralString
def func1(a: Literal["one"], b: Literal["two"], c: str):
    x1: LiteralString = a
    x2: Literal[""] = b  # E: Incompatible types in assignment (expression has type "Literal['two']", variable has type "Literal['']")
    x3: LiteralString = c

[case literal_string_operations]
# flags: --mode typed
# Copied from conformance tests (literals_literalstring.py)

from typing import LiteralString, assert_type

def func2(a: LiteralString, b: LiteralString):
    # > Addition: x + y is of type LiteralString if both x and y are compatible with LiteralString.
    assert_type(a + b, LiteralString)

    # > Joining: sep.join(xs) is of type LiteralString if sep’s type is
    # > compatible with LiteralString and xs’s type is compatible with Iterable[LiteralString].
    assert_type(",".join((a, b)), LiteralString)
    assert_type(",".join((a, str(b))), str)

    # > In-place addition: If s has type LiteralString and x has type compatible with
    # > LiteralString, then s += x preserves s’s type as LiteralString.
    a += "hello"
    b += a

    # > String formatting: An f-string has type LiteralString if and only if its constituent
    # > expressions are literal strings. s.format(...) has type LiteralString if and only if
    # > s and the arguments have types compatible with LiteralString.
    assert_type(f"{a} {b}", LiteralString)

    variable = 3
    x1: LiteralString = f"{a} {str(variable)}"  # E: Incompatible types in assignment (expression has type "str", variable has type "LiteralString")

    assert_type(a + str(1), str)

    # > LiteralString is compatible with the type str
    x2: str = a

    # > Other literal types, such as literal integers, are not compatible with LiteralString.
    x3: LiteralString = 3  # E: Incompatible types in assignment (expression has type "Literal[3]", variable has type "LiteralString")
    x4: LiteralString = b"test"  # E: Incompatible types in assignment (expression has type "Literal[b'test']", variable has type "LiteralString")

[case literal_string_additions_with_literals]
# flags: --mode typed
from typing import LiteralString, Literal
def f(s: str, ls: LiteralString, l: Literal['x'], i: Literal[1], b: Literal[b'']):
    reveal_type(s + ls)  # N: Revealed type is "str"
    reveal_type(ls + s)  # N: Revealed type is "str"
    reveal_type(l + ls)  # N: Revealed type is "LiteralString"
    reveal_type(ls + l)  # N: Revealed type is "LiteralString"
    reveal_type(ls + ls)  # N: Revealed type is "LiteralString"

    i + ls  # E: Unsupported operand types for + ("Literal[1]" and "LiteralString")
    ls + i  # E: Unsupported operand types for + ("LiteralString" and "Literal[1]")
    b + ls  # E: Unsupported operand types for + ("Literal[b'']" and "LiteralString")
    ls + b  # E: Unsupported operand types for + ("LiteralString" and "Literal[b'']")

[case fstrings_with_only_strings_is_literal_string]
# flags: --mode typed
from typing import LiteralString, Literal
def f(s: str, ls: LiteralString, l: Literal['x'], i: Literal[1], b: Literal[b''], u: Literal['a', 'b']):
    reveal_type(f"s {'x'}")  # N: Revealed type is "LiteralString"
    reveal_type(f"s {1}")  # N: Revealed type is "LiteralString"
    reveal_type(f"s {s}")  # N: Revealed type is "str"
    reveal_type(f"s {str()}")  # N: Revealed type is "str"
    reveal_type(f"s {ls}")  # N: Revealed type is "LiteralString"
    reveal_type(f"s {l}")  # N: Revealed type is "LiteralString"
    reveal_type(f"s {i}")  # N: Revealed type is "LiteralString"
    reveal_type(f"s {b}")  # N: Revealed type is "LiteralString"

    reveal_type(f"s {ls:{s}}")  # N: Revealed type is "str"
    reveal_type(f"s {ls:{ls}}")  # N: Revealed type is "LiteralString"

    reveal_type(f"s {u}")  # N: Revealed type is "LiteralString"

    reveal_type(f"s {ls}" "")  # N: Revealed type is "LiteralString"
    reveal_type("a" f"s {ls}" "b")  # N: Revealed type is "LiteralString"
    reveal_type("a" r"b")  # N: Revealed type is "LiteralString"

[case literal_string_conditions_and_context]
# flags: --mode typed
# Copied from conformance tests (literals_literalstring.py)

from typing import LiteralString
# > Conditional statements and expressions work as expected.
def condition1() -> bool: ...

def return_literal_string() -> LiteralString:
    return "foo" if condition1() else "bar"  # OK

def return_literal_str2(literal_string: LiteralString) -> LiteralString:
    return "foo" if condition1() else literal_string  # OK

def return_literal_str3() -> LiteralString:
    result: LiteralString
    if condition1():
        result = "foo"
    else:
        result = "bar"

    return result  # OK

[case general_literalstring_type_usage]
# flags: --mode typed
# Copied from conformance tests (literals_literalstring.py)

from typing import LiteralString, TypeVar, Literal, assert_type, Generic
# > TypeVars can be bound to LiteralString.
T = TypeVar("T")
TLiteral = TypeVar("TLiteral", bound=LiteralString)

def literal_identity(s: TLiteral) -> TLiteral:
    return s

def func3(s: Literal["hello"]):
    assert_type(literal_identity(s), Literal["hello"])

def func4(s: LiteralString):
    assert_type(literal_identity(s), LiteralString)

def func5(s: str):
    literal_identity(s)  # E: Value of type variable "TLiteral" of "literal_identity" cannot be "str"

# > LiteralString can be used as a type argument for generic classes.
class Container(Generic[T]):
    def __init__(self, value: T) -> None:
        self.value = value

def func6(s: LiteralString):
    x: Container[LiteralString] = Container(s)  # OK

def func7(s: str):
    x_error: Container[LiteralString] = Container(s)  # E: Argument 1 to "Container" has incompatible type "str"; expected "LiteralString"

# > Standard containers like List work as expected.
xs: list[LiteralString] = ["foo", "bar", "baz"]

[case literal_string_in_overloads]
# flags: --mode typed
# Copied from conformance tests (literals_literalstring.py)

from typing import LiteralString, overload, assert_type, Any, Literal, Sequence

class A: pass
class B(A): pass
class C(B): pass

@overload
def func8(x: Literal["foo"]) -> C: ...
@overload
def func8(x: LiteralString) -> B: ...
@overload
def func8(x: str) -> A: ...

def func8(x: Any) -> Any: ...

assert_type(func8("foo"), C)  # First overload
assert_type(func8("bar"), B)  # Second overload
assert_type(func8(str(1)), A)  # Third overload

def func9(val: list[LiteralString]):
    x1: list[str] = val  # E: Incompatible types in assignment (expression has type "list[LiteralString]", variable has type "list[str]") \
                         # N: "List" is invariant -- see https://mypy.readthedocs.io/en/stable/common_issues.html#variance \
                         # N: Consider using "Sequence" instead, which is covariant


def func10(val: Sequence[LiteralString]):
    x1: Sequence[str] = val  # OK

[case literal_string_context_for_containers]
# flags: --mode typed
from typing import LiteralString, Literal

def f(x: LiteralString, y: list[LiteralString]):
    reveal_type([f"asdf {'x'}"])  # N: Revealed type is "list[str]"
    reveal_type([x])  # N: Revealed type is "list[LiteralString]"
    a: list[str] = [x]
    a = y  # E: Incompatible types in assignment (expression has type "list[LiteralString]", variable has type "list[str]") \
           # N: "List" is invariant -- see https://mypy.readthedocs.io/en/stable/common_issues.html#variance \
           # N: Consider using "Sequence" instead, which is covariant

[case literal_string_percent_syntax]
# flags: --mode typed
from typing import LiteralString, Literal

def f(x: Literal[1], y: Literal["c %s %s"], z: LiteralString, s: str, u1: Literal['a%s', 'b%s'], u2: LiteralString | str):
    reveal_type("asdf %s" % x)  # N: Revealed type is "LiteralString"
    reveal_type("asdf %s" % y)  # N: Revealed type is "LiteralString"
    reveal_type("asdf %s" % z)  # N: Revealed type is "LiteralString"
    reveal_type("asdf %s" % s)  # N: Revealed type is "str"
    reveal_type("asdf %s" % (y,))  # N: Revealed type is "LiteralString"
    reveal_type("asdf %s %s" % (y, z))  # N: Revealed type is "LiteralString"
    reveal_type("asdf %s %s" % (z, s))  # N: Revealed type is "str"

    reveal_type(y % (z, z))  # N: Revealed type is "LiteralString"
    reveal_type(y % z)  # N: Revealed type is "LiteralString"
    reveal_type(y % s)  # N: Revealed type is "str"
    reveal_type(z % (z, z))  # N: Revealed type is "LiteralString"
    reveal_type(z % (s, z))  # N: Revealed type is "str"
    reveal_type(z % z)  # N: Revealed type is "LiteralString"
    reveal_type(z % s)  # N: Revealed type is "str"

    reveal_type(z % s)  # N: Revealed type is "str"

    reveal_type(u1 % u1)  # N: Revealed type is "LiteralString"
    reveal_type(u1 % (u1, u1))  # N: Revealed type is "LiteralString"
    reveal_type(u1 % (u1, u2))  # N: Revealed type is "str"
    reveal_type(u1 % u2)  # N: Revealed type is "str"
    reveal_type(u2 % u1)  # N: Revealed type is "str"

[case literal_string_format_function]
# flags: --mode typed

from typing import Literal, LiteralString
def f(l: Literal["a{}"], ls: LiteralString, u: Literal["a{}", "b{}"], s: str):
    reveal_type("a{}".format(""))  # N: Revealed type is "LiteralString"

    reveal_type(l.format(l))  # N: Revealed type is "LiteralString"
    reveal_type(l.format(ls))  # N: Revealed type is "LiteralString"
    reveal_type(ls.format(l))  # N: Revealed type is "LiteralString"
    reveal_type(ls.format(ls))  # N: Revealed type is "LiteralString"

    reveal_type(l.format(s))  # N: Revealed type is "str"
    reveal_type(ls.format(s))  # N: Revealed type is "str"
    reveal_type(s.format(ls))  # N: Revealed type is "str"

    reveal_type(u.format(ls))  # N: Revealed type is "LiteralString"
    reveal_type(u.format(l))  # N: Revealed type is "LiteralString"
    reveal_type(l.format(u))  # N: Revealed type is "LiteralString"
    reveal_type(ls.format(u))  # N: Revealed type is "LiteralString"
    reveal_type(u.format(u))  # N: Revealed type is "LiteralString"

    reveal_type(u.format(s))  # N: Revealed type is "str"
    reveal_type(s.format(u))  # N: Revealed type is "str"

[case literal_string_multiplication]
# flags: --mode typed
from typing import LiteralString

def f(y: LiteralString):
    reveal_type(y * 5)  # N: Revealed type is "LiteralString"
    reveal_type(5 * y)  # N: Revealed type is "LiteralString"
    reveal_type(y * 1000000)  # N: Revealed type is "LiteralString"
    reveal_type(1000000 * y)  # N: Revealed type is "LiteralString"
