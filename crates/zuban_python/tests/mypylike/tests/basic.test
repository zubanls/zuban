[case invalid_base_class_in_param]
# Checked mypy for this.

def x(a: int):
    class Foo(a): pass  # E: Invalid base class "a"

def y(a: type):  
    class Foo(a): pass

def z(a: type[int]) -> None:
    class Foo(a): pass  # E: Invalid base class "a"

[case keyword_only_params_with_kwargs]

def foo(*, x: int, y: int) -> None: ...

dct: dict[str, int]
foo(**dct)

[case positional_only_params_with_kwargs]

def foo(x, /) -> None: ...

dct: dict[str, int]
foo(**dct) # E: Too few arguments for "foo"

[case strict_optional_none_return]
def foo() -> str:
    return None  # E: Incompatible return value type (got "None", expected "str")

[case no_strict_optional_none_return]
# flags: --no-strict-optional
def foo() -> str:
    return None

[case except_nested_tuple]
try:
    1
except (AttributeError, (NotImplementedError, NameError)) as e:  # E: Exception type must be derived from BaseException (or be a tuple of exception classes)
    reveal_type(e)  # N: Revealed type is "AttributeError | NotImplementedError | NameError"

[case tuple_generic_class_type_comment]
from typing import Generic, TypeVar, Any

T = TypeVar("T")

any: Any

class Foo(Generic[T]):
    x, y = any  # type: (T, int)
    u, v = any  # type: T, int

foo: Foo[str]
reveal_type(foo.x)  # N: Revealed type is "str"
reveal_type(foo.y)  # N: Revealed type is "int"
reveal_type(foo.u)  # N: Revealed type is "str"
reveal_type(foo.v)  # N: Revealed type is "int"

[case inplace_operator_on_undefined_target]
undefined += 1  # E: Name "undefined" is not defined
undefined *= 1

[case operator_return_in_failure_case]
a: A
b: B
x = a & a  # E: Unsupported operand types for & ("A" and "A")
reveal_type(x)  # N: Revealed type is "__main__.B"
class A:
    def __and__(self, x: 'B') -> 'B': pass
class B: pass

[case alias_of_classes]
class A: ...
class B: ...
X = A | B
x: X
reveal_type(X)  # N: Revealed type is "types.UnionType"
reveal_type(x)  # N: Revealed type is "__main__.A | __main__.B"

[case yield_without_expr]
from typing import Generator

def yield_receive1() -> Generator[None, str, None]:
    reveal_type((yield))  # N: Revealed type is "str"

def yield_receive2() -> Generator[str | None, str, None]:
    reveal_type((yield))  # N: Revealed type is "str"
    reveal_type((yield ""))  # N: Revealed type is "str"

def yield_receive3() -> Generator[bytes | int, str, None]:
    reveal_type((yield))  # E: Yield value expected \
                          # N: Revealed type is "str"
    reveal_type((yield b""))  # N: Revealed type is "str"

[case yield_without_expr_with_any]
from typing import Generator

def yield_receive4() -> object:
    reveal_type((yield))  # N: Revealed type is "Any"
    reveal_type((yield b""))  # N: Revealed type is "Any"
    return 1

def yield_receive5() -> None:  # E: The return type of a generator function should be "Generator" or one of its supertypes
    reveal_type((yield))  # N: Revealed type is "Any"
    reveal_type((yield b""))  # N: Revealed type is "Any"
    return 1

[case yield_without_expr_with_generator_sub_type]
from typing import Generator

class SubGenerator(Generator[int, str, bytes]): ...

def yield_receive() -> SubGenerator:  # E: The return type of a generator function should be "Generator" or one of its supertypes
    reveal_type((yield))  # N: Revealed type is "Any"
    reveal_type((yield b""))  # N: Revealed type is "Any"
    return 1

[case yield_with_generator]
# flags: --warn-no-return
from typing import Generator

def yield_send() -> Generator[bytes, str, float]:  # E: Missing return statement
    reveal_type((yield b""))  # N: Revealed type is "str"
    if int():
        return 1.0

[case yield_from_with_generator_subtype]
from typing import Generator, Any, Self

a: Any

class SubGenerator1(Generator[int, str, bytes]):
    send = a
    throw = a

class SubGenerator2(Generator[int, str, bytes]):
    send = a
    throw = a
    def __iter__(self) -> Self:
        raise NotImplementedError

def g() -> Generator[int, str, None]:
    x = yield from ()  # E: Function does not return a value (it only ever returns None)
    y = yield from SubGenerator1()
    reveal_type(y)  # N: Revealed type is "bytes"
    z = yield from SubGenerator2()
    # TODO This Any is wrong, but that's also how Mypy does it.
    reveal_type(z)  # N: Revealed type is "Any"

[case invalid_forward_reference]
a: 'int; str'  # E: Syntax error in type annotation
b: 'int str'  # E: Invalid syntax

[case typing_extensions_assert_type]
from typing_extensions import assert_type, Literal

assert_type(1, Literal[1])
assert_type(1, Literal[2])  # E: Expression is of type "Literal[1]", not "Literal[2]"

[case yield_from_in_typed_and_untyped]
# testNoYieldFromInAsyncDef tests this as well, but not with untyped.
from typing import Any

async def f1():
    yield from []  # E: "yield from" in async function
async def g1():
    x = yield from []  # E: "yield from" in async function
async def f2() -> Any:
    yield from []  # E: "yield from" in async function
async def g2() -> Any:
    x = yield from []  # E: "yield from" in async function

[case untyped_star_assignment_should_not_error]
def foo(z):
    *x, y = z

[case __slots___implicit_tuple]
class Foo:
    __slots__ = 'a', 'b'

    def __init__(self) -> None:
        self.a = 3
        self.b = 4
        self.c = 5 # E: Trying to assign name "c" that is not in "__slots__" of type "__main__.Foo"

[case __slots___string_only]
class Foo:
    __slots__ = 'foo'

    def __init__(self) -> None:
        self.foo = 3
        self.bar = 3 # E: Trying to assign name "bar" that is not in "__slots__" of type "__main__.Foo"

[case __slots___star_ignored]
class Foo:
    __slots__ = *'foo', "bar"

    def __init__(self) -> None:
        self.foo = 3
        self.bar = 3
        self.f = 3
        self.other = 3

class Bar:
    __slots__ = (*('foo',),)

    def __init__(self) -> None:
        self.foo = 3
        self.bar = 3
        self.f = 3
        self.other = 3

[case __slots___inherited]
class Foo:
    __slots__ = 'a', 'b'
    a: int

    def __init__(self) -> None:
        self.a = 3
        self.b = 3

Foo().a = 3
Foo().b = 3
if bool():
    Foo.a = 3
else:
    x = Foo.a  # E: "a" in __slots__ conflicts with class variable access
    reveal_type(x) # N: Revealed type is "int"
Foo.b = 3  # E: "type[Foo]" has no attribute "b"

[case type_type_annotation]
# No such test exists in Mypy (only for recursive aliases)
foo: type[type[int]]  # E: type[...] can't contain "type[...]"

[case type_type_alias_circular]
A = type["B"]  # E: type[...] can't contain "type[...]"
B = list[type[A]]

[case assign_bool_to_false_true_literal]
from typing import Literal
blo: bool
bla: Literal[False, True] = blo

if int():
    blo = bla

[case walrus_context]
foo: list[int]
(foo := reveal_type([]))  # N: Revealed type is "list[int]"
reveal_type(foo)  # N: Revealed type is "list[int]"

[case none_getitem]
None[1]  # E: Value of type "None" is not indexable

[case dict_implicit_literals_no_context]
a = {1: 2 for x in [1]}
reveal_type(a)  # N: Revealed type is "dict[int, int]"

[case dict_implicit_literals_with_context]
a: dict[int, int] = {1: 2 for x in [1]}

[case weird_del_usages]
a = 3
del [], ()
a
del [], (a)
a # E: Trying to read deleted variable "a"
a = 3
del [], (a,)
a # E: Trying to read deleted variable "a"

a = 3
del [a], (a,)  # E: Trying to read deleted variable "a"
a # E: Trying to read deleted variable "a"

[case del_name_as_a_source]
del a  # E: Name "a" is not defined
a + 1  # E: Trying to read deleted variable "a"

[case operator_any_add_result]
# Tests parts of testBinaryOperationsWithDynamicAsRightOperand for both sides
from typing import Any

def foo(x: int, y: Any):
    reveal_type(x + y)  # N: Revealed type is "Any"
    reveal_type(y + x)  # N: Revealed type is "Any"

class A:
    def __radd__(self, a: int) -> str: ...

def bar(x: Any, y: A):
    reveal_type(x + y)  # N: Revealed type is "Any"
    reveal_type(y + x)  # N: Revealed type is "Any"

[case explicit_never_list_tuple_unpacking_mypy_compatible]
# flags: --mypy-compatible
from typing import Never
xx: list[Never] = []

for (y, z) in xx:  # E: "Never" object is not iterable
    reveal_type(y)

1()  # E: "int" not callable

[case explicit_never_list_tuple_unpacking_no_mypy_compatible]
# flags: --no-mypy-compatible
from typing import Never
xx: list[Never] = []

for (y, z) in xx:  # E: "Never" object is not iterable
    reveal_type(y)  # TODO this might be unreachable, but doesn't need to be.

1()  # E: "int" not callable

[case set_literal_item_mismatch]
from typing import Set
x: Set[int] = {1, ""}  # E: Set item 1 has incompatible type "str"; expected "int"

[case string_backslash_newline_escape]
from typing import Final, Literal
x: Final = "\
"
def check_empty(literal: Literal[""]): ...
check_empty(x)

[case string_backslash_special_characters_escape]
from typing import Final, Literal
a: Final = "\a"
def check_bell(literal: Literal["\x07"]): ...
check_bell(a)

b: Final = "\b"
def check_backspace(literal: Literal["\x08"]): ...
check_backspace(b)
check_bell(b)  # E: Argument 1 to "check_bell" has incompatible type "Literal['\x08']"; expected "Literal['\x07']"
check_backspace(a) # E: Argument 1 to "check_backspace" has incompatible type "Literal['\x07']"; expected "Literal['\x08']"

f: Final = "\f"
def check_form_feed(literal: Literal["\x0c"]): ...
check_form_feed(f)
check_bell(f)  # E: Argument 1 to "check_bell" has incompatible type "Literal['\x0c']"; expected "Literal['\x07']"

r: Final = "\r"
def check_carriage_return(literal: Literal["\x0d"]): ...
check_carriage_return(r)
check_bell(r)  # E: Argument 1 to "check_bell" has incompatible type "Literal['\r']"; expected "Literal['\x07']"

t: Final = "\t"
def check_tab(literal: Literal["\x09"]): ...
check_tab(t)
check_bell(t)  # E: Argument 1 to "check_bell" has incompatible type "Literal['\t']"; expected "Literal['\x07']"

v: Final = "\v"
def check_vertical_tab(literal: Literal["\x0b"]): ...
check_vertical_tab(v)
check_bell(v)  # E: Argument 1 to "check_bell" has incompatible type "Literal['\x0b']"; expected "Literal['\x07']"

[case string_backslash_octal_escape]
from typing import Literal

def check_octal0(literal: Literal["\x00"]): ...
def check_octal1(literal: Literal["\x01"]): ...
def check_octal7(literal: Literal["\x07"]): ...
def check_octal8(literal: Literal["\x08"]): ...
def check_octalI(literal: Literal["iIi"]): ...
def check_octalI1(literal: Literal["iI1"]): ...
def check_octal18(literal: Literal["\x018"]): ...

check_octal0("\0")
check_octal1("\1")
check_octal7("\7")
check_octal8("\8")  # E: Argument 1 to "check_octal8" has incompatible type "Literal['\\8']"; expected "Literal['\x08']"
check_octalI("i\111i")
check_octalI1("i\1111")
check_octal18("\18")
check_octal18("\018")
check_octal18("\0018")
check_octal18("\00018")  # E: Argument 1 to "check_octal18" has incompatible type "Literal['\x0018']"; expected "Literal['\x018']"

[case string_invalid_escapes]
from typing import Literal
def check(literal: Literal["a"]): ...
def ok(literal: Literal["\\l"]): ...

ok("\l")
check("\l")  # E: Argument 1 to "check" has incompatible type "Literal['\\l']"; expected "Literal['a']"
check("\i")  # E: Argument 1 to "check" has incompatible type "Literal['\\i']"; expected "Literal['a']"
check("\z")  # E: Argument 1 to "check" has incompatible type "Literal['\\z']"; expected "Literal['a']"
check("\ä ")  # E: Argument 1 to "check" has incompatible type "Literal['\\ä ']"; expected "Literal['a']"

[case string_literal_multiline]
from typing import Literal

def foo(y: Literal["abc"]): ...
def bar(y: Literal["ab\nc"]): ...
def baz(y: Literal["""ab
c"""]): ...

# Errors
foo(r'''ab\
c''')
foo(r'''abc
''')
foo("""ab""" '''c''')

foo("""abc""")
foo("""ab\
c""")

foo(u"""abc""")
foo(r"""abc""")
foo(R"""abc""")
foo(U"""abc""")

bar("""ab
c""")
bar('''ab
c''')
bar("""ab\n\
c""")

baz("""ab
c""")
baz(r'''ab
c''')
baz("""ab\nc""")

[out]
__main__:9: error: Argument 1 to "foo" has incompatible type "Literal['ab\\\nc']"; expected "Literal['abc']"
__main__:11: error: Argument 1 to "foo" has incompatible type "Literal['abc\n']"; expected "Literal['abc']"
__main__:13: error: Argument 1 to "foo" has incompatible type "LiteralString"; expected "Literal['abc']"

[case fstring_unions]
abc = int

def ok(literal: "a" "bc"): ...
ok(1)
ok("")  # E: Argument 1 to "ok" has incompatible type "str"; expected "int"

def not_ok1(literal: f"a" "bc"): ...  # E: Invalid type comment or annotation
def not_ok2(literal: "a" f"bc"): ...  # E: Invalid type comment or annotation
def not_ok3(literal: f"a" f"bc"): ...  # E: Invalid type comment or annotation

def not_ok4(literal: "\x01" f"bc"): ...  # E: Invalid type comment or annotation
def not_ok5(literal: f"a" "\x01"): ...  # E: Invalid type comment or annotation

[case invalid_hex]
# Theoretically these should raise SyntaxErrors, but for now they don't and that's fine.
from typing import Literal
x: Literal["\xz"]

y: Literal["\UFFFFFFFF"]

[case check_bytes_merging]
from typing import Literal

def foo(y: Literal[b"abc"]): ...
foo(b'a' b'bc')  # E: Argument 1 to "foo" has incompatible type "bytes"; expected "Literal[b'abc']"
foo(b'abc')
foo(b'a' f'bc')  # E: Invalid syntax
foo('a' b'bc')  # E: Invalid syntax

def simple(y: bytes): ...
simple(b'a' b'bc')

def not_supported(y: Literal[b"abc" b"d"]): ...  # E: Literals with chained bytes are not supported

[case check_bytes_raw]
from typing import Literal

def foo(y: Literal[rb"a\nb"]): ...
foo(b'a\nb')  # E: Argument 1 to "foo" has incompatible type "Literal[b'a\nb']"; expected "Literal[b'a\\nb']"
foo(br'a\nb')
foo(RB"""a\nb""")
foo(br'''''')  # E: Argument 1 to "foo" has incompatible type "Literal[b'']"; expected "Literal[b'a\\nb']"

[case bytes_backslash_special_characters_escape]
from typing import Final, Literal
a: Final = b"\a"
def check_bell(literal: Literal[b"\x07"]): ...
check_bell(a)

b: Final = b"\b"
def check_backspace(literal: Literal[b"\x08"]): ...
check_backspace(b)
check_bell(b)  # E: Argument 1 to "check_bell" has incompatible type "Literal[b'\x08']"; expected "Literal[b'\x07']"
check_backspace(a) # E: Argument 1 to "check_backspace" has incompatible type "Literal[b'\x07']"; expected "Literal[b'\x08']"

f: Final = b"\f"
def check_form_feed(literal: Literal[b"\x0c"]): ...
check_form_feed(f)
check_bell(f)  # E: Argument 1 to "check_bell" has incompatible type "Literal[b'\x0c']"; expected "Literal[b'\x07']"

r: Final = b"\r"
def check_carriage_return(literal: Literal[b"\x0d"]): ...
check_carriage_return(r)
check_bell(r)  # E: Argument 1 to "check_bell" has incompatible type "Literal[b'\r']"; expected "Literal[b'\x07']"
check_bell(b"\n")  # E: Argument 1 to "check_bell" has incompatible type "Literal[b'\n']"; expected "Literal[b'\x07']"

t: Final = b"\t"
def check_tab(literal: Literal[b"\x09"]): ...
check_tab(t)
check_bell(t)  # E: Argument 1 to "check_bell" has incompatible type "Literal[b'\t']"; expected "Literal[b'\x07']"

v: Final = b"\v"
def check_vertical_tab(literal: Literal[b"\x0b"]): ...
check_vertical_tab(v)
check_bell(v)  # E: Argument 1 to "check_bell" has incompatible type "Literal[b'\x0b']"; expected "Literal[b'\x07']"

[case bytes_invalid_escapes]
from typing import Literal
def check(literal: Literal[b"a"]): ...
def ok(literal: Literal[b"\\l"]): ...

ok(b"\l")
check(b"\l")  # E: Argument 1 to "check" has incompatible type "Literal[b'\\l']"; expected "Literal[b'a']"
check(b"\i")  # E: Argument 1 to "check" has incompatible type "Literal[b'\\i']"; expected "Literal[b'a']"
check(b"\z")  # E: Argument 1 to "check" has incompatible type "Literal[b'\\z']"; expected "Literal[b'a']"
check(b"\ä ")  # E: Argument 1 to "check" has incompatible type "Literal[b'\\\xc3\xa4 ']"; expected "Literal[b'a']"

[case bare_self_aug_assignment]
# flags: --disallow-untyped-globals
class Foo:
    def f(self) -> None:
        self.foo += 1  # E: "Self" has no attribute "foo"
        self.bla[1] += 1  # E: "Self" has no attribute "bla"
        self.lst = []  # E: Need type annotation for "lst" (hint: "lst: List[<type>] = ...")

        reveal_type(self.foo)  # N: Revealed type is "Any"
        reveal_type(self.bla)  # E: "Self" has no attribute "bla" # N: Revealed type is "Any"

        self.lst[0] += 1


reveal_type(Foo().foo)  # N: Revealed type is "Any"
reveal_type(Foo().bla)  # E: "Foo" has no attribute "bla" # N: Revealed type is "Any"

Foo().undefined += 1  # E: "Foo" has no attribute "undefined"  # E: "Foo" has no attribute "undefined"

[case aug_assign_tuple_syntax_issue]
class Foo:
    def f(self) -> None:
        self.a = 3
        (self.bar, self.baz) += 1  # E: Invalid syntax
        self.b = 3

reveal_type(Foo().a)  # N: Revealed type is "int"
reveal_type(Foo().b)  # N: Revealed type is "int"

[case aug_assign_tuple_syntax_issue2]
a = 1
(a) += 1

[case accessing__file__]
__file__.endswith("")

[case current_module_attrs]
reveal_type(__name__)  # N: Revealed type is "str"
reveal_type(__file__)  # N: Revealed type is "str"
reveal_type(__package__)  # N: Revealed type is "str"
reveal_type(__spec__)  # N: Revealed type is "_frozen_importlib.ModuleSpec | None"

# Attributes defined in ModuleType but not actually available in the current module.
__dict__  # E: Name "__dict__" is not defined
__loader__  # E: Name "__loader__" is not defined
__path__  # E: Name "__path__" is not defined
__init__  # E: Name "__init__" is not defined
__getattr__  # E: Name "__getattr__" is not defined

# From object
reveal_type(__doc__)  # N: Revealed type is "str | None"
reveal_type(__annotations__)  # N: Revealed type is "dict[str, Any]"
__module__  # E: Name "__module__" is not defined
__hash__  # E: Name "__hash__" is not defined
__eq__  # E: Name "__eq__" is not defined
# From metaclass
mro  # E: Name "mro" is not defined
__base__  # E: Name "__base__" is not defined

def foo() -> None:
    reveal_type(__name__)  # N: Revealed type is "str"
    reveal_type(__file__)  # N: Revealed type is "str"
    reveal_type(__package__)  # N: Revealed type is "str"
    reveal_type(__spec__)  # N: Revealed type is "_frozen_importlib.ModuleSpec | None"

    __dict__  # E: Name "__dict__" is not defined
    __loader__  # E: Name "__loader__" is not defined
    __path__  # E: Name "__path__" is not defined
    __init__  # E: Name "__init__" is not defined
    __getattr__  # E: Name "__getattr__" is not defined

    reveal_type(__doc__)  # N: Revealed type is "str | None"
    reveal_type(__annotations__)  # N: Revealed type is "dict[str, Any]"
    __module__  # E: Name "__module__" is not defined
    __hash__  # E: Name "__hash__" is not defined
    __eq__  # E: Name "__eq__" is not defined
    mro  # E: Name "mro" is not defined

class Foo:
    reveal_type(__name__)  # N: Revealed type is "str"
    reveal_type(__file__)  # N: Revealed type is "str"
    reveal_type(__package__)  # N: Revealed type is "str"
    reveal_type(__spec__)  # N: Revealed type is "_frozen_importlib.ModuleSpec | None"

    __dict__  # E: Name "__dict__" is not defined
    __loader__  # E: Name "__loader__" is not defined
    __path__  # E: Name "__path__" is not defined
    __init__  # E: Name "__init__" is not defined
    __getattr__  # E: Name "__getattr__" is not defined

    reveal_type(__doc__)  # N: Revealed type is "str | None"
    reveal_type(__annotations__)  # N: Revealed type is "dict[str, Any]"
    reveal_type(__module__)  # N: Revealed type is "str"
    __hash__  # E: Name "__hash__" is not defined
    __eq__  # E: Name "__eq__" is not defined
    mro  # E: Name "mro" is not defined

[case __doc__not_none_with_docstr]
import m
reveal_type(m.__doc__)  # N: Revealed type is "str | None"

[file m.py]
"""
Hello
"""
reveal_type(__doc__)  # N: Revealed type is "str"

[case __doc__nullable_without_docstr]
import m
reveal_type(m.__doc__)  # N: Revealed type is "str | None"

[file m.py]
reveal_type(__doc__)  # N: Revealed type is "str | None"

[case had_fstring_syntax_error]
a = 'x'
f"{a * 3:1}"
f"{a + ':':24}"
f'{a + ":":24}'
f"{a / 3:9}"  # E: Unsupported operand types for / ("str" and "int")
f"""{'' + ":":24}"""

[case special_builtins_access]
reveal_type(isinstance)  # N: Revealed type is "def (object, type[Any] | types.UnionType | tuple[..., ...]) -> bool"
reveal_type(issubclass)  # N: Revealed type is "def (type[Any], type[Any] | types.UnionType | tuple[..., ...]) -> bool"
reveal_type(super)  # N: Revealed type is "super"

[case special_typing_access]
# Some types are handled in a special way, check however that normal
# reveal_type does not crash.
import typing
reveal_type(typing.TypeVar)  # N: Revealed type is "type[typing.TypeVar]"
reveal_type(typing.TypeVarTuple)  # N: Revealed type is "type[typing.TypeVarTuple]"
reveal_type(typing.ParamSpec)  # N: Revealed type is "type[typing.ParamSpec]"
reveal_type(typing.cast)  # N: Revealed type is "object"
reveal_type(typing.ClassVar)  # N: Revealed type is "typing._SpecialForm"
reveal_type(typing.reveal_type)  # N: Revealed type is "def [_T] (_T) -> _T"
reveal_type(typing.NewType)  # N: Revealed type is "type[typing.NewType]"
reveal_type(typing.TypeGuard)  # N: Revealed type is "typing._SpecialForm"
reveal_type(typing.TypeIs)  # N: Revealed type is "typing._SpecialForm"
reveal_type(typing.Concatenate)  # N: Revealed type is "typing._SpecialForm"
reveal_type(typing.assert_type)  # N: Revealed type is "object"
reveal_type(typing.Required)  # N: Revealed type is "typing._SpecialForm"
reveal_type(typing.NotRequired)  # N: Revealed type is "typing._SpecialForm"
reveal_type(typing.ReadOnly)  # N: Revealed type is "typing._SpecialForm"
reveal_type(typing.LiteralString)  # N: Revealed type is "typing._SpecialForm"
reveal_type(typing.Unpack)  # N: Revealed type is "typing._SpecialForm"
reveal_type(typing.Never)  # N: Revealed type is "typing._SpecialForm"
reveal_type(typing.Self)  # N: Revealed type is "typing._SpecialForm"
reveal_type(typing.Union)  # N: Revealed type is "typing._SpecialForm"
reveal_type(typing.Generic)  # N: Revealed type is "typing._SpecialForm"
reveal_type(typing.Protocol)  # N: Revealed type is "typing._SpecialForm"
reveal_type(typing.Callable)  # N: Revealed type is "typing._SpecialForm"
reveal_type(typing.NoReturn)  # N: Revealed type is "typing._SpecialForm"
reveal_type(typing.ClassVar)  # N: Revealed type is "typing._SpecialForm"
reveal_type(typing.Tuple)  # N: Revealed type is "def (typing.Iterable[Any] =) -> tuple[Any, ...]"
reveal_type(typing.TypeAlias)  # N: Revealed type is "typing._SpecialForm"
reveal_type(typing.Final)  # N: Revealed type is "typing._SpecialForm"
reveal_type(typing.Literal)  # N: Revealed type is "typing._SpecialForm"
reveal_type(typing.Annotated)  # N: Revealed type is "typing._SpecialForm"
reveal_type(typing.dataclass_transform)  # N: Revealed type is "function"
reveal_type(typing.TypedDict)  # N: Revealed type is "typing._SpecialForm"
reveal_type(typing.NamedTuple)  # N: Revealed type is "typing._SpecialForm"
reveal_type(typing.final)  # N: Revealed type is "def [_T] (f: _T) -> _T"

[case other_special_types_access]
import collections
import dataclasses
import mypy_extensions

reveal_type(collections.namedtuple)  # N: Revealed type is "def (typename: str, field_names: str | typing.Iterable[str], *, rename: bool =, module: str | None =, defaults: typing.Iterable[Any] | None =) -> type[tuple[Any, ...]]"
reveal_type(dataclasses.dataclass)  # N: Revealed type is "Overload(def [_T] (type[_T], *, init: bool =, repr: bool =, eq: bool =, order: bool =, unsafe_hash: bool =, frozen: bool =, match_args: bool =, kw_only: bool =, slots: bool =, weakref_slot: bool =) -> type[_T], def (None =, *, init: bool =, repr: bool =, eq: bool =, order: bool =, unsafe_hash: bool =, frozen: bool =, match_args: bool =, kw_only: bool =, slots: bool =, weakref_slot: bool =) -> def [_T] (type[_T]) -> type[_T])"
reveal_type(mypy_extensions.FlexibleAlias)  # N: Revealed type is "Any"
reveal_type(mypy_extensions.Arg)  # N: Revealed type is "Overload(def [_T] (type: _T, name: str | None =) -> _T, def (*, name: str | None =) -> Any)"
reveal_type(mypy_extensions.DefaultArg)  # N: Revealed type is "Overload(def [_T] (type: _T, name: str | None =) -> _T, def (*, name: str | None =) -> Any)"
reveal_type(mypy_extensions.NamedArg)  # N: Revealed type is "Overload(def [_T] (type: _T, name: str | None =) -> _T, def (*, name: str | None =) -> Any)"
reveal_type(mypy_extensions.DefaultNamedArg)  # N: Revealed type is "Overload(def [_T] (type: _T, name: str | None =) -> _T, def (*, name: str | None =) -> Any)"
reveal_type(mypy_extensions.VarArg)  # N: Revealed type is "Overload(def [_T] (type: _T) -> _T, def () -> Any)"
reveal_type(mypy_extensions.KwArg)  # N: Revealed type is "Overload(def [_T] (type: _T) -> _T, def () -> Any)"

[case type_var_likes_access]
import typing
T = typing.TypeVar("T")
Ts = typing.TypeVarTuple("Ts")
P = typing.ParamSpec("P")

reveal_type(T.__name__) # N: Revealed type is "str"
reveal_type(Ts.__name__) # N: Revealed type is "str"
reveal_type(P.__name__) # N: Revealed type is "str"

[case flexible_alias_basics]
from mypy_extensions import FlexibleAlias

X = FlexibleAlias[int]  # E: FlexibleAlias must have exactly two type arguments
Y = FlexibleAlias[int, str, bytes]  # E: FlexibleAlias must have exactly two type arguments
Z = FlexibleAlias[int, str]

reveal_type(FlexibleAlias.undefined)  # N: Revealed type is "Any"
x: X
reveal_type(x)  # N: Revealed type is "Any"
y: Y
reveal_type(y)  # N: Revealed type is "str"
z: Y
reveal_type(z)  # N: Revealed type is "str"

[case type_differences]
# flags: --strict
from typing import Type, Any
x: Type  # E: Missing type parameters for generic type "Type"
y: type

class Foo(Type): ...  # E: Invalid base class "Type"
class Bar(type): ...

a: Any = ...
if isinstance(a, type):
    reveal_type(a) # N: Revealed type is "type[Any]"
if issubclass(a, type):
    reveal_type(a) # N: Revealed type is "type[type]"

isinstance(x, Type)  # E: Argument 2 to "isinstance" has incompatible type "_SpecialForm"; expected "type[Any] | UnionType | tuple[_ClassInfo, ...]"
issubclass(x, Type)  # E: Argument 2 to "issubclass" has incompatible type "_SpecialForm"; expected "type[Any] | UnionType | tuple[_ClassInfo, ...]"

type.mro
Type.mro  # E: "_SpecialForm" has no attribute "mro"

[case dict_getitem_context]
def foo(y: dict[int, set[int]]) -> None:
    y[1] = set()

[case assign_self_to_variable]
# flags: --disallow-redefinition
from typing import Self

class X:
    def __init__(self) -> None:
        y = self
        y = X()

        z: Self = self
        a = z
        reveal_type(a)  # N: Revealed type is "Self"

    def foo(self: Self) -> None:
        y = self
        y = X()  # E: Incompatible types in assignment (expression has type "X", variable has type "Self")

[case bool_matching_false_and_true_literals]
# flags: --disallow-redefinition
from typing import Literal
def foo(x: bool, y: Literal[False, True], z: Literal[False, True, ""]) -> None:
    if bool():
        x = y
    if bool():
        y = x
    if bool():
        z = x
    x = z  # E: Incompatible types in assignment (expression has type "Literal[False, True, '']", variable has type "bool")

def bar(x: list[bool], y: list[Literal[False, True]], z: list[Literal[False, True, ""]]) -> None:
    if bool():
        x = y
    if bool():
        y = x

    if bool():
        z = x  # E: Incompatible types in assignment (expression has type "list[bool]", variable has type "list[Literal[False, True, '']]") \
               # N: "List" is invariant -- see https://mypy.readthedocs.io/en/stable/common_issues.html#variance \
               # N: Consider using "Sequence" instead, which is covariant
    x = z  # E: Incompatible types in assignment (expression has type "list[Literal[False, True, '']]", variable has type "list[bool]")

[case dict_comprehension_context]

class A: ...
class B(A): ...

x: dict[A, A] = {B(): B() for _ in [1]}

[case for_loop_avoids_implicit_literals]
for x in ('a', 'b'):
    reveal_type(x)  # N: Revealed type is "str"

[case del_stmt_inference]
from foo import x
[file foo.py]
del x  # E: Name "x" is not defined

[case del_stmt_inference_with_star_import]
from bar import Alias

reveal_type(Alias)  # N: Revealed type is "Any"

[file bar.py]
from foo import *
_Alias = Alias
del Alias

x: _Alias
reveal_type(x)  # N: Revealed type is "int"

[file foo.py]
Alias = int

[case del_stmt_inference_of_self_name]
class C:
    def foo(self) -> None:
        here = 1
        del self.cache1  # E: Cannot determine type of "cache1"
        del (self.cache2, foo, here)  # E: Cannot determine type of "cache2" \
                                      # E: Name "foo" is not defined

    def bar(self) -> None:
        self.cache1 = 1
        self.cache2 = 1  # E: Cannot determine type of "cache2"

reveal_type(C().cache1)  # E: Cannot resolve name "C().cache1" (possible cyclic definition) # N: Revealed type is "Any"

[case star_union]
def f(x: list[bytes] | list[str]):
    y = 1, *x
    reveal_type(y)  # N: Revealed type is "tuple[int | bytes | str, ...]"

[case invalid_star_star_context]
x: dict[int, str] = {**{}}
y: dict[int, bytes] = {**x}  # E: Unpacked dict entry 0 has incompatible type "dict[int, str]"; expected "SupportsKeysAndGetItem[int, bytes]"

e1: dict[int, str] = {**1}  # E: Unpacked dict entry 0 has incompatible type "int"; expected "SupportsKeysAndGetItem[int, str]"

a: dict[str, int] = dict(**{})
b: dict[str, int] = dict(**x)  # E: Keywords must be strings
e2: dict[str, int] = dict(**1)  # E: Argument after ** must be a mapping, not "int"

e3 = {**1}  # E: Unpacked dict entry 0 has incompatible type "int"; expected "SupportsKeysAndGetItem[Never, Never]"
e4 = {"": 1, **1}  # E: Unpacked dict entry 1 has incompatible type "int"; expected "SupportsKeysAndGetItem[str, int]"
reveal_type(e3)  # N: Revealed type is "dict[Any, Any]"
reveal_type(e4)  # N: Revealed type is "dict[str, int]"

[case fstring_tuple]
f"{1,2}"

[case reveal_type_bad_params]
reveal_type()  # E: Too few arguments for "reveal_type"
reveal_type(1, 1)  # E: Too many arguments for "reveal_type"
reveal_type(a=1)  # E: "reveal_type" only accepts one positional argument

[case basic_access_of_special_types]
from typing import cast
from collections import namedtuple
from mypy_extensions import DefaultArg
x: str = namedtuple  # E: Incompatible types in assignment (expression has type "Callable[[str, str | Iterable[str], DefaultNamedArg(bool, 'rename'), DefaultNamedArg(str | None, 'module'), DefaultNamedArg(Iterable[Any] | None, 'defaults')], type[tuple[Any, ...]]]", variable has type "str")
y: str = cast  # E: Incompatible types in assignment (expression has type "object", variable has type "str")
z: str = DefaultArg  # E: Incompatible types in assignment (expression has type "overloaded function", variable has type "str")

[case never_operation]
from typing import Never

def foo(x: Never) -> None:
    +x
    -x
    x+x

[case fstring_forward_reference_invalid]
class C(list[f'{"int"}']): ...  # E: Type expected within [...]

[case global_after_name_def]
x = 1
def foo() -> None:
    x = ""
    global x  # E: SyntaxError: name 'x' is assigned to before global declaration
    x = ""

[case py_not_checked_if_pyi_exists]
import foo

reveal_type(foo.foo)  # N: Revealed type is "def (x: str, y: int)"

[file foo.py]
def foo(x, y: bytes):
    reveal_type(y.foo)

1()

[file foo.pyi]
def foo(x: str, y: int) -> None: ...

[case __debug__usage]
if __debug__: ...

[case dec_number_multiple_zeros]
from typing import Final
x: Final = 00
y: Final = 000000
z: Final = 0_0
reveal_type(x)  # N: Revealed type is "Literal[0]?"
reveal_type(y)  # N: Revealed type is "Literal[0]?"
reveal_type(z)  # N: Revealed type is "Literal[0]?"

[case invalidation_of_subfiles1]
import m

[file m.py]
import n
# These forward reference create a subfile that should still work
def f(foo: list["bytes"], bar: list["n.X"]):
    reveal_type(foo)
    reveal_type(bar)

[file n.py]
X = int
[file n.py.2]
X = str
[out]
m.py:4: note: Revealed type is "list[bytes]"
m.py:5: note: Revealed type is "list[int]"
[out2]
m.py:4: note: Revealed type is "list[bytes]"
m.py:5: note: Revealed type is "list[str]"

[case invalidation_of_subfiles2]
import m

[file m.py]
def f(foo: list["int"]):
    reveal_type(foo)  # N: Revealed type is "list[int]"

[file m.py.2]
def f(foo: list["str"]):
    reveal_type(foo)  # N: Revealed type is "list[str]"

[case special_subscription_assignments]
from typing import TypeVarTuple, Generic

class C:
    def __setitem__(self, index, value: int): ...
x  = C()

x[:1:] = 1
x[::] = 1
x[*(1, 2)] = 1

[case walrus_definition_reused_mypy_compatible]
# flags: --mypy-compatible
def foo(x: int) -> None:
    w = w if (w := x) else None # E: Incompatible types in assignment (expression has type "int | None", variable has type "int")
    reveal_type(w)  # N: Revealed type is "int"

[case walrus_definition_reused_no_mypy_compatible]
# flags: --no-mypy-compatible
def foo(x: int) -> None:
    w = w if (w := x) else None
    reveal_type(w)  # N: Revealed type is "int | None"

[case walrus_definition_used_in_assignment]
if (avar := avar()):  # E: Name "avar" is used before definition
    reveal_type(avar)  # N: Revealed type is "Any"

bvar: int
if (bvar := bvar):
    reveal_type(bvar)  # N: Revealed type is "int"

x: int = (cvar := cvar())  # E: Name "cvar" is used before definition
reveal_type(cvar)  # N: Revealed type is "Any"

[case walrus_redefinition]
lst = [1]
list(x for s in lst if (x := s))
list(x for s in lst if (x := s))

[case after_invalid_syntax_function_should_still_be_importable]
# flags: --no-warn-unreachable
import m, n
reveal_type(m.x)  # N: Revealed type is "int"
reveal_type(n.x)  # N: Revealed type is "int"

[file m.py]
e =   # E: Invalid syntax
x = 1

[file n.py]
def err()(value: str) -> str  # E: Invalid syntax
    return value  # E: "return" outside function  # E: Invalid syntax
x = 1

[case avoid_bracket_slowdown]
(
    ((((( ((((( ((((( (((((
    ((((( ((((( ((((( (((((
    ((((( ((((( ((((( (((((
    ((((( ((((( ((((( (((((
    ((((( ((((( ((((( (((((
    1
    ))))) ))))) ))))) )))))
    ))))) ))))) ))))) )))))
    ))))) ))))) ))))) )))))
    ))))) ))))) ))))) )))))
    ))))) ))))) ))))) )))))
)

[case unicode_escaped_literal_should_not_crash]
def f(char: str) -> None:
    if char <= "\u009d": ...
    if char <= "\u009f": ...
    if char <= "\u019f": ...

[case nested_class_in_untyped_def_with_forward_reference_no_check_untyped]
# flags: --no-check-untyped-defs
def f(x):
    class Outer:
        def meth(self, x: Nested): ...
        x: Nested  # N: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs
        class Nested: ...

[case nested_class_in_untyped_def_and_unreachable_no_crash]
import sys
def f(x):
    if sys.platform.startswith('undefined_operating_system'):
        class Outer:
            def meth(self, x: Nested): ...
            x: Nested
            class Nested: ...

[case global_in_different_module]
from m import t

reveal_type(t) # N: Revealed type is "Any"

[file m.py]
global t  # E: Global at module level is unnecessary
t = 1

[case ellipsis_in_older_python]
# flags: --python-version 3.8
# Ellipsis is special in typeshed and was only introduced correctly as a type in 3.10

x = undefined  # E: Name "undefined" is not defined
reveal_type(x)  # N: Revealed type is "Any"
if x == ...:
    reveal_type(x)  # N: Revealed type is "ellipsis"

[case ellipsis_in_newer_python]
# flags: --python-version 3.13

x = undefined  # E: Name "undefined" is not defined
reveal_type(x)  # N: Revealed type is "Any"
if x == ...:
    reveal_type(x)  # N: Revealed type is "types.EllipsisType"

[case star_expr_in_older_python]
# flags: --python-version 3.8

def foo() -> None: ...

try:
    foo()
except *Exception as x:  # E: Missing the typing symbols for star exceptions \
                         # N: Your --python-version is probably too low.
    reveal_type(x)  # N: Revealed type is "Any"

[case star_expr_in_newer_python]
# flags: --python-version 3.13

def foo() -> None: ...

try:
    foo()
except *Exception as x:
    reveal_type(x)  # N: Revealed type is "ExceptionGroup[Exception]"

[case special_types_access_in_older_python]
# flags: --python-version 3.8
import typing
reveal_type(reveal_type)  # N: Revealed type is "def [_T] (_T) -> _T"
reveal_type(typing.NewType)  # N: Revealed type is "type[typing_extensions.NewType]"

[case set_item_error_code]
# flags: --show-error-codes
x: set[str] = {1}  # E: Set item 0 has incompatible type "int"; expected "str"  [arg-type]

[case list_slice_access]
def f(x: list[int]):
    reveal_type(x[:1]) # N: Revealed type is "list[int]"

[case unicode_column_positions]
# flags: --show-column-numbers --show-error-end
'ä'; ä
[out]
__main__:2:6:2:7: error: Name "ä" is not defined

[case name_binder_error_stays_after_dependency_changes]
from m import C
return
[file m.py]
class C: ...
[file m.py.2]
def C(): ...
[""]
[out]
__main__:2: error: "return" outside function
[out2]
__main__:2: error: "return" outside function

[case string_indexing_should_not_be_any]
# flags: --strict --disallow-any-unimported --python-version 3.8
def short_type(obj: object) -> str:
    t = str(type(obj))
    return t.split(".")[-1].rstrip("'>")

[case broken_if_and_variables_after_should_still_resolve]
def f() -> None:
    x = 1
    if asd fds:  # E: Invalid syntax
        reveal_type(x)  # E: Invalid syntax # N: Revealed type is "int"
    reveal_type(x)  # N: Revealed type is "int"

[case broken_scope1]
a = 1
 b = 1  # E: Invalid syntax
c = 1

[case broken_scope2]
a = 1
if bool()  # E: Invalid syntax
    b = 1  # E: Invalid syntax
c = 1

[case diagnostics_after_trailing_semicolon_regression]
a = 1;

1()  # E: "int" not callable

[case assert_type_list_int]
from typing import assert_type
def x(l: list[int]):
    assert_type(l, list[int])
    assert_type(l, list[str])  # E: Expression is of type "list[int]", not "list[str]"

[case none_can_access_class]
from typing import assert_type
def func2(val1: type[None]):
    assert_type(val1, type[None])

func2(None.__class__)  # OK

[case type_alias_type_var_execution]
from typing import TypeVar, TypeAlias, Type
T = TypeVar("T")
TA7: TypeAlias = type[T]
TA8: TypeAlias = Type[T]

def func11(t1: TA7[T]) -> T:
    return t1()

def func12(t1: TA8[T]) -> T:
    return t1()

def func13(t1: type[T]) -> T:
    return t1()

[case assert_type_equals_implicit_literals]
from typing import assert_type
def func3[*Ts, T](*args: * tuple[int, *Ts, T]) -> tuple[T, *Ts]: ...

assert_type(func3(1, "", 3j, 3.4), tuple[float, str, complex])

[case assert_type_for_enum_literals]
from typing import Literal, assert_type
from enum import Enum

class Color1(Enum):
    RED = 1
    GREEN = 2

assert_type(Color1.RED, Literal[Color1.RED])
assert_type(Color1.RED, Literal[Color1.GREEN])  # E: Expression is of type "Literal[Color1.RED]", not "Literal[Color1.GREEN]"

[case annotated_incompatibility_with_type]
# Copied from conformance tests (qualifiers_annotated.py)
from typing import TypeAlias, Annotated, Any, TypeVar
T = TypeVar("T")
# > Annotated is not type compatible with type or type[T]
SmallInt: TypeAlias = Annotated[int, ""]

not_type1: type[Any] = Annotated[int, ""]  # E: Incompatible types in assignment (expression has type "_SpecialForm", variable has type "type[Any]")
not_type2: type[Any] = SmallInt  # E: Incompatible types in assignment (expression has type "_SpecialForm", variable has type "type[Any]")


def func4(x: type[T]) -> T:
    return x()


func4(Annotated[str, ""])  # E: Argument 1 to "func4" has incompatible type "_SpecialForm"; expected "type[Never]"
func4(SmallInt)  # E: Argument 1 to "func4" has incompatible type "_SpecialForm"; expected "type[Never]"


# > An attempt to call Annotated (whether parameterized or not) should be
# > treated as a type error by type checkers.

Annotated()  # E: "_SpecialForm" not callable
Annotated[int, ""]()  # E: "_SpecialForm" not callable
SmallInt(1)  # E: "<typing special form>" not callable

[case annotated_can_be_nested]
# Copied from conformance tests (qualifiers_annotated.py)
from typing import Annotated, ClassVar, Final
class ClassA:
    a: ClassVar[Annotated[int, ""]] = 1
    b: Annotated[ClassVar[int], ""] = 1
    c: Final[Annotated[int, ""]] = 1
    d: Annotated[Final[int], ""] = 1

[case implicit_alias_with_bitwise_or_recognized]
from typing import TypeVar
T = TypeVar("T")

alias1 = tuple[T, ...] | list[T] | str
alias2 = str | tuple[T, ...] | list[T]
alias3 = tuple[set[T], ...] | tuple[list[T]]

non_alias1, non_alias2 = list[T] | str  # E: "UnionType" object is not iterable \
                                        # E: Type variable "__main__.T" is unbound \
                                        # N: (Hint: Use "Generic[T]" or "Protocol[T]" base class to bind "T" inside a class) \
                                        # N: (Hint: Use "T" in function signature to bind "T" inside a function)
non_alias3: type = list[T] | str  # E: Incompatible types in assignment (expression has type "UnionType", variable has type "type[Any]") \
                                  # E: Type variable "__main__.T" is unbound \
                                  # N: (Hint: Use "Generic[T]" or "Protocol[T]" base class to bind "T" inside a class) \
                                  # N: (Hint: Use "T" in function signature to bind "T" inside a function)


[case valid_type_alias_implicit_from_conformance_tests]
# from conformance tests (aliases_implicit.py)
from typing import TypeVar, ParamSpec, Callable, Union, Any, assert_type, Concatenate
TFloat = TypeVar("TFloat", bound=float)
S = TypeVar("S")
T = TypeVar("T")
P = ParamSpec("P")
R = TypeVar("R")

GoodTypeAlias1 = Union[int, str]
GoodTypeAlias2 = int | None
GoodTypeAlias3 = list[GoodTypeAlias2]
GoodTypeAlias4 = list[T]
GoodTypeAlias5 = tuple[T, ...] | list[T]
GoodTypeAlias6 = tuple[int, int, S, T]
GoodTypeAlias7 = Callable[..., int]
GoodTypeAlias8 = Callable[[int, T], T]
GoodTypeAlias9 = Callable[Concatenate[int, P], R]
GoodTypeAlias10 = Any
GoodTypeAlias11 = GoodTypeAlias1 | GoodTypeAlias2 | list[GoodTypeAlias4[int]]
GoodTypeAlias12 = list[TFloat]
GoodTypeAlias13 = Callable[P, None]


def good_type_aliases(
    p1: GoodTypeAlias1,
    p2: GoodTypeAlias2,
    p3: GoodTypeAlias3,
    p4: GoodTypeAlias4[int],
    p5: GoodTypeAlias5[str],
    p6: GoodTypeAlias6[int, str],
    p7: GoodTypeAlias7,
    p8: GoodTypeAlias8[str],
    p9: GoodTypeAlias9[[str, str], None],
    p10: GoodTypeAlias10,
    p11: GoodTypeAlias11,
    p12: GoodTypeAlias12[bool],
    p13: GoodTypeAlias13
):
    assert_type(p1, int | str)
    assert_type(p2, int | None)
    assert_type(p3, list[int | None])
    assert_type(p4, list[int])
    assert_type(p5, tuple[str, ...] | list[str])
    assert_type(p6, tuple[int, int, int, str])
    assert_type(p7, Callable[..., int])
    assert_type(p8, Callable[[int, str], str])
    assert_type(p9, Callable[[int, str, str], None])
    assert_type(p10, Any)
    assert_type(p11, int | str | None | list[list[int]])
    assert_type(p12, list[bool])
    assert_type(p13, Callable[..., None])

[case float_promotions_with_subclasses_of_int]
class X(int): ...

x: float = X()
y: float = True
z: float = bool()

[case alias_disallowed_in_function]
# flags: --no-mypy-compatible
# Copied from conformance tests (aliases_type_statement.py)
def func3() -> None:
    type BadTypeAlias15 = int  # E: Type alias not allowed in function

[case assert_type_in_untyped_func]
# flags: --check-untyped-defs
from typing import Any, assert_type
def foo(x):
    assert_type(x, Any)

[case no_type_check_but_params_for_calls_are_still_checked_in_mypy_compatible]
# flags: --no-mypy-compatible
# Copied from conformance tests (directives_no_type_check.py)
from typing import no_type_check
@no_type_check
def func1(a: int, b: str) -> None:
    c = a + b  # E?: No error should be reported
    return 1  # E?: No error should be reported

func1(b"invalid", b"arguments")  # E?: No error should be reported
# This should still be an error because type checkers should ignore
# annotations, but still check the argument count.
func1()  # E: Missing positional arguments "a", "b" in call to "func1"

[case no_type_check_when_type_is_changed]
from typing import no_type_check, Callable

def dec(x) -> Callable[[int], str]: ...

@dec
@no_type_check
def f(a: int, b: str) -> None: ...

f(1, 2)  # E: Too many arguments for "f"
f(1)
reveal_type(f(b''))  # N: Revealed type is "Any"

[case no_type_check_when_callable_becomes_none]
from typing import no_type_check, Callable

def dec(x) -> None: ...

@dec
@no_type_check
def f(a: 1 + 2, b: str) -> None:
    ...

reveal_type(f) # N: Revealed type is "None"
f(1, 2)  # E: "None" not callable

[case non_redundant_cast_with_any]
# flags: --strict
from typing import Any, cast

def f(x: Any | None) -> None:
    y = cast(str | None, x)
    reveal_type(y)  # N: Revealed type is "str | None"

[case types_for_exponentials]
# From GitHub #59
reveal_type(0e0)  # N: Revealed type is "float"
reveal_type(0.0e0)  # N: Revealed type is "float"

[case empty_exception_groups_no_crash]
# See GitHub #68
try:
    pass
except* () as e:
    reveal_type(e)  # N: Revealed type is "BaseExceptionGroup[Never]"

[case no_crash_on_aug_assignment_with_same_name]
import foo
reveal_type(foo.c)  # N: Revealed type is "Any"

[file foo.py]
(c  # E: Name "c" is not defined
) +=c  # E: Name "c" is used before definition  # E: Cannot resolve name "c" (possible cyclic definition)

[case aug_assignment_change_incremental1]
[file m.py]
import n
x = n.a
x += 1

[file n.py]
a = 1

[file n.py.2]
a = ""
[out]
==
m.py:3: error: Unsupported operand types for + ("str" and "int")

[case aug_assignment_change_incremental2]
[file m.py]
import n
x = []
x += [n.a]
x += [1]

[file n.py]
a = 1

[file n.py.2]
a = ""
[out]
==
m.py:4: error: Argument 1 to "__iadd__" of "list" has incompatible type "list[int]"; expected "Iterable[str]"

[case avoid_recursion_problem_in_del]
# From GH #76
del a.b, \
    a
[out]
__main__:2: error: Name "a" is used before definition
__main__:3: error: Name "a" is not defined

[case e_in_hex_int]
a1: int = 0x0D
a2: int = 0x0E
a3: int = 0x0F

reveal_type(0x0E)  # N: Revealed type is "Literal[14]?"

a4: int = 0x0d
a5: int = 0x0e

reveal_type(0x0E3)  # N: Revealed type is "Literal[227]?"
reveal_type(0X0E3)  # N: Revealed type is "Literal[227]?"
reveal_type(0X0e3)  # N: Revealed type is "Literal[227]?"

reveal_type(0E3)  # N: Revealed type is "float"
reveal_type(0e3)  # N: Revealed type is "float"

reveal_type(0b1)  # N: Revealed type is "Literal[1]?"
reveal_type(0xb1)  # N: Revealed type is "Literal[177]?"

[case exception_group_is_valid_in_except]
# From GH #96
try:
    1
except ExceptionGroup:
    pass

[case python310_with_typing_extensions_should_not_crash]
# flags: --python-version 3.10
# From GH #106
import typing_extensions
typing_extensions.OrderedDict

[case python308_with_typing_extensions_should_not_crash]
# flags: --python-version 3.8
# From GH #106
import typing_extensions
typing_extensions.OrderedDict

[case with_multi_simple_contexts]
# From GH #109
import contextlib

with (
    contextlib.suppress(Exception),
    contextlib.suppress(Exception),
):
    pass

[case avoid_recursion_with_decorator]
# From GH #123
@f  # E: Name "f" is used before definition  # E: Cannot resolve name "f" (possible cyclic definition)
def f():
    pass

@g  # E: Name "g" is used before definition  # E: Cannot resolve name "g" (possible cyclic definition)
def g() -> int:
    pass

[case avoid_recursion_with_exception_name_reuse1]
# From GH #130
try:
    pass
except e as e:  # E: Cannot resolve name "e" (possible cyclic definition)
    pass

try:
    pass
except *f as f:  # E: Cannot resolve name "f" (possible cyclic definition)
    pass

[case avoid_recursion_with_exception_name_reuse2]
# From GH #132
try:
    pass
except E as e:  # E: Name "E" is used before definition \
                # E: Cannot resolve name "e" (possible cyclic definition)
    pass
except e as E:
    pass

try:
    pass
except *F as f:  # E: Name "F" is used before definition \
                # E: Cannot resolve name "f" (possible cyclic definition) \
                # E: Exception type must be derived from BaseException (or be a tuple of exception classes)
    pass
except *f as F:  # E: Exception type must be derived from BaseException (or be a tuple of exception classes)
    pass

[case avoid_crash_with_del]
# From GH #138
i  # E: Name "i" is used before definition
del a[i], i  # E: Name "a" is not defined \
             # E: Name "i" is used before definition \
             # E: Cannot resolve name "i" (possible cyclic definition) \
             # E: Name "i" is not defined
