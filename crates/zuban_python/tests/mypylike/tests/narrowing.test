[case reachability_mypy_compatible]
# flags: --mypy-compatible
def foo(x: None) -> None:
    if x is None:
        return
    else:
        1()
        if x:
            reveal_type(x)

[case reachability_no_mypy_compatible]
# flags: --no-mypy-compatible
def foo(x: None, y: int | None) -> None:
    if x is None:
        return
    else:
        1()  # E: "int" not callable
        if y:
            reveal_type(y)  # N: Revealed type is "int"
            reveal_type(x)  # N: Revealed type is "None"

[case narrow_len_yoda_like]
from typing import Any, Union, Tuple

x: Union[Tuple[int, int], Tuple[int, int, int]]
if 2 == len(x):
    reveal_type(x) # N: Revealed type is "tuple[int, int]"
else:
    reveal_type(x) # N: Revealed type is "tuple[int, int, int]"

[case narrow_unreachable_len1]
# flags: --warn-unreachable --mypy-compatible
from typing import Tuple

x: Tuple[int, ...]
if str():
    if len(x) >= 0:
        reveal_type(x)  # N: Revealed type is "tuple[int, ...]"
    else:
        reveal_type(x)  # E: Statement is unreachable

if str():
    if len(x) <= 0:
        reveal_type(x)  # N: Revealed type is "tuple[()]"
    else:
        reveal_type(x)  # N: Revealed type is "tuple[int, Unpack[Tuple[int, ...]]]"

if str():
    if 0 >= len(x):
        reveal_type(x)  # N: Revealed type is "tuple[()]"
    else:
        reveal_type(x)  # N: Revealed type is "tuple[int, Unpack[Tuple[int, ...]]]"

if str():
    if len(x) <= 1:
        reveal_type(x)  # N: Revealed type is "tuple[()] | tuple[int]"
    else:
        reveal_type(x)  # N: Revealed type is "tuple[int, int, Unpack[Tuple[int, ...]]]"

if str():
    if 1 >= len(x):
        reveal_type(x)  # N: Revealed type is "tuple[()] | tuple[int]"
    else:
        reveal_type(x)  # N: Revealed type is "tuple[int, int, Unpack[Tuple[int, ...]]]"


[case narrow_unreachable_len2]
# flags: --warn-unreachable --mypy-compatible
from typing import Tuple

x: Tuple[int, ...]

if str():
    if 0 > len(x):
        reveal_type(x)  # E: Statement is unreachable
    else:
        reveal_type(x)  # N: Revealed type is "tuple[int, ...]"

if str():
    if 1 > len(x):
        reveal_type(x)  # N: Revealed type is "tuple[()]"
    else:
        reveal_type(x)  # N: Revealed type is "tuple[int, Unpack[Tuple[int, ...]]]"

if str():
    if 2 > len(x):
        reveal_type(x)  # N: Revealed type is "tuple[()] | tuple[int]"
    else:
        reveal_type(x)  # N: Revealed type is "tuple[int, int, Unpack[Tuple[int, ...]]]"

if str():
    if 0 < len(x):
        reveal_type(x)  # N: Revealed type is "tuple[int, Unpack[Tuple[int, ...]]]"
    else:
        reveal_type(x)  # N: Revealed type is "tuple[()]"

if str():
    if len(x) < 0:
        reveal_type(x)  # E: Statement is unreachable
    else:
        reveal_type(x)  # N: Revealed type is "tuple[int, ...]"

[case narrowing_named_tuple_calls1]
# Like testNarrowingLenUnionOfNamedTuples, but with direct calls instead of classes
from typing import NamedTuple, Union

Point2D = NamedTuple("Point2D", [('x', int), ('y', int)])
Point3D = NamedTuple("Point3D", [('x', int), ('y', int), ('z', int)])

x: Union[Point2D, Point3D]
if len(x) == 2:
    reveal_type(x)  # N: Revealed type is "tuple[int, int, fallback=__main__.Point2D]"
else:
    reveal_type(x)  # N: Revealed type is "tuple[int, int, int, fallback=__main__.Point3D]"

[case narrowing_named_tuple_calls2]
# Like testNarrowingLenUnionOfNamedTuples, but with direct calls instead of classes
from typing import NamedTuple, Union
from collections import namedtuple

Point2D = namedtuple("Point2D", ['x', 'y'])
Point3D = namedtuple("Point3D", ['x', 'y', 'z'])

x: Union[Point2D, Point3D]
if len(x) == 2:
    reveal_type(x)  # N: Revealed type is "tuple[Any, Any, fallback=__main__.Point2D]"
else:
    reveal_type(x)  # N: Revealed type is "tuple[Any, Any, Any, fallback=__main__.Point3D]"

[case narrowing_type_of_other_side]
from typing import Any

x: Any
if int == type(x):
    reveal_type(x)  # N: Revealed type is "int"
else:
    reveal_type(x)  # N: Revealed type is "Any"

[case avoid_narrowing_of_len_with_big_unpack]
from typing import Tuple
from typing_extensions import Unpack

VarTuple = Tuple[int, Unpack[Tuple[str, ...]]]

x: VarTuple
if len(x) < 30:
    reveal_type(x) # N: Revealed type is "tuple[int, Unpack[Tuple[str, ...]]]"
else:
    reveal_type(x) # N: Revealed type is "tuple[int, Unpack[Tuple[str, ...]]]"

[case narrow_attribute_split]
class Foo:
    x: int | None

foo: Foo

foo.x + 1 # E: Unsupported operand types for + ("None" and "int") \
          # N: Left operand is of type "int | None"

if foo.x:
    foo.x + 1

[case narrow_getitem_split]
foo: list[int | None]

foo[0] + 1 # E: Unsupported operand types for + ("None" and "int") \
           # N: Left operand is of type "int | None"

if foo[0]:
    foo[0] + 1
    foo[1] + 1 # E: Unsupported operand types for + ("None" and "int") \
               # N: Left operand is of type "int | None"

[case new_type_intersection]
from typing import NewType
class A: ...
class B: ...
N = NewType('N', A)

def parse_ast(n: N) -> None:
    if isinstance(n, B):
        reveal_type(n)  # N: Revealed type is "<subclass of "__main__.N" and "__main__.B">"

[case tuple_intersection_with_getitem]
from typing import Tuple
class A:
    def foo(self) -> int: ...
class B: ...

x: Tuple[int, str]

if isinstance(x, A):
    reveal_type(x)  # N: Revealed type is "<subclass of "tuple[int, str]" and "__main__.A">"
    reveal_type(x[0])  # N: Revealed type is "int"
    reveal_type(x[1])  # N: Revealed type is "str"
    x.foo()

a: A
if isinstance(a, B):
    a[0]  # E: Value of type "A" is not indexable

[case intersection_with_getitem_of_classes]
from typing import Tuple
class A:
    def __getitem__(self, other: int) -> str: ...
class B: ...

a: A
b: B
if isinstance(a, B):
    reveal_type(a[0])  # N: Revealed type is "str"

if isinstance(b, A):
    reveal_type(b[0]) # N: Revealed type is "str"

[case issubclass_and_isinstance_with_generics]
from typing import Generic, TypeVar, Type
T = TypeVar('T')

class A(Generic[T]): ...

a1: Type[A[int]]
a2: A[int]

if issubclass(a1, A):
    reveal_type(a1)  # N: Revealed type is "type[__main__.A[int]]"

if isinstance(a2, A):
    reveal_type(a2) # N: Revealed type is "__main__.A[int]"

[case narrow_frozenset_contains]
d: frozenset[str]
key: str | None
if key in d:
    reveal_type(key)  # N: Revealed type is "str"
else:
    reveal_type(key)  # N: Revealed type is "str | None"

[case narrow_type_type_parent_unions]
from typing import ClassVar, Type, Literal
class Foo:
    baz: ClassVar[Literal[1]] = 1
class Bar:
    baz: ClassVar[Literal[2]] = 2

def foo(x: Type[Foo | Bar]) -> None:
    if x.baz == 1:
        reveal_type(x)  # N: Revealed type is "type[__main__.Foo]"
    else:
        reveal_type(x)  # N: Revealed type is "type[__main__.Bar]"

def bar(x: Type[Foo] | Type[Bar]) -> None:
    if x.baz == 2:
        reveal_type(x)  # N: Revealed type is "type[__main__.Bar]"
    else:
        reveal_type(x)  # N: Revealed type is "type[__main__.Foo]"

[case try_stmt_else_narrowing1]
class A: ...
class B(A): ...
a: A = A()
try:
    a = B()
except Exception:
    reveal_type(a)  # N: Revealed type is "__main__.A"
else:
    reveal_type(a)  # N: Revealed type is "__main__.B"
finally:
    reveal_type(a)  # N: Revealed type is "__main__.A"

[case try_stmt_else_narrowing2]
class A: ...
class B: ...
class C: ...
a: A | B | C
a = A()
try:
    a = B()
except Exception:
    reveal_type(a)  # N: Revealed type is "__main__.A | __main__.B"
else:
    reveal_type(a)  # N: Revealed type is "__main__.B"
finally:
    reveal_type(a)  # N: Revealed type is "__main__.A | __main__.B"

[case try_stmt_else_unreachable]
# flags: --warn-unreachable
try:
    raise NotImplementedError
except Exception:
    1
else:
    1  # E: Statement is unreachable
finally:
    1

[case try_multiple_excepts_narrowing]
# flags: --warn-unreachable
class A: ...
class B(A): ...

x: A = A()
y: A = A()
x = B()
y = B()

try:
    x = A()
    y = A()
except ValueError:
    pass
except TypeError:
    pass
reveal_type(x)  # N: Revealed type is "__main__.A"
reveal_type(y)  # N: Revealed type is "__main__.A"

[case try_walrus_widening]
class A: ...
class B: ...
class C: ...
a: A | B | C
b: A | B | C
c: A | B | C
d: A | B | C
a = A()
b = A()
c = A()
d = A()

try:
    if (a := B()) and bool():
        pass
    if bool() and (b := B()):
        pass
    if (c := B()):
        pass
    (d := B())
except ValueError:
    pass
else:
    a = A()
    b = A()
    c = A()
    d = A()
reveal_type(a)  # N: Revealed type is "__main__.A | __main__.B"
reveal_type(b)  # N: Revealed type is "__main__.A | __main__.B"
reveal_type(c)  # N: Revealed type is "__main__.A | __main__.B"
reveal_type(d)  # N: Revealed type is "__main__.A | __main__.B"

[case if_widening_statement1]
# flags: --warn-unreachable
class A: ...
class B(A): ...
class C(B): ...

x: A = A()
x = C()

if bool():
    x = B()

reveal_type(x)  # N: Revealed type is "__main__.B"

[case if_widening_statement2]
# flags: --warn-unreachable
class A: ...
class B: ...
class C: ...

x: A | B | C = A()
x = A()

if bool():
    if bool():
        x = B()

    reveal_type(x)  # N: Revealed type is "__main__.A | __main__.B"
    if bool():
        x = C()
reveal_type(x)  # N: Revealed type is "__main__.A | __main__.B | __main__.C"

[case unreachable_for_simple_stmt_but_some_simple_stmts_are_ok]
# flags: --warn-unreachable

a: str | None
a = ""
if a is None:
    raise NotImplementedError; \
        bool()  # E: Statement is unreachable

[case walrus_in_conjunction]
class A: ...
class B: ...
class C: ...

y: int

def foo() -> None:
    x: A | B | C
    x = A()
    if (x := B()) and y == 1:
        reveal_type(x)  # N: Revealed type is "__main__.B"
    else:
        reveal_type(x)  # N: Revealed type is "__main__.B"
    reveal_type(x)  # N: Revealed type is "__main__.B"

def bar() -> None:
    x: A | B | C
    x = A()
    if y == 1 and (x := B()):
        reveal_type(x)  # N: Revealed type is "__main__.B"
    else:
        reveal_type(x)  # N: Revealed type is "__main__.A | __main__.B"
    reveal_type(x)  # N: Revealed type is "__main__.B | __main__.A"

[case walrus_in_disjunction]
class A: ...
class B: ...
class C: ...

y: int

def foo() -> None:
    x: A | B | C
    x = A()
    if (x := B()) or y == 1:
        reveal_type(x)  # N: Revealed type is "__main__.B"
    else:
        reveal_type(x)  # N: Revealed type is "__main__.B"
    reveal_type(x)  # N: Revealed type is "__main__.B"

def bar() -> None:
    x: A | B | C
    x = A()
    if y == 1 or (x := B()):
        reveal_type(x)  # N: Revealed type is "__main__.A | __main__.B"
    else:
        reveal_type(x)  # N: Revealed type is "__main__.B"
    reveal_type(x)  # N: Revealed type is "__main__.A | __main__.B"

[case walrus_isinstance_conjunction_joining]
class A: ...
class B: ...
class BB(B): ...
class C: ...

y: int

def foo() -> None:
    x: A | B | C
    x = A()
    if (x := B()) and isinstance(x, BB):
        reveal_type(x)  # N: Revealed type is "__main__.BB"
    else:
        reveal_type(x)  # N: Revealed type is "__main__.B"
    reveal_type(x)  # N: Revealed type is "__main__.B"

def bar() -> None:
    x: A | B | C
    x = A()
    if isinstance(x, BB) and (x := B()):
        reveal_type(x)  # N: Revealed type is "__main__.B"
    else:
        reveal_type(x)  # N: Revealed type is "__main__.A | __main__.B"
    reveal_type(x)  # N: Revealed type is "__main__.B | __main__.A"

[case walrus_isinstance_disjunction_joining]
class A: ...
class B: ...
class BB(B): ...
class C: ...

y: int

def foo() -> None:
    x: A | B | C
    x = A()
    if (x := B()) or isinstance(x, BB):
        reveal_type(x)  # N: Revealed type is "__main__.B"
    else:
        reveal_type(x)  # N: Revealed type is "__main__.B"
    reveal_type(x)  # N: Revealed type is "__main__.B"

def bar() -> None:
    x: A | B | C
    x = A()
    if isinstance(x, BB) or (x := B()):
        reveal_type(x)  # N: Revealed type is "__main__.B"
    else:
        reveal_type(x)  # N: Revealed type is "__main__.B"
    reveal_type(x)  # N: Revealed type is "__main__.B"

[case walrus_narrowing_with_initial_definition_in_if]
d = {'hello': 'hi'}

if x:= d.get('hello'):
    reveal_type(x)  # N: Revealed type is "str"
elif x:= d.get('world'):
    reveal_type(x)  # N: Revealed type is "str"
else:
    reveal_type(x)  # N: Revealed type is "Literal[''] | None"

[case walrus_narrowing_with_initial_definition_in_class_body]
class C:
    x: int | None

    def func(self) -> None:
        if x := self.x:
            reveal_type(x) # N: Revealed type is "int"
        else:
            reveal_type(x) # N: Revealed type is "Literal[0] | None"

[case walrus_narrowing_with_initial_definition_outside_if_wrong_type]
d = {'hello': 'hi'}

x: str | None

if x:= d.get('hello'):
    reveal_type(x)  # N: Revealed type is "str"
elif x:= 1:  # E: Incompatible types in assignment (expression has type "int", variable has type "str | None")
    reveal_type(x)  # N: Revealed type is "Literal[''] | None"
else:
    reveal_type(x)  # N: Revealed type is "Literal[''] | None"

[case walrus_narrowing_with_unreachable_if]
# flags: --warn-unreachable
from typing import Literal
def f(x: Literal[0] | None):
    if y := x:
        reveal_type(y)  # E: Statement is unreachable
    else:
        reveal_type(y)  # N: Revealed type is "Literal[0] | None"

[case multi_while_break_widening]
class A: ...
class B: ...
class C: ...

def foo(x: A | B | C) -> None:
    x = A()
    while bool():
        if bool():
            x = B()
            break
        if bool():
            x = C()
            break
    reveal_type(x)  # N: Revealed type is "__main__.A | __main__.B | __main__.C"

def bar(x: A | B | C) -> None:
    x = A()
    while True:
        if bool():
            x = B()
            break
        if bool():
            x = C()
            break
    reveal_type(x)  # N: Revealed type is "__main__.B | __main__.C"

[case while_break_widening2]
class A: ...
class B: ...
class C: ...

def foo(x: A | B | C) -> None:
    x = A()
    while bool():
        if bool():
            break
        x = B()
    reveal_type(x)  # N: Revealed type is "__main__.A | __main__.B"

[case try_except_multi_widening]
class A: ...
class B: ...
class C: ...

def foo(x: A | B | C) -> None:
    x = A()
    try:
        pass
    except ValueError:
        x = B()
    except TypeError:
        pass
    else:
        return
    reveal_type(x)  # N: Revealed type is "__main__.A | __main__.B"

def bar(x: A | B | C) -> None:
    x = A()
    try:
        pass
    except ValueError:
        pass
    except TypeError:
        x = B()
    else:
        return
    reveal_type(x)  # N: Revealed type is "__main__.A | __main__.B"

[case with_widening]
class A: ...
class B: ...
class C: ...
class D: ...

class Suppresses1:
    def __enter__(self) -> int: ...
    def __exit__(self, exctype: object, excvalue: object, traceback: object) -> bool: ...

class DoesNotSuppress:
    def __enter__(self) -> int: ...
    def __exit__(self, exctype: object, excvalue: object, traceback: object) -> None: ...


def foo(x: A | B | C | D) -> None:
    x = A()
    with Suppresses1():
        x = B()
        x = C()

    reveal_type(x)  # N: Revealed type is "__main__.A | __main__.B | __main__.C"

def bar(x: A | B | C | D) -> None:
    x = A()
    with DoesNotSuppress():
        x = B()
        x = C()

    reveal_type(x)  # N: Revealed type is "__main__.C"

[case narrowing_primary_target]
from typing import Union

class Animal:
    pass

class Dog(Animal):
    paws: int | str = 4

class House:
    pet: Animal | None = None

h = House()
h.pet = Dog()

if isinstance(h.pet, Dog):
    if isinstance(h.pet.paws, str):
        h.pet.paws = 1
        h.pet.paws + 1
        h.pet.paws = 1.0  # E: Incompatible types in assignment (expression has type "float", variable has type "int | str")

[case try_invalidation]
class Animal:
    pass

class Dog(Animal):
    paws: int | str = 4

def foo(x: Animal):
    x = Dog()
    x.paws = ""
    try:
        x.paws = 3
    except:
        x = Animal()
    x.paws  # E: "Animal" has no attribute "paws"

def bar(x: Animal):
    x = Dog()
    x.paws = ""
    try:
        pass
    except:
        x.paws = 3
    else:
        x = Animal()
    x.paws  # E: "Animal" has no attribute "paws"

def baz(x: Animal):
    x = Dog()
    x.paws = ""
    try:
        pass
    except TypeError:
        x.paws = 3
    except:
        x = Animal()
    x.paws  # E: "Animal" has no attribute "paws"

[case if_invalidation]
class Animal:
    pass

class Dog(Animal):
    paws: int | str = 4

def foo(x: Animal):
    x = Dog()
    x.paws = ""
    if bool():
        x.paws = 3
    else:
        x = Animal()
    x.paws  # E: "Animal" has no attribute "paws"

def bar(x: Animal):
    x = Dog()
    x.paws = ""
    if bool():
        x = Animal()
    else:
        x.paws = 3
    x.paws  # E: "Animal" has no attribute "paws"

[case del_invalidation]
class Animal:
    pass

class Dog(Animal):
    paws: int | str = 4

def foo(x: Animal):
    x = Dog()
    x.paws = ""
    if bool():
        del x
    else:
        x.paws = 3
    x.paws

def bar(x: Animal):
    x = Dog()
    x.paws = ""
    if bool():
        x.paws = 3
    else:
        del x
    x.paws

def baz(x: Animal):
    x = Dog()
    x.paws = ""
    if bool():
        del x
    else:
        del x
    x.paws  # E: Trying to read deleted variable "x"


[case try_invalidation2]
class Animal:
    pass

class Dog(Animal):
    paws: int | str | bytes = 4

def foo(x: Animal):
    x = Dog()
    x.paws = ""
    try:
        x.paws = 3
        # Error can occur between these statements
        x = Dog()
    except:
        reveal_type(x.paws)  # N: Revealed type is "int | str | bytes"

def bar(x: Animal):
    x = Dog()
    x.paws = ""
    try:
        x.paws = 3
        # Error can occur between these statements
        x = Dog()
        return
    except:
        reveal_type(x.paws)  # N: Revealed type is "int | str | bytes"

def baz(x: Animal):
    x = Dog()
    x.paws = ""
    try:
        x = Dog()
        # Error can occur between these statements
        x.paws = 3
    except:
        reveal_type(x.paws)  # N: Revealed type is "int | str | bytes"

def bla(x: Animal):
    x = Dog()
    x.paws = ""
    try:
        x.paws = 3
    except:
        reveal_type(x.paws)  # N: Revealed type is "str | int"

[case with_invalidation]
class Animal:
    pass

class Dog(Animal):
    paws: int | str | bytes = 4

class Suppresses:
    def __enter__(self) -> int: ...
    def __exit__(self, exctype: object, excvalue: object, traceback: object) -> bool: ...

class DoesNotSuppress:
    def __enter__(self) -> int: ...
    def __exit__(self, exctype: object, excvalue: object, traceback: object) -> None: ...

def foo(x: Animal):
    x = Dog()
    x.paws = ""
    with DoesNotSuppress():
        x = Dog()
        x.paws = 3
    reveal_type(x.paws)  # N: Revealed type is "int"

def bar(x: Animal):
    x = Dog()
    x.paws = ""
    with Suppresses():
        x = Dog()
        # Error can occur between these statements
        x.paws = 3
    reveal_type(x.paws)  # N: Revealed type is "int | str | bytes"

def baz(x: Animal):
    x = Dog()
    x.paws = ""
    with Suppresses():
        x.paws = 3
        x = Dog()
    reveal_type(x.paws)  # N: Revealed type is "int | str | bytes"

def bla(x: Animal):
    x = Dog()
    x.paws = ""
    with Suppresses():
        x.paws = 3
    reveal_type(x.paws)  # N: Revealed type is "str | int"


[case if_invalidation2]
class Dog:
    paws: int | str | bytes = 4

x = Dog()
x.paws = ""
if bool():
    x = Dog()
    reveal_type(x.paws)  # N: Revealed type is "int | str | bytes"
else:
    reveal_type(x.paws)  # N: Revealed type is "str"
reveal_type(x.paws)  # N: Revealed type is "int | str | bytes"

[case if_invalidation3]
class Dog:
    paws: int | str | bytes = 4

x = Dog()
x.paws = ""
if bool():
    x = Dog()
    reveal_type(x.paws)  # N: Revealed type is "int | str | bytes"
else:
    x.paws = 3
    reveal_type(x.paws)  # N: Revealed type is "int"
reveal_type(x.paws)  # N: Revealed type is "int | str | bytes"

[case if_invalidation_nested]
class Dog:
    paws: int | str | bytes = 4

class House:
    pet: Dog

def foo(x: House):
    x.pet.paws = ""
    if bool():
        x = House()
        reveal_type(x.pet.paws)  # N: Revealed type is "int | str | bytes"
    else:
        reveal_type(x.pet.paws)  # N: Revealed type is "str"
    reveal_type(x.pet.paws)  # N: Revealed type is "int | str | bytes"

def bar(x: House):
    x.pet.paws = ""
    if bool():
        x.pet = Dog()
        reveal_type(x.pet.paws)  # N: Revealed type is "int | str | bytes"
    else:
        reveal_type(x.pet.paws)  # N: Revealed type is "str"
    reveal_type(x.pet.paws)  # N: Revealed type is "int | str | bytes"

[case loop_invalidation1]
class Dog:
    paws: int | str | bytes = 4

def foo(x: Dog):
    x.paws = ""
    for _ in [1]:
        if bool():
            x.paws = 3
            continue
        else:
            x = Dog()
            continue
    else:
        reveal_type(x.paws)  # N: Revealed type is "int | str | bytes"
    reveal_type(x.paws)  # N: Revealed type is "int | str | bytes"

def bar(x: Dog):
    x.paws = ""
    for _ in [1]:
        if bool():
            x = Dog()
            continue
        else:
            x.paws = 3
            continue
    else:
        reveal_type(x.paws)  # N: Revealed type is "int | str | bytes"
    reveal_type(x.paws)  # N: Revealed type is "int | str | bytes"

[case loop_invalidation2]
class Dog:
    paws: int | str | bytes = 4

def foo(x: Dog):
    x.paws = ""
    for _ in [1]:
        if bool():
            x.paws = 3
            continue
        else:
            x = Dog()
            x.paws = 3
            continue
    else:
        reveal_type(x.paws)  # N: Revealed type is "int | str | bytes"
    reveal_type(x.paws)  # N: Revealed type is "int | str | bytes"

def bar(x: Dog):
    x.paws = ""
    for _ in [1]:
        if bool():
            x = Dog()
            x.paws = 3
            continue
        else:
            x.paws = 3
            continue
    else:
        reveal_type(x.paws)  # N: Revealed type is "int | str | bytes"
    reveal_type(x.paws)  # N: Revealed type is "int | str | bytes"

[case loop_invalidation3]
class Dog:
    paws: int | str | bytes = 4

# foo could theoretically narrow to int | str instead of not narrowing, because
# there are so many edge cases and Mypy also doesn't narrow it.
def foo(x: Dog):
    x.paws = ""
    for _ in [1]:
        if bool():
            x = Dog()
            x.paws = 3
            continue
        else:
            x = Dog()
            x.paws = 3
            continue
    else:
        reveal_type(x.paws)  # N: Revealed type is "int | str | bytes"
    reveal_type(x.paws)  # N: Revealed type is "int | str | bytes"

def bar(x: Dog):
    x.paws = ""
    for _ in [1]:
        if bool():
            x = Dog()
            x.paws = 3
            continue
        else:
            x.paws = 3
            x = Dog()
            continue
    else:
        reveal_type(x.paws)  # N: Revealed type is "int | str | bytes"
    reveal_type(x.paws)  # N: Revealed type is "int | str | bytes"

def baz(x: Dog):
    x.paws = ""
    for _ in [1]:
        if bool():
            x.paws = 3
            x = Dog()
            continue
        else:
            x = Dog()
            x.paws = 3
            continue
    else:
        reveal_type(x.paws)  # N: Revealed type is "int | str | bytes"
    reveal_type(x.paws)  # N: Revealed type is "int | str | bytes"

[case loop_invalidation4]
class Dog:
    paws: int | str | bytes = 4

def foo(x: Dog):
    x.paws = ""
    for _ in [1]:
        if bool():
            x.paws = 3
            x = Dog()
            continue
        else:
            x.paws = 3
            continue
    else:
        reveal_type(x.paws)  # N: Revealed type is "int | str | bytes"
    reveal_type(x.paws)  # N: Revealed type is "int | str | bytes"

def bar(x: Dog):
    x.paws = ""
    for _ in [1]:
        if bool():
            x.paws = 3
            continue
        else:
            x.paws = 3
            x = Dog()
            continue
    else:
        reveal_type(x.paws)  # N: Revealed type is "int | str | bytes"
    reveal_type(x.paws)  # N: Revealed type is "int | str | bytes"

[case loop_invalidation_nested]
class Dog:
    paws: int | str | bytes = 4

class House:
    dog: Dog

def foo(x: House):
    x.dog.paws = ""
    for _ in [1]:
        if bool():
            x.dog.paws = 3
            continue
        else:
            x = House()
            continue
    else:
        reveal_type(x.dog.paws)  # N: Revealed type is "int | str | bytes"
    reveal_type(x.dog.paws)  # N: Revealed type is "int | str | bytes"

def bar(x: House):
    x.dog.paws = ""
    for _ in [1]:
        if bool():
            x.dog.paws = 3
            continue
        else:
            x.dog = Dog()
            continue
    else:
        reveal_type(x.dog.paws)  # N: Revealed type is "int | str | bytes"
    reveal_type(x.dog.paws)  # N: Revealed type is "int | str | bytes"

[case union_isinstance_with_any]
from typing import Any

def foo(x: int | str, y: Any):
    if isinstance(x, int | y):
        reveal_type(x)  # N: Revealed type is "int | Any"
    else:
        reveal_type(x)  # N: Revealed type is "str"

    if isinstance(x, y | int):
        reveal_type(x)  # N: Revealed type is "Any | int"
    else:
        reveal_type(x)  # N: Revealed type is "str"

[case type_is_restriction_with_reachability]
# flags: --warn-unreachable
# Like testTypeIsNestedRestrictionUnionIsInstance, but in a better way
from typing_extensions import TypeIs
from typing import Any, List

class A: ...
class B: ...
def f(x: List[Any] | B) -> TypeIs[List[str]]: ...

def test(x: List[Any]) -> None:
    if not(f(x) or isinstance(x, A)):  # E: Right operand of "or" is never evaluated
        return  # E: Statement is unreachable
    reveal_type(x)  # N: Revealed type is "list[Any]"

def test2(x: List[Any] | B) -> None:
    if f(x) or isinstance(x, A):
        reveal_type(x)  # N: Revealed type is "list[str] | <subclass of "__main__.B" and "__main__.A">"
    else:
        reveal_type(x)  # N: Revealed type is "__main__.B"

[case self_assignment_does_not_narrow]
class A:
    x: int | str
class B(A):
    def __init__(self) -> None:
        self.x = 1
reveal_type(B().x)  # N: Revealed type is "int | str"

[case finished_dict_overwrite]
# flags: --local-partial-types --disallow-untyped-globals

x = {}  # E: Need type annotation for "x" (hint: "x: Dict[<type>, <type>] = ...")

def foo() -> None:
    global x
    if bool():
        x = {1: 2}
    reveal_type(x) # N: Revealed type is "dict[Any, Any]"

[case dict_overwrite_twice_with_walrus]
x = {}
x = (x := {1: 2})
reveal_type(x) # N: Revealed type is "dict[int, int]"

[case set_overwrite]
x = set()
if bool():
    x = {1, 2}
reveal_type(x) # N: Revealed type is "set[int]"

[case module_mutual_flow_analysis1]
import a

[file a.py]
# Note: imports cycle
from b import b
if bool():
    a = int()
else:
    b + 1

[file b.py]
from a import a  # E: Cannot determine type of "a"
if bool():
    b = int()
else:
    a + 1

[case module_mutual_flow_analysis2]
import a

[file a.py]
from b import b as x
if bool():
    a = int()
else:
    x + 1

[file b.py]
from a import a as y  # E: Cannot determine type of "a"
if bool():
    b = int()
else:
    y + 1

[case module_mutual_flow_analysis3]
# flags: --warn-unreachable
import a
[file a.py]
from b import b as x
class A: ...
if isinstance(x, A):
    reveal_type(x)  # N: Revealed type is "<subclass of "b.B" and "a.A">"
    a = int()
else:
    x + 1  # E: Unsupported operand types for + ("B" and "int")

[file b.py]
from a import a as y, A  # E: Cannot determine type of "a"
class B: ...
if isinstance(y, B):
    reveal_type(y)  # N: Revealed type is "b.B"
    b = y
else:
    y + 1

[case module_mutual_flow_analysis4]
# Mypy errors are similar but not exactly the same
import a
[file a.py]
if bool():
    a = b  # E: Name "b" is used before definition
else:
    a = 1
from b import b
reveal_type(b)  # N: Revealed type is "Any"

[file b.py]
if bool():
    b = a  # E: Name "a" is used before definition
else:
    b = a  # E: Name "a" is used before definition
from a import a  # E: Cannot resolve name "a" (possible cyclic definition)
reveal_type(b)  # N: Revealed type is "Any"

[case module_mutual_flow_analysis5]
# flags: --warn-unreachable
import a
[file a.py]
from b import b
if b is None:
    a = None
else:
    a = 1
reveal_type(b)  # N: Revealed type is "Any | None"

[file b.py]
if a is None:  # E: Name "a" is used before definition
    b = None
else:
    b = a  # E: Name "a" is used before definition
from a import a  # E: Cannot determine type of "a"
reveal_type(b)  # N: Revealed type is "Any | None"

[case module_mutual_flow_analysis6]
# flags: --warn-unreachable
import a
[file a.py]
from b import b
if b is None:
    a = None
else:
    a = 1
reveal_type(b)  # N: Revealed type is "Any | None"

[file b.py]
from a import a  # E: Cannot determine type of "a"
if a is None:
    b = None
else:
    b = a
reveal_type(b)  # N: Revealed type is "Any | None"

[case module_mutual_flow_analysis7]
# flags: --warn-unreachable
import a
reveal_type(a.foo)  # N: Revealed type is "int | None"
[file a.py]
if bool():
    bar = None
else:
    bar = 1
foo = bar
reveal_type(foo)  # N: Revealed type is "int | None"

[case func_call_should_not_narrow_eagerly]
# flags: --warn-unreachable
x: str | int
x = 1
def foo() -> str:
    reveal_type(x)  # N: Revealed type is "str | int"
    return ""

if bool():
    x = foo()
foo()

[case self_access_should_not_narrow_eagerly]
# flags: --warn-unreachable
x: str | int
x = 1
class A:
    def __init__(self) -> None:
        reveal_type(x)  # N: Revealed type is "str | int"
        self.z = 3

if bool():
    A().z
x = ""
A().z

[case access_self_variable_before_definition_no_mypy_compatible]
# flags: --no-mypy-compatible
# This is supported by Mypy (many tests cover it), but we should probably
# suppress this kind of pattern of accessing members before definition.
x: A
x.z  # E: Cannot determine type of "z"
class A:
    def __init__(self) -> None:
        self.z = 3


[case final_with_getitem_in_loop]
# Like testFinalNotInLoops but instead of Final we use Final[int]
from typing import Final

for i in [1, 2, 3]:
    x: Final[int] = i  # E: Cannot use Final inside a loop

while True:
    y: Final[bool] = True  # E: Cannot use Final inside a loop

[case final_reassignment_in_init]
# Like testFinalDelayedDefinition, but not delayed
from typing import Final

class C:
    x: Final[int] = 2  # OK, defined in __init__

    def __init__(self, x: int) -> None:
        self.x = 2  # E: Cannot assign to final attribute "x"

[case self_access_before_assignment1]
class A:
    def __init__(self) -> None:
        self.x = 2

class B(A):
    def __init__(self) -> None:
        super().__init__()
        reveal_type(self.x)  # N: Revealed type is "int"
        self.x = 2

[case self_access_before_assignment2]
class A:
    x: int

class B(A):
    def __init__(self) -> None:
        super().__init__()
        reveal_type(self.x)  # N: Revealed type is "int"
        self.x = 2

[case self_access_before_assignment3]
from typing import TypeVar, Generic

T = TypeVar("T")
class A(Generic[T]):
    def foo(self: A[int]) -> int: ...

class B(A[str]):
    def __init__(self) -> None:
        reveal_type(self.foo)  # E: Invalid self argument "B" to attribute function "foo" with type "Callable[[A[int]], int]" \
                               # N: Revealed type is "def () -> int"
        self.foo = lambda: 1  # E: Invalid self argument "B" to attribute function "foo" with type "Callable[[A[int]], int]" \
                              # E: Property "foo" defined in "A" is read-only
        reveal_type(self.foo)  # N: Revealed type is "def () -> Literal[1]?"

    def bar(self) -> None:
        reveal_type(self.foo)  # N: Revealed type is "def () -> int"

[case sys_version_defined_smaller_than]
import sys
if sys.version_info < (3, 200):
    undefined # E: Name "undefined" is not defined
if sys.version_info > (3, 200):
    undefined
if sys.version_info > (3, 1):
    undefined # E: Name "undefined" is not defined
if sys.version_info < (2, 200):
    undefined
if sys.version_info > (2, 200):
    undefined # E: Name "undefined" is not defined

[case sys_version_slice_defined_smaller_than]
import sys
if sys.version_info[:2] < (3, 200):
    undefined # E: Name "undefined" is not defined
if sys.version_info[:2] > (3, 200):
    undefined
if sys.version_info[:2] > (3, 1):
    undefined # E: Name "undefined" is not defined
if sys.version_info[:2] < (2, 200):
    undefined
if sys.version_info[:2] > (2, 200):
    undefined # E: Name "undefined" is not defined

[case not_narrowing]
# flags: --warn-unreachable
reveal_type(not str())  # N: Revealed type is "bool"
reveal_type(1 and not str())  # N: Revealed type is "bool"
reveal_type(1 or not str())  # E: Right operand of "or" is never evaluated # N: Revealed type is "Literal[1]?"
reveal_type(not 1 or not str())  # N: Revealed type is "bool"
x = 1
reveal_type(x and not str())  # N: Revealed type is "Literal[0] | bool"
reveal_type(x or not str())  # N: Revealed type is "int"
reveal_type(not x or not str())  # N: Revealed type is "bool"

[case with_unpack_tuple_in_isinstance]
from typing import TypeVarTuple, Any

Ts = TypeVarTuple("Ts")
def foo(
        x1: tuple[type[int], *tuple[type[bytes], ...], type[str]],
        x2: tuple[type[int], *tuple[type[int], ...]],

        x3: tuple[type[int], *Ts, type[str]],
        x4: tuple[int, *tuple[type[bytes], ...], type[str]],
        y: Any,
        ) -> None:
    if isinstance(y, x1):
        reveal_type(y)  # N: Revealed type is "int | str | bytes"
    if isinstance(y, x2):
        reveal_type(y)  # N: Revealed type is "int"

    if isinstance(y, x3):  # E: Argument 2 to "isinstance" has incompatible type "tuple[type[int], Unpack[Ts], type[str]]"; expected "type[Any] | UnionType | tuple[_ClassInfo, ...]"
        reveal_type(y)  # N: Revealed type is "Any"
    if isinstance(y, x4):  # E: Argument 2 to "isinstance" has incompatible type "tuple[int, Unpack[Tuple[type[bytes], ...]], type[str]]"; expected "type[Any] | UnionType | tuple[_ClassInfo, ...]"
        reveal_type(y)  # N: Revealed type is "Any"

[case comprehension_if_complex_narrowing]
class Foo:
    x: int

def foo(lst) -> None:
    a = [
        reveal_type(obj).x  # N: Revealed type is "def () -> __main__.Foo"
        for obj in lst
        if isinstance(obj, type)
        and issubclass(obj, Foo)
        and obj is not Foo
    ]
    reveal_type(a)  # N: Revealed type is "list[int]"

[case self_vars_narrowed]
class B:
    x: int = 1

class Foo1:
    b: B | None = None
    y: int

    def __init__(self) -> None:
        self.b = B()

    def foo(self) -> None:
        if self.b:
            self.y = self.b.x

    def bar(self) -> None:
        self.y = 1

class Foo2:
    b: B | None = None
    y: int

    def __init__(self) -> None:
        self.b = B()

    def bar(self) -> None:
        self.y = 1

    def foo(self) -> None:
        if self.b:
            self.y = self.b.x

[case context_for_self_var_should_prefer_class]
class Foo1:
    x: list[int | str]

    def __init__(self) -> None:
        self.x = [1]

    def bar(self) -> None:
        self.x = [""]

class Foo2:
    x: list[int | str]

    def __init__(self) -> None:
        self.x = [""]

    def bar(self) -> None:
        self.x = [1]

[case narrowing_should_work_in_comprehensions_after_conjunction]
def foo(x: list[int] | None) -> None:
    x is not None and any(a for a in x)
    x is not None and any([a for a in x])

[case narrowing_negative_literal]
class A:
    x = 1
class B(A):
    y = 1

def foo(a: list[A]) -> None:
    if isinstance(a[-1], B):
        a[-1].x
        a[-1].y

[case extend_narrowed_any_list1]
from typing import Any
def foo(item: Any) -> None:
    mark_list = []
    if isinstance(item, list):
        mark_list.extend(item)
    reveal_type(mark_list)  # N: Revealed type is "list[Any]"

[case extend_narrowed_any_list2]
from typing import Any, TypeVar
T = TypeVar("T")

class Setlist(list[set[T]]): ...
def foo(item: Any) -> None:
    mark_list = []
    if isinstance(item, Setlist):
        mark_list.extend(item)
    reveal_type(mark_list)  # N: Revealed type is "list[set[Any]]"

[case context_for_ternary_else]
class Y:
    x = 1

class X(Y):
    def f(self) -> None:
        x = [1] if bool() else []
        reveal_type(x)  # N: Revealed type is "list[int]"

[case tuple_assign_none]
x, y = None, None
if bool():
    x = 1
    y = ""
reveal_type(x)  # N: Revealed type is "int | None"

[case narrow_in_closure]
def foo(x: int | None = None) -> None:
    def closure() -> bool:
        if x is not None:
            return x + 1 == 1
        return True

    closure()

[case narrow_global_var]
x: int | None = None

def foo() -> None:
    if x is not None:
        x + 1 == 1

[case narrowed_aug_assign]
def foo(x: dict[str, object]) -> None:
    if "foo" in x:
        assert isinstance(x["foo"], str)
        x["foo"] += "-a"

[case narrow_widen_narrow_in_if]
def foo(x: int | None, other: int | None = None) -> int:
    if x is None:
        x = other
        assert x is not None
    return x

[case narrow_isinstance_int_and_bool]
def foo(x: complex, y: int | bool | str) -> None:
    if isinstance(y, int):
        reveal_type(y)  # N: Revealed type is "int"
        x + y

[case assert_isinstance_of_type_of_type_var]
from typing import TypeVar, Any

T = TypeVar("T")

def foo(x: T, y: Any) -> T:
    assert isinstance(y, type(x))
    return y

[case assert_isinstance_of_type_of_type_var]
from typing import TypeVar, Any

T = TypeVar("T")

def foo(x: T, y: Any) -> T:
    assert isinstance(y, type(x))
    return y

[case or_context]
x = {1} or set()
y: set[int] = {1} or set()

[case self_context_should_not_be_narrowed]
class Foo:
    def __init__(self) -> None:
        self.x: set[int] | None = None

    def foo(self) -> None:
        if self.x is None:
            self.x = set()

[case narrowing_or_with_bools]
def foo(z: str, w: bool, u: bool) -> bool:
    return z and w or u

def bar(z: str, w: bool, u: bool) -> bool:
    return (z and w) or u

def baz(z: str, w: bool, u: bool) -> bool:
    return (z or w) and u

[case issubclass_intersection_attributes]
class A:
    a = 1
    def __init__(self) -> None:
        self.c = 1
class B: b = 1

def f(x: type[A]):
    if issubclass(x, B):
        reveal_type(x.a)  # N: Revealed type is "int"
        reveal_type(x.b)  # N: Revealed type is "int"
        x.c  # E: "<subclass of "__main__.A" and "__main__.B">" has no attribute "c"
        x.d  # E: "<subclass of "__main__.A" and "__main__.B">" has no attribute "d"

[case try_stmt_except_type]
from typing import TypeVarTuple, Any
Ts = TypeVarTuple("Ts")

def f(a: Any, x: tuple[type[ValueError], *Ts], y: tuple[type[TypeError], *tuple[type[NotImplementedError], ...], type[ValueError]]):
    try:
        ...
    except x as a:  # E: Exception type must be derived from BaseException (or be a tuple of exception classes)
        reveal_type(a)  # N: Revealed type is "Any"

    try:
        ...
    except y as b:
        reveal_type(b)  # N: Revealed type is "TypeError | NotImplementedError | ValueError"

[case should_not_narrow_any]
from typing import Any

def f(x: Any) -> None:
    x = 1
    reveal_type(x)  # N: Revealed type is "Any"
    for x in [1]:
        reveal_type(x)  # N: Revealed type is "Any"

[case isinstance_any_narrowing_with_reassignment]
# flags: --warn-unreachable
from typing import Any
def foo(x: Any, y: Any):
    if isinstance(x, str):
        x = y
        if x is None:
            reveal_type(x)  # N: Revealed type is "None"
        reveal_type(x)  # N: Revealed type is "Any"
    reveal_type(x)  # N: Revealed type is "Any"

[case callable_intersection_with_class_twice]
class A:
    a: int
class B:
    b: int
def foo(x: A):
    if callable(x):
        x.a
        x.b  # E: "<callable subtype of A>" has no attribute "b"
        if isinstance(x, B):
            x.a
            x.b
            x.undefined  # E: "<subclass of "def (*Any, **Any) -> Any", "__main__.A", and "__main__.B">" has no attribute "undefined"
            # callable introduces Any unfortunately :(
            x(1)
            x(undefined=3)

[case isinstance_on_generic_inherited_with_access1]
from typing import Generic, TypeVar, Any

T = TypeVar('T')

class Base(Generic[T]):
    def __init__(self, c: T):
        self.base_attr = c

class Super(Base[list[T]]):
    def __init__(self, c: T) -> None:
        super().__init__([c])
        self.attr = int()

class Sub(Super[int]): ...

def f(x: Any):
    if issubclass(x, Sub):
        reveal_type(x)  # N: Revealed type is "def (c: int) -> __main__.Sub"

    if isinstance(x, Sub):
        reveal_type(x) # N: Revealed type is "__main__.Sub"
        x.attr
        reveal_type(x.base_attr)  # N: Revealed type is "list[int]"

    if issubclass(x, Super):
        reveal_type(x)  # N: Revealed type is "def [T] (c: T) -> __main__.Super[T]"

    if isinstance(x, Super):
        reveal_type(x) # N: Revealed type is "__main__.Super"
        x.attr
        reveal_type(x.base_attr)  # N: Revealed type is "list[Any]"

[case isinstance_on_generic_inherited_with_access2]
from m import Super

def f(m) -> None:
    if isinstance(m, Sub):
        m.x

class Sub(Super[int]): ...

[file m.py]
from typing import Generic, TypeVar

T = TypeVar("T")

class Base(Generic[T]):
    def __init__(self, x: T):
        self.x = x

class Super(Base[T]):
    x: T

[case issubclass_with_union_type]
class A: ...
class B: ...
class C: ...
def f(x: type[A | B]):
    if issubclass(x, C):
        reveal_type(x)  # N: Revealed type is "type[<subclass of "__main__.C" and "__main__.A"> | <subclass of "__main__.C" and "__main__.B">]"

[case narrowing_with_key_in_different_file]
import m

def f(x: dict[str, tuple[int] | tuple[str, int]]) -> None:
    assert len(x["a"]) == 2
    reveal_type(x["a"])  # N: Revealed type is "tuple[str, int]"
    x[m.S1]

[file m.py]
S1 = "hello"

[case isinstance_with_type_of_something_with_any_generics]
# flags: --show-error-codes
from typing import Any, Tuple

x = tuple([Tuple, set])
reveal_type(x)  # Revealed types is "tuple[type[typing.Collection[Any]], ...]"

def f(value: Any) -> bool:
    return isinstance(value, x)

[case narrowing_with_simple_type_var_fallback]
from typing import overload, Protocol

def r1[T](x: T) -> T: ...

def f1(x: int | None, default):
    if x is None:
        x = r1(default)
    reveal_type(x)  # N: Revealed type is "int | Any"

def r2[T](x: list[T]) -> T: ...

def f2(x: int | None, default):
    if x is None:
        x = r2(default)
    reveal_type(x)  # N: Revealed type is "int | Any"

[case unreachable_end_position]
# flags: --warn-unreachable --show-error-end --show-column-numbers
def x() -> None:
    return
    if str():
        bool()

    bool()

[out]
__main__:4:5:5:15: error: Statement is unreachable

[case except_var_deleted_after_scope]
try:
    try:
        ...
    except Exception as err:
        print(err)
except Exception as err:
    print(err)
err  # E: Trying to read deleted variable "err"

[case async_narrowing]
# See GH #94
class A:
    async def foo(self) -> int | None:
        return 3

class B:
    async def foo(self) -> str | None:
        return "3"

async def test(cls: A | B) -> int | str:
    result = reveal_type(await cls.foo())  # N: Revealed type is "int | None | str"
    if result is None:
        return 0
    return reveal_type(result)  # N: Revealed type is "int | str"
