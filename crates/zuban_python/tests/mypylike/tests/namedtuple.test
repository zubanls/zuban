[case namedtuple__new__]

from typing import NamedTuple
class A(NamedTuple):
    x: int

reveal_type(A.__new__)  # N: Revealed type is "?"
reveal_type(A(1).__new__)  # N: Revealed type is "?"

reveal_type(A.__new__(A, 1))  # N: Revealed type is "A"
reveal_type(A(1).__new__(A, 1))  # N: Revealed type is "A"

[case namedtuple_type_used_as_callable]
from typing import NamedTuple, Generic, Callable, ParamSpec, TypeVar

P = ParamSpec("P")
T = TypeVar("T")

class Foo(NamedTuple):
    a: int = 1
class Bar(NamedTuple, Generic[T]):
    a: T

Baz = NamedTuple("Baz", [('x', int)])

def identity(x: Callable[P, T]) -> Callable[P, T]:
    return x

reveal_type(identity(Foo)) # N: Revealed type is "def (a: int =) -> tuple[int, fallback=__main__.Foo]"
reveal_type(identity(Bar)) # N: Revealed type is "def [T] (a: T) -> tuple[T, fallback=__main__.Bar[T]]"
reveal_type(identity(Baz)) # N: Revealed type is "def (x: int) -> tuple[int, fallback=__main__.Baz]"

[case namedtuple_replace_on_inherited_class]
from typing import NamedTuple

class Foo(NamedTuple):
    a: int

class Bar(Foo): ...

b: Bar
Bar._replace(b, c=3) # E: Unexpected keyword argument "c" for "_replace" of "Foo"
reveal_type(Bar._replace(b, a=3)) # N: Revealed type is "tuple[int, fallback=__main__.Bar]"

b._replace(c=3) # E: Unexpected keyword argument "c" for "_replace" of "Foo"
reveal_type(b._replace(a=3)) # N: Revealed type is "tuple[int, fallback=__main__.Bar]"

[case namedtuple_make_on_inherited_class]
from typing import NamedTuple

class Foo(NamedTuple):
    a: int

class Bar(Foo): ...

b: Bar
reveal_type(Bar._make([])) # N: Revealed type is "tuple[int, fallback=__main__.Bar]"
reveal_type(b._make([])) # N: Revealed type is "tuple[int, fallback=__main__.Bar]"

[case namedtuple_generic_call_form_in_class]
from typing import NamedTuple, TypeVar, Generic

T = TypeVar("T")
S = TypeVar("S")

class Foo(Generic[S]):
    def foo(self, s: S) -> None:
        NT = NamedTuple("NT", [("key", S), ("value", T)])
        reveal_type(NT)  # N: Revealed type is "def [T] (key: S, value: T) -> tuple[S, T, fallback=__main__.NT]"

        wrong_count: NT[int, str] # E: Bad number of arguments for type alias, expected 1, given 2

        nt_any: NT
        reveal_type(nt_any)  # N: Revealed type is "tuple[S, Any, fallback=__main__.NT]"
        nts: NT[str]
        reveal_type(nts)  # N: Revealed type is "tuple[S, str, fallback=__main__.NT]"

        NT[int](key=1, value=1)  # E: Argument "key" to "NT" has incompatible type "int"; expected "S"
        NT[int](key=s, value=1)

[case functional_namedtuple_attributes_are_readonly]
# Like testTypingNamedTupleAttributesAreReadOnly but with functional namedtuples
from typing import NamedTuple, Protocol

class HasX(Protocol):
    x: str

A = NamedTuple("A", [('x', str)])

a: HasX = A("foo")  # E: Incompatible types in assignment (expression has type "A", variable has type "HasX") \
                    # N: Protocol member HasX.x expected settable variable, got read-only attribute
a.x = "bar"

[case namedtuple_iter_of_generic]
from typing import NamedTuple, Generic, TypeVar

T = TypeVar("T")
class A(NamedTuple, Generic[T]):
    val: T

a: A[int]
for x in a:
    reveal_type(x)  # N: Revealed type is "int"

[case namedtuple_generic_matching]
from typing import NamedTuple, Generic, TypeVar

T = TypeVar("T")
N = NamedTuple("N", [('t', T)])

def f1(n1: N[int], n2: N[int]) -> None:
    n1 = n2

def f2(n1: N, n2: N) -> None:
    n1 = n2

def f3(n1: N[int], n2: N[str]) -> None:
    n1 = n2  # E: Incompatible types in assignment (expression has type "N", variable has type "N")

[case namedtuple_invalid_init]
from typing import NamedTuple
from collections import namedtuple

x = NamedTuple()  # E: Too few arguments for "NamedTuple()"
y = namedtuple()  # E: Too few arguments for "namedtuple()"

A = NamedTuple("A", *[{}])  # E: List or tuple literal expected as the second argument to "NamedTuple()"
B = namedtuple("B", *[{}])  # E: List or tuple literal expected as the second argument to "namedtuple()"

C = NamedTuple("C", lambda: 1)  # E: List or tuple literal expected as the second argument to "NamedTuple()"
D = namedtuple("D", lambda: 1)  # E: List or tuple literal expected as the second argument to "namedtuple()"

str_lst = ['']
E = namedtuple("E", [*str_lst])  # E: String literal expected as "namedtuple()" item

F = namedtuple("F", f'x, {1}')  # E: List or tuple literal expected as the second argument to "namedtuple()"

[case disallow_deleting_namedtuple_field]
from typing import NamedTuple
from collections import namedtuple
class Point1(NamedTuple):
    x: int

p = Point1(1)
del p.x  # E: NamedTuple attributes cannot be deleted
del p[0]  # E: "Point1" has no attribute "__delitem__"

Point2 = NamedTuple("Point2", [('x', int)])

q = Point2(1)
del q.x  # E: NamedTuple attributes cannot be deleted
del q[0]  # E: "Point2" has no attribute "__delitem__"

Point3 = namedtuple("Point3", ('x', 'y'))

r = Point3(1, 2)
del r.x  # E: NamedTuple attributes cannot be deleted
del r[0]  # E: "Point3" has no attribute "__delitem__"

[case disallow_subclassing_of_named_tuple_and_overwriting_attr]
# Copied in parts from conformance tests (namedtuples_define_class.py)
from typing import NamedTuple
class Point(NamedTuple):
    x: int
    y: int
    units: str = "meters"

class PointWithName(Point):
    name: str = ""  # OK

class BadPointWithName(Point):
    name: str = ""  # OK
    x: int = 0  # E: Cannot override namedtuple attr

[case namedtuple_attribute_from_conformance_tests]
# flags: --no-mypy-compatible
# Copied from conformance tests (namedtuples_define_class.py)
from typing import NamedTuple
class Point2(NamedTuple):
    x: int
    y: int
    units = "meters"  # Not a field

    def is_origin(self) -> int:  # Not a field
        return self.x == 0 and self.y == 0

[case named_tuple_overwrite_of_attribute_in_inheritance_invalid]
# Copied from conformance tests (namedtuples_define_class.py)
from typing import NamedTuple
class Point(NamedTuple):
    x: int
    y: int
    units: str = "meters"

class BadPointWithName(Point):
    name: str = ""  # OK
    x: int = 0  # E: NamedTuple attributes cannot be overridden in subclasses

[case named_tuple_with_final_field_name]
from typing import NamedTuple, Final
# Copied from conformance tests (qualifiers_final_annotation.py)
X: Final = "x"
Y: Final = "y"
N = NamedTuple("N", [(X, int), (Y, int)])

N(x=3, y=4)  # OK
N(a=1)  # E: Unexpected keyword argument "a" for "N"
N(x="", y="")  # E: Argument "x" to "N" has incompatible type "str"; expected "int" \
               # E: Argument "y" to "N" has incompatible type "str"; expected "int"

[case named_tuple_with_literal_field_name]
from typing import NamedTuple, Final, Literal
X: Literal['x'] = "x"
Y: Final[Literal['y']] = "y"
N = NamedTuple("N", [(X, int), (Y, int)])

N(x=3, y=4)  # OK
N(a=1)  # E: Unexpected keyword argument "a" for "N"
N(x="", y=1)  # E: Argument "x" to "N" has incompatible type "str"; expected "int"
