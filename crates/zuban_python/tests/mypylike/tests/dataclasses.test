[case dataclass_any_inherited_nested]
# Checks issues of testDataclassesAnyInherit but with additional inheritance
from dataclasses import dataclass
from typing import Any
A: Any
@dataclass
class B(A):
    a: int

@dataclass
class C(B):
    b: str

reveal_type(C) # N: Revealed type is "def (a: int, b: str, *Any, **Any) -> __main__.C"
C(a=1, b="", c=2)
C(1, 1)  # E: Argument 2 to "C" has incompatible type "int"; expected "str"
C(a="foo", b="")  # E: Argument "a" to "C" has incompatible type "str"; expected "int"

[case dataclass_method_binding1]
from dataclasses import dataclass
from typing import Self

@dataclass
class A:
    x: int

    def foo(self) -> Self:
        return self

class B(A):
    y: int

x = B(1).foo()
reveal_type(x)  # N: Revealed type is "__main__.B"
type(x)(x=3)

y = B.foo(A(1))
type(y)(x=3)
z = B.foo(B(1))
type(z)(x=3)

[case dataclass_method_binding2]
from dataclasses import dataclass
from typing import Self

@dataclass
class A:
    x: int

    def foo(self) -> Self:
        return self

@dataclass
class B(A):
    y: int

x = B(1, 2).foo()
reveal_type(x)  # N: Revealed type is "__main__.B"
type(x)(x=3, y=4)

y = B.foo(A(1))
type(y)(x=3)
z = B.foo(B(1, 2))
type(z)(x=3, y=2)

a = A.foo(A(1))
reveal_type(a)  # N: Revealed type is "__main__.A"
type(a)(x=3)

[case dataclass_inheritance_method_generics_with_normal_class]
from typing import TypeVar, Generic, List
from dataclasses import dataclass

T = TypeVar("T")

@dataclass
class A(Generic[T]):
    x: T

    def foo(self) -> T: return self.x

class B(A[T]):
    y: str

b: B[str]
reveal_type(b.foo())  # N: Revealed type is "str"
x = B(1)
reveal_type(x)  # N: Revealed type is "__main__.B[int]"
reveal_type(x.foo())  # N: Revealed type is "int"

class C(A[List[T]]): ...

C(1)  # E: Argument 1 to "C" has incompatible type "int"; expected "list[Never]"
y = C([1])
reveal_type(y.foo())  # N: Revealed type is "list[int]"

[case dataclass_inheritance_method_generics_with_dataclass]
from typing import TypeVar, Generic, List
from dataclasses import dataclass

T = TypeVar("T")

@dataclass
class A(Generic[T]):
    x: T

    def foo(self) -> T: return self.x

@dataclass
class B(A[T]):
    y: str

b: B[str]
reveal_type(b.foo())  # N: Revealed type is "str"
x = B(1, "")
reveal_type(x)  # N: Revealed type is "__main__.B[int]"
reveal_type(x.foo())  # N: Revealed type is "int"

@dataclass
class C(A[List[T]]):
    y: str

C(1, "")  # E: Argument 1 to "C" has incompatible type "int"; expected "list[Never]"
y = C([1], "")
reveal_type(y.foo())  # N: Revealed type is "list[int]"

[case dataclass_inheritance_method_generics_with_dataclass_no_init]
from typing import TypeVar, Generic, List
from dataclasses import dataclass

T = TypeVar("T")

@dataclass
class A(Generic[T]):
    x: T

    def foo(self) -> T: return self.x

@dataclass(init=False)
class B(A[T]):
    y: str

b: B[str]
reveal_type(b.foo())  # N: Revealed type is "str"
x = B(1)
reveal_type(x)  # N: Revealed type is "__main__.B[int]"
reveal_type(x.foo())  # N: Revealed type is "int"

@dataclass(init=False)
class C(A[List[T]]):
    y: str

C(1)  # E: Argument 1 to "C" has incompatible type "int"; expected "list[Never]"
y = C([1])
reveal_type(y.foo())  # N: Revealed type is "list[int]"

[case dataclass_self_in_inheritance]
from typing import Self
from dataclasses import dataclass

@dataclass
class A:
    x: int

    def foo(self) -> Self: return self

@dataclass()
class B(A):
    y: str

x = B(1, "").foo()
reveal_type(x)  # N: Revealed type is "__main__.B"
type(x)(2, "")
type(x)(2, 2)  # E: Argument 2 to "B" has incompatible type "int"; expected "str"

class C(A):
    y: str

y = C(1)
reveal_type(y)  # N: Revealed type is "__main__.C"
type(y)("")  # E: Argument 1 to "C" has incompatible type "str"; expected "int"
type(y)(1)

[case generic_dataclass_used_in_annotation]
from typing import TypeVar, Generic
from dataclasses import dataclass

T = TypeVar("T")

@dataclass
class D(Generic[T]):
    foo: T
def foo(x: D[int]) -> None:
    reveal_type(x.foo)  # N: Revealed type is "int"

[case dataclass__call__]
from dataclasses import dataclass

@dataclass
class A:
    x: int

    def __call__(self, x: int) -> None: ...

A(1)()  # E: Missing positional argument "x" in call to "__call__" of "A"
A(1)(1)

[case dataclass_invalid_options]
from dataclasses import dataclass
def f(b: bool):
    @dataclass(init=b)  # E: "init" argument must be a True or False literal
    class B:
        y: str

    @dataclass(**{'undefined': b})  # E: Unexpected argument to "dataclass()"
    class C:
        y: str

[case dataclass_invalid_field_options]
from dataclasses import dataclass, field

def f(b: bool):
    @dataclass
    class B:
        y: str = field(init=b)  # E: "init" argument must be a True or False literal
        z: str = field(kw_only=b)  # E: "kw_only" argument must be a True or False literal

[case dataclass_post_init_invalid_self_type_override]
from typing import TypeVar, Generic, List
from dataclasses import dataclass

T = TypeVar("T")

@dataclass
class A(Generic[T]):
    x: T

    def __post_init__(self: A[int]) -> None: ...  # E: Invalid self argument "Self" to attribute function "__post_init__" with type "Callable[[A[int]], None]"
    def y(self: A[int]) -> None: ...

[case dataclass_init_with_self_type]
from typing import TypeVar, Generic, overload, Any
from dataclasses import dataclass

T = TypeVar("T")

@dataclass()
class C(Generic[T]):
    lower: T
    upper: T
    what: bool

    def __repr__(self) -> str:
        return f"VR[{self.lower}, {self.upper}]"

    def __init__(self: C[int], lower: T, upper: T) -> None: ...

reveal_type(C(1, 1))  # N: Revealed type is "__main__.C[int]"
reveal_type(C('', ''))  # E: Argument 1 to "C" has incompatible type "str"; expected "int" \
                        # E: Argument 2 to "C" has incompatible type "str"; expected "int" \
                        # N: Revealed type is "__main__.C[Any]"

[case dataclass_init_with_self_type_overloaded]
from typing import TypeVar, Generic, overload, Any
from dataclasses import dataclass

T = TypeVar("T")

@dataclass()
class C(Generic[T]):
    lower: T
    upper: T
    what: bool

    def __repr__(self) -> str:
        return f"VR[{self.lower}, {self.upper}]"

    @overload
    def __init__(self: C[int], lower: int, upper: int) -> None: ...
    @overload
    def __init__(self: C[str], lower: str, upper: str) -> None: ...
    def __init__(self, lower: Any, upper: Any) -> None: ...

reveal_type(C(1, 1))  # N: Revealed type is "__main__.C[int]"
reveal_type(C('', ''))  # N: Revealed type is "__main__.C[str]"

[case custom_dataclass_stubs]
from dataclasses import dataclass

@dataclass
class A:
    x: int

A(1)
A(x=1)
A(1, y=1)  # E: Unexpected keyword argument "y" for "A"

[file dataclasses-stubs/__init__.pyi]
from typing import Any
def dataclass(cls: type[Any], /) -> type[Any]: ...

[case dataclass_descriptor_call]
from dataclasses import dataclass

class MyDescriptor:
    def __get__(self, obj: object | None, owner) -> "int | MyDescriptor": ...
    def __set__(self, obj: object | None, value: int) -> None: ...

@dataclass
class Foo:
    x: MyDescriptor
    y: MyDescriptor = MyDescriptor()

Foo(3, 3)  # E: Argument 1 to "Foo" has incompatible type "int"; expected "MyDescriptor"
Foo(MyDescriptor(), MyDescriptor())  # E: Argument 2 to "Foo" has incompatible type "MyDescriptor"; expected "int"
f = Foo(MyDescriptor(), 3)  # Currently a false positive error in pyright (and mypy)

f.y = 4

reveal_type(f.y)  # N: Revealed type is "int | __main__.MyDescriptor"
reveal_type(Foo.y)  # N: Revealed type is "int | __main__.MyDescriptor"

[case dataclass_with_or_should_not_panic]
from dataclasses import dataclass

@dataclass()
class Foo(): ...

Bar = Foo | int

[case dataclass_transform_metaclass_with_dataclass_inheritance1]
# flags: --python-version 3.11

from typing import dataclass_transform, overload, Any
from dataclasses import dataclass

@dataclass_transform()
class Metaclass(type): ...

class C(metaclass=Metaclass):
    x: int

@dataclass
class D(C):
    y: str

D()  # E: Missing positional arguments "x", "y" in call to "D"
d = D(1, "")
d.x
d.y
d.z  # E: "D" has no attribute "z"

[case dataclass_transform_metaclass_with_dataclass_inheritance2]
from typing import dataclass_transform, overload, Any
from dataclasses import dataclass

@dataclass_transform()
class Metaclass(type): ...

# This is a special case and it should probably just not crash
@dataclass
class C(Metaclass):
    x: int

C(1)
C()  # E: Missing positional argument "x" in call to "C"

@dataclass
class D(C):
    y: str

D()  # E: Missing positional arguments "x", "y" in call to "D"
d = D(1, "")
d.x
d.y
d.z  # E: "D" has no attribute "z"

[case dataclass_transform_invalid_arg]
from typing import dataclass_transform, overload, Any
from dataclasses import dataclass

@dataclass_transform(1)  # E: Unexpected argument to "dataclass_transform()"
class M1(type): ...

@dataclass_transform(*(1,))  # E: Unexpected argument to "dataclass_transform()"
class M2(): ...

@dataclass_transform(**dict(eq_default=True))  # E: Unexpected argument to "dataclass_transform()"
class M3(): ...

@dataclass_transform(**{'eq_default': True })  # E: Unexpected argument to "dataclass_transform()"
class M4(): ...

[case dataclass_transform_post_init_access]
from typing import dataclass_transform
from dataclasses import dataclass

@dataclass_transform()
class Meta(type): ...

class C(metaclass=Meta):
    key: str

class D(C):
    def __post_init__(self) -> None:
        super().__post_init__  # E: "__post_init__" undefined in superclass

@dataclass()
class E(C):
    def __post_init__(self) -> None:
        # TODO this is not correct, because it's wrapped as a dataclass again
        super().__post_init__  # E: "__post_init__" undefined in superclass

[case dataclass_transform_in_wrong_place]
from typing import dataclass_transform
# This is not correct, but for now we don't support it in a better way
reveal_type(dataclass_transform())  # N: Revealed type is "object"

[case dataclass_transform_wrong_args]
from typing import dataclass_transform, Any
@dataclass_transform(order_default=True)
def foo(x: int) -> Any: ...

@foo(order=False)  # E: Unexpected keyword argument "order" for "foo"
class D:
    x: int

[case dataclass_transform_on_first_overload]
# Copied from testDataclassTransformOverloadsDecoratorOnOverload, but with
# dataclass_transform on first overload
from typing import dataclass_transform, overload, Callable, Type

@dataclass_transform(frozen_default=True)
@overload
def my_dataclass(*, foo: str) -> Callable[[Type], Type]: ...
@overload
def my_dataclass(*, foo: int) -> Callable[[Type], Type]: ...
def my_dataclass(*, foo) -> Callable[[Type], Type]:
    return lambda cls: cls
@my_dataclass(foo="hello")
class A:
    a: int
@my_dataclass(foo=5)
class B:
    b: int

reveal_type(A)  # N: Revealed type is "def (a: int) -> __main__.A"
reveal_type(B)  # N: Revealed type is "def (b: int) -> __main__.B"
A(1, "hello")  # E: Too many arguments for "A"
a = A(1)
a.a = 2  # E: Property "a" defined in "A" is read-only

[case dataclass_transform_on_overload_with_reassignment]
from typing import dataclass_transform, overload, Callable, Type

@dataclass_transform(frozen_default=True)
@overload
def my_dataclass(*, foo: str) -> Callable[[Type], Type]: ...
@overload
def my_dataclass(*, foo: int) -> Callable[[Type], Type]: ...
def my_dataclass(*, foo) -> Callable[[Type], Type]: ...

# This needs to work, because attrs uses something like this
reassignment = other = my_dataclass

@reassignment(foo="hello")
class A:
    a: int

A(1, "hello")  # E: Too many arguments for "A"
a = A(1)

[case dataclass_transform_invalid_usage]
from typing import dataclass_transform

x = dataclass_transform(frozen_default=True)
x()  # E: "object" not callable
x.y # E: "object" has no attribute "y"
x[0]  # E: Value of type "object" is not indexable
reveal_type(x)  # N: Revealed type is "object"

[case dataclass_transform_conformance_tests]
# Copied from conformance tests (dataclasses_transform_class.py)
from typing import dataclass_transform, Any

class ModelField:
    def __init__(self, *, init: bool = True, default: Any | None = None) -> None: ...

def model_field(*, init: bool = True, default: Any | None = None, alias: str | None = None) -> Any: ...

@dataclass_transform(
    kw_only_default=True,
    field_specifiers=(ModelField, model_field),
)
class ModelBase:
    not_a_field: str

    def __init_subclass__(
        cls,
        *,
        frozen: bool = False,
        kw_only: bool = True,
        order: bool = True,
    ) -> None:
        ...

    def __init__(self, not_a_field: str) -> None:
        self.not_a_field = not_a_field

class Customer1(ModelBase, frozen=True):
    id: int = model_field()
    name: str = model_field()
    name2: str = model_field(alias="other_name", default="None")

# This should generate an error because a non-frozen dataclass cannot
# derive from a frozen one.
class Customer1Subclass(Customer1):  # E: Non-frozen dataclass cannot inherit from a frozen dataclass
    salary: float = model_field()

c1_1 = Customer1(id=3, name="Sue", other_name="Susan")

[case dataclass_transform_overload]
# Copied from conformance tests (dataclasses_transform_func.py)
from typing import overload, dataclass_transform, Any, TypeVar, Callable
T = TypeVar("T")
@overload
@dataclass_transform(kw_only_default=True, order_default=True)
def create_model(cls: T) -> T: ...


@overload
@dataclass_transform(kw_only_default=True, order_default=True)
def create_model(
    *,
    frozen: bool = False,
    kw_only: bool = True,
    order: bool = True,
) -> Callable[[T], T]: ...


def create_model(*args: Any, **kwargs: Any) -> Any: ...

@create_model(kw_only=False, order=False)
class Customer1:
    id: int
    name: str

c1_1 = Customer1(id=3, name="Sue")
c1_1.id = 4

[case dataclass_enum_combination]
from dataclasses import dataclass
from enum import Enum

@dataclass
class C(Enum):  # E: An Enum cannot be a dataclass
    x = 1
    y: str

C()  # E: Missing positional argument "y" in call to "C"

[case dataclasses_isinstance_narrowing_no_crash]
from dataclasses import dataclass

class A:
    z: str

@dataclass
class X[T]:
    x: T

@dataclass
class Y[T](X[T]):
    y: T

def test(x: Y[int]) -> None:
    if isinstance(x, A):
        reveal_type(x)  # N: Revealed type is "<subclass of "__main__.Y[int]" and "__main__.A">"
        reveal_type(x.x)  # N: Revealed type is "int"
        reveal_type(x.y)  # N: Revealed type is "int"
        reveal_type(x.z)  # N: Revealed type is "str"

[case dataclass_typeddict_combination]
from typing import TypedDict
from dataclasses import dataclass

@dataclass
class C(TypedDict):  # E: A TypedDict cannot be a dataclass
    x = 1  # E: Invalid statement in TypedDict definition; expected "field_name: field_type"
    y: str


C()  # E: Missing keys ("x", "y") for TypedDict "C"

[case dataclass_post_init_should_not_crash1]
import m

def _construct_named_inputs_and_attrs(signature: m.OpSignature): ...

[file m.py]
import dataclasses
from typing import Any

EMPTY = bool()

@dataclasses.dataclass
class OpSignature:
    default: Any = EMPTY

    def __post_init__(self) -> None: ...

[case dataclass_post_init_should_not_crash2]
import m

def f(signature: m.OpSignature): ...

[file m.py]
import dataclasses
from typing import Any

EMPTY = bool()

@dataclasses.dataclass
class OpSignature:
    default: dataclasses.InitVar[Any] = EMPTY

    def __post_init__(self) -> None: ...  # E: Signature of "__post_init__" incompatible with supertype "dataclass" \
                                          # N:      Superclass: \
                                          # N:          def __post_init__(self, default: Any) -> None \
                                          # N:      Subclass: \
                                          # N:          def __post_init__(self) -> None
                                          #
[case dataclass_slots_access]
# Copied from conformance tests (dataclasses_slots.py)
from dataclasses import dataclass
@dataclass(slots=True)
class DC5:
    a: int
DC5.__slots__   
DC5(1).__slots__

[case invalid_frozen_dataclass_base_access]
from dataclasses import dataclass
@dataclass(frozen=True)
class C(Undefined):  # E: Name "Undefined" is not defined
    x: int

x = C(x=1, y=1)
reveal_type(x.x)  # N: Revealed type is "int"
reveal_type(x.y)  # N: Revealed type is "Any"
x.x = 1  # E: Property "x" defined in "C" is read-only
x.y = ""  # E: Property "y" defined in "C" is read-only

[case dataclass_transform_converter_errors]
# Copied from conformance tests (dataclasses_transform_converter.py)
from typing import Callable, TypeVar, dataclass_transform

T = TypeVar("T")
S = TypeVar("S")

def model_field(
    *,
    converter: Callable[[S], T],
    default: S | None = None,
    default_factory: Callable[[], S] | None = None,
) -> T: ...

@dataclass_transform(field_specifiers=(model_field,))
class ModelBase: ...

# > The converter must be a callable that must accept a single positional
# > argument (but may accept other optional arguments, which are ignored for
# > typing purposes).

def bad_converter1() -> int:
    return 0


def bad_converter2(*, x: int) -> int:
    return 0

class DC1(ModelBase):
    field1: int = model_field(converter=bad_converter1)  # E: Argument "converter" to "model_field" has incompatible type "Callable[[], int]"; expected "Callable[[Never], int]"
    field2: int = model_field(converter=bad_converter2)  # E: Argument "converter" to "model_field" has incompatible type "Callable[[NamedArg(int, 'x')], int]"; expected "Callable[[Never], int]"

[case dataclass_transform_converter_conformance]
# Copied from conformance tests (dataclasses_transform_converter.py)
from typing import Any, Callable, TypeVar, dataclass_transform, overload

T = TypeVar("T")
S = TypeVar("S")

def model_field(
    *,
    converter: Callable[[S], T],
    default: S | None = None,
    default_factory: Callable[[], S] | None = None,
) -> T: ...

@dataclass_transform(field_specifiers=(model_field,))
class ModelBase:
    ...

def converter_simple(s: str) -> int:
    return int(s)

def converter_with_param_before_args(s: str, *args: int, **kwargs: int) -> int:
    return int(s)

def converter_with_args(*args: str) -> int:
    return int(args[0])

@overload
def overloaded_converter(s: str) -> int: ...
@overload
def overloaded_converter(s: list[str]) -> int: ...
def overloaded_converter(s: str | list[str], *args: str) -> int | str:
    return 0

class ConverterClass:
    @overload
    def __init__(self, val: str) -> None: ...
    @overload
    def __init__(self, val: bytes) -> None: ...
    def __init__(self, val: str | bytes) -> None:
        pass


class DC2(ModelBase):
    field0: int = model_field(converter=converter_simple)
    field1: int = model_field(converter=converter_with_param_before_args)
    field2: int = model_field(converter=converter_with_args)
    field3: ConverterClass = model_field(converter=ConverterClass)
    field4: int = model_field(converter=overloaded_converter)
    field5: dict[str, str] = model_field(converter=dict, default=())


DC2(1, "f1", "f2", b"f3", [])  # E: Argument 1 to "DC2" has incompatible type "int"; expected "str"
DC2("f0", "f1", "f2", 1, [])  # E: Argument 4 to "DC2" has incompatible type "int"; expected "str | bytes"
DC2("f0", "f1", "f2", "f3", 3j)  # E: Argument 5 to "DC2" has incompatible type "complex"; expected "str | list[str]"


dc1 = DC2("f0", "f1", "f2", b"f6", [])

dc1.field0 = "f1"
dc1.field3 = "f6"
dc1.field3 = b"f6"

dc1.field0 = 1  # E: Incompatible types in assignment of a dataclass converter (expression has type "int", expected type "str")
dc1.field3 = 1  # E: Incompatible types in assignment of a dataclass converter (expression has type "int", expected type "str | bytes")

dc2 = DC2("f0", "f1", "f2", "f6", "1", (("a", "1"), ("b", "2")))

[case dataclass_transform_converter_defaults]
# Copied from conformance tests (dataclasses_transform_converter.py)
from typing import Callable, TypeVar, dataclass_transform

T = TypeVar("T")
S = TypeVar("S")

def model_field(
    *,
    converter: Callable[[S], T],
    default: S | None = None,
    default_factory: Callable[[], S] | None = None,
) -> T: ...

@dataclass_transform(field_specifiers=(model_field,))
class ModelBase: ...

def converter_simple(s: str) -> int:
    return int(s)

# > If default or default_factory are provided, the type of the default value
# > should be assignable to the first positional parameter of the converter.

class DC3(ModelBase):
    field0: int = model_field(converter=converter_simple, default="")
    field1: int = model_field(converter=converter_simple, default=1)  # E: Argument "default" to "model_field" has incompatible type "int"; expected "str | None"

    field2: int = model_field(converter=converter_simple, default_factory=str)
    field3: int = model_field(converter=converter_simple, default_factory=int)  # E: Argument "default_factory" to "model_field" has incompatible type "type[int]"; expected "Callable[[], str] | None"

[case dataclass_transform_converter_generic]
from typing import Callable, TypeVar, dataclass_transform

T = TypeVar("T")
S = TypeVar("S")

def model_field(
    *,
    converter: Callable[[S], T],
    default: S | None = None,
    default_factory: Callable[[], S] | None = None,
) -> T: ...

@dataclass_transform(field_specifiers=(model_field,))
class ModelBase: ...

def converter_generic(s: list[T]) -> tuple[T, ...]:
    return tuple(s)

class DC(ModelBase):
    field0: tuple[int, ...] = model_field(converter=converter_generic)

DC((1,))  # E: Argument 1 to "DC" has incompatible type "tuple[int]"; expected "list[Any]"
d = DC([1])
reveal_type(d.field0)  # N: Revealed type is "tuple[int, ...]"
d.field0 = [1]
d.field0 = 1  # E: Incompatible types in assignment of a dataclass converter (expression has type "int", expected type "list[Any]")

[case dataclass_classmethod_initialization_type_checking]
from dataclasses import dataclass

@dataclass
class Foo:
    a: int
    b: str

    @classmethod
    def create(cls, a: int, b: str) -> Foo:
        Foo(a=a, b=a)  # E: Argument "b" to "Foo" has incompatible type "int"; expected "str"
        Foo(b=b, a=b)  # E: Argument "a" to "Foo" has incompatible type "str"; expected "int"
        Foo(b=b, a=a)
        Foo(b, a)  # E: Argument 1 to "Foo" has incompatible type "str"; expected "int" \
                   # E: Argument 2 to "Foo" has incompatible type "int"; expected "str"
        Foo(a, b)
        return cls(a=a, b=b)

[case avoid_dataclass_transform_converter_crash1]
from typing import cast, overload, Any, Callable, Literal, dataclass_transform

def field(converter: Any) -> Any: ...

@dataclass_transform(frozen_default=True, field_specifiers=(field,))
def frozen[_C](
    maybe_cls: _C,
) -> _C: ...

@overload

class Converter[In, Out]:
    def __init__(
        self,
        converter: Callable[[In, Any], Out],
    ) -> None: ...

@frozen
class Thing:
    foo: int
    bar: int = field(converter=Converter(lambda _, self: cast("Thing", self).foo))

[case avoid_dataclass_transform_converter_crash2]
from typing import cast, Callable, Any, dataclass_transform, overload

class Converter[In, Out]:
    def __init__(
        self,
        converter: Callable[[In, Any], Out],
    ) -> None: ...

@overload
def field(*, converter: None = ...) -> Any: ...
@overload
def field(*, converter: Converter) -> Any: ...
def field(*, converter: Converter | None = None) -> Any: ...

@dataclass_transform(frozen_default=True, field_specifiers=(field,))
def frozen[_C](maybe_cls: _C) -> _C: ...

@frozen
class Thing:
    foo: int
    bar: int = field(converter=Converter(lambda _, self: cast("Thing", self).foo))

[case avoid_dataclass_transform_crash_with_weird_generics]
from typing import Any, Self, TypeVar, dataclass_transform

@dataclass_transform()
class Concrete: ...


class Value[T, S](Concrete):
    value: T
    dtype: S

    @classmethod
    def __coerce__(cls, value: Any) -> Self:
        raise NotImplementedError

Scalar = Value[int, str]

class Literal[U](Scalar):
    dtype: U  # E: Incompatible types in assignment (expression has type "U", base class "Value" defined the type as "str")

Literal.__coerce__(1) == Literal(1, "")
reveal_type(Literal.__coerce__)  # N: Revealed type is "def [U] (value: Any) -> __main__.Literal[U]"

[case dataclass_attributes_on_class_are_preferred_over_dataclass]
# From GH #95
from dataclasses import dataclass

@dataclass(kw_only=True)
class Foo:
    a: int
    b: str
    __match_args__ = ("a", "b")

foo = Foo(a=1, b="2")

match foo:
    case Foo(a, b):
        pass

[case dataclass__getitem__]
# From GH #100
from dataclasses import dataclass

@dataclass
class Data:
    def __getitem__(self, value: int) -> str:
        return ""

data = Data()
reveal_type(data[1])  # N: Revealed type is "str"
data[""]  # E: Invalid index type "str" for "Data"; expected type "int"

[case dataclass_as_exceptions1]
# From GH #102
from dataclasses import dataclass

@dataclass
class CustomError(Exception):
    foo: int

try:
    raise CustomError(foo=3)
except CustomError:
    print("Custom error")
    raise CustomError  # E: Missing positional argument "foo" in call to "CustomError"

[case dataclass_as_exceptions2]
# From GH #153
import dataclasses

@dataclasses.dataclass
class CustomError(Exception):
    pass

def foo() -> None:
    raise KeyError

def bar() -> None:
    raise CustomError

def baz() -> None:
    raise CustomError()

[case dataclass_replace_on_incomplete_mro]
# From GH #105
from dataclasses import replace, dataclass

@dataclass
class A(X):  # E: Name "X" is not defined
    x: int

def f(a: A):
    replace(a, x=2)
    replace(a, x="")  # E: Argument "x" to "replace" of "A" has incompatible type "str"; expected "int"
    # Fine as well since we don't know the full MRO
    replace(a, y="")
    replace(a, y=1, z=3)

[case nested_dataclass]
from dataclasses import dataclass

@dataclass
class A:

    @dataclass
    class B:
        pass

    class C:
        pass

def foo(val: A.B, val2: A.C) -> None:
    pass

[case dataclass_should_not_crash]
# From GH #161
import dataclasses
from typing import overload

@dataclasses.dataclass()
class BaseExpression:
    pass

class BaseArithmeticExpression(BaseExpression):
    def __add__(self, other: int) -> Addition:
        return Addition()

class Addition[G](BaseArithmeticExpression): ...

[case dataclass_recursive_types_assert_type]
# From GH #161
import dataclasses
from typing import Literal, assert_type, overload

type ArithmeticExpression = int | float | BaseArithmeticExpression

@dataclasses.dataclass(frozen=True, kw_only=True)
class BaseExpression[G]:
    pass

class BaseComparableExpression[G](BaseExpression[G]):
    pass

class BaseNumericExpression[G](BaseComparableExpression[G]):
    pass

class BaseArithmeticExpression[G](BaseNumericExpression[G]):
    @overload
    def __add__[S: BaseArithmeticExpression[Literal[False]]](
        self: S,
        other: int,
    ) -> Addition[Literal[False], S, int]: ...

    @overload
    def __add__[S: BaseArithmeticExpression[Literal[False]]](
        self: S,
        other: float,
    ) -> Addition[Literal[False], S, float]: ...

    def __add__(self, other: ArithmeticExpression) -> Addition:
        return Addition(lhs=self, rhs=other)  # type: ignore

    @overload
    def __radd__[S: BaseArithmeticExpression[Literal[False]]](
        self: S,
        other: int,
    ) -> Addition[Literal[False], int, S]: ...

    @overload
    def __radd__[S: BaseArithmeticExpression[Literal[False]]](
        self: S,
        other: float,
    ) -> Addition[Literal[False], float, S]: ...

    def __radd__(self, other: ArithmeticExpression) -> Addition:
        return Addition(lhs=other, rhs=self)  # type: ignore

class BaseBinaryArithmeticOperation[
    G,
    L: ArithmeticExpression,
    R: ArithmeticExpression,
](BaseArithmeticExpression[G]):
    lhs: L
    rhs: R

class Addition[
    G,
    L: ArithmeticExpression,
    R: ArithmeticExpression,
](BaseBinaryArithmeticOperation[G, L, R]):
    pass

class BaseNamedSymbol(BaseExpression[Literal[False]]):
    name: str

class IntegerNamedSymbol(BaseArithmeticExpression[Literal[False]]):
    pass

age = IntegerNamedSymbol()

result1 = age + 3.7
assert_type(result1, Addition[Literal[False], IntegerNamedSymbol, float])
result2 = 3.7 + age
assert_type(result2, Addition[Literal[False], float, IntegerNamedSymbol])

[case dataclasses_hash]
# Copied from conformance tests (dataclasses_transform_class.py)
from dataclasses import dataclass
from typing import Hashable

@dataclass
class DC1:
    a: int

v1: Hashable = DC1(0)  # E: Incompatible types in assignment (expression has type "DC1", variable has type "Hashable")

@dataclass(eq=True, frozen=True)
class DC2:
    a: int

v2: Hashable = DC2(0)

@dataclass(eq=True)
class DC3:
    a: int

v3: Hashable = DC3(0)  # E: Incompatible types in assignment (expression has type "DC3", variable has type "Hashable")
@dataclass(frozen=True)
class DC4:
    a: int

v4: Hashable = DC4(0)

@dataclass(eq=True, unsafe_hash=True)
class DC5:
    a: int

v5: Hashable = DC5(0)

@dataclass(eq=True)
class DC6:
    a: int

    def __hash__(self) -> int:
        return 0

v6: Hashable = DC6(0)

@dataclass(frozen=True)
class DC7:
    a: int

    def __eq__(self, other) -> bool:
        return self.a == other.a

v7: Hashable = DC7(0)

[case dataclasses_slots_checking]
# flags: --mode default
# Copied from conformance tests (dataclasses_slots.py)
from dataclasses import dataclass

# This should generate an error because __slots__ is already defined
@dataclass(slots=True)
class DC1:  # E: "DC1" both defines "__slots__" and is used with "slots=True"
    x: int

    __slots__ = ()

@dataclass(slots=True)
class DC2:
    x: int

    def __init__(self):
        self.x = 3

        # This should generate an error because "y" is not in slots.
        self.y = 3  # E: Trying to assign name "y" that is not in "__slots__" of type "__main__.DC2"

@dataclass(slots=False)
class DC3:
    x: int

    __slots__ = ("x",)

    def __init__(self):
        self.x = 3

        # This should generate an error because "y" is not in slots.
        self.y = 3  # E: Trying to assign name "y" that is not in "__slots__" of type "__main__.DC3"

[case dataclasses_final_conformance_tests]
# Copied from conformance tests (dataclasses_final.py)
from dataclasses import dataclass
from typing import assert_type, ClassVar, Final

@dataclass
class D:
    final_no_default: Final[int]
    final_with_default: Final[str] = "foo"
    final_classvar: ClassVar[Final[int]] = 4
    # we don't require support for Final[ClassVar[...]] because the dataclasses
    # runtime implementation won't recognize it as a ClassVar either

# An explicitly marked ClassVar can be accessed on the class:
assert_type(D.final_classvar, int)

# ...but not assigned to, because it's Final:
D.final_classvar = 10  # E: Cannot assign to final attribute "final_classvar"

# A non-ClassVar attribute (with or without default) is a dataclass field:
d = D(final_no_default=1, final_with_default="bar")
assert_type(d.final_no_default, int)
assert_type(d.final_with_default, str)

# ... but can't be assigned to (on the class or on an instance):
d.final_no_default = 10  # E: Cannot assign to final attribute "final_no_default"
d.final_with_default = "baz"  # E: Cannot assign to final attribute "final_with_default"
D.final_no_default = 10  # E: Cannot assign to final attribute "final_no_default"
D.final_with_default = "baz"  # E: Cannot assign to final attribute "final_with_default"

[case dataclass_self_type_matching]
from dataclasses import dataclass
from typing import ClassVar, Callable, assert_type

def f(s: str) -> int:
    return int(s)

@dataclass
class DC6:
    a: ClassVar[int] = 0
    b: str
    c: Callable[[str], int] = f


dc6 = DC6("")
assert_type(dc6.a, int)
assert_type(DC6.a, int)
assert_type(dc6.b, str)
assert_type(dc6.c, Callable[[str], int])

[case dataclasses_replace_as_method]
# From GH #176
import dataclasses

@dataclasses.dataclass
class DataClass:
    x: int
    replace = dataclasses.replace

DataClass(1).replace()
DataClass(1).replace(x=2)

[case dataclass_classmethod_with_self_and_type_var_remapping]
# From GH #245
from typing import Self
from dataclasses import dataclass

def f[T: C](x: type[T]) -> T:
    return x.create()

@dataclass
class C():
    @classmethod
    def create(cls) -> Self:
        return cls()

[case correct_dataclass_slots_with_post_init]
from dataclasses import dataclass, field
# From GH #293
@dataclass(slots=True, eq=False)
class Sensor:
    address: int = field(init=False)

    def __post_init__(self) -> None:
        self.address = 1
        self.address = "a" # E: Incompatible types in assignment (expression has type "str", variable has type "int")

[case dataclass_replace_with_self]
# From GH #297
from dataclasses import dataclass, replace
from typing import Self

@dataclass
class CrItem(BaseClass):  # E: Name "BaseClass" is not defined
    def dedup_project(self) -> CrItem:
        return replace(self, new_param=[])

@dataclass
class Other:
    x: int

    def f(self) -> Self:
        if bool():
            return replace(self, new_param=[])  # E: Unexpected keyword argument "new_param" for "replace" of "Other"
        else:
            return replace(self, x=5)
