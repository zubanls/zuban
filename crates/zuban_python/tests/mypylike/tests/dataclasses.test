[case dataclass_any_inherited_nested]
# Checks issues of testDataclassesAnyInherit but with additional inheritance
from dataclasses import dataclass
from typing import Any
A: Any
@dataclass
class B(A):
    a: int

@dataclass
class C(B):
    b: str

reveal_type(C) # N: Revealed type is "def (a: int, b: str, *Any, **Any) -> __main__.C"
C(a=1, b="", c=2)
C(1, 1)  # E: Argument 2 to "C" has incompatible type "int"; expected "str"
C(a="foo", b="")  # E: Argument "a" to "C" has incompatible type "str"; expected "int"

[case dataclass_method_binding1]
from dataclasses import dataclass
from typing import Self

@dataclass
class A:
    x: int

    def foo(self) -> Self:
        return self

class B(A):
    y: int

x = B(1).foo()
reveal_type(x)  # N: Revealed type is "__main__.B"
type(x)(x=3)

y = B.foo(A(1))
type(y)(x=3)
z = B.foo(B(1))
type(z)(x=3)

[case dataclass_method_binding2]
from dataclasses import dataclass
from typing import Self

@dataclass
class A:
    x: int

    def foo(self) -> Self:
        return self

@dataclass
class B(A):
    y: int

x = B(1, 2).foo()
reveal_type(x)  # N: Revealed type is "__main__.B"
type(x)(x=3, y=4)

y = B.foo(A(1))
type(y)(x=3)
z = B.foo(B(1, 2))
type(z)(x=3, y=2)

a = A.foo(A(1))
reveal_type(a)  # N: Revealed type is "__main__.A"
type(a)(x=3)

[case dataclass_inheritance_method_generics_with_normal_class]
from typing import TypeVar, Generic, List
from dataclasses import dataclass

T = TypeVar("T")

@dataclass
class A(Generic[T]):
    x: T

    def foo(self) -> T: return self.x

class B(A[T]):
    y: str

b: B[str]
reveal_type(b.foo())  # N: Revealed type is "str"
x = B(1)
reveal_type(x)  # N: Revealed type is "__main__.B[int]"
reveal_type(x.foo())  # N: Revealed type is "int"

class C(A[List[T]]): ...

C(1)  # E: Argument 1 to "C" has incompatible type "int"; expected "list[Never]"
y = C([1])
reveal_type(y.foo())  # N: Revealed type is "list[int]"

[case dataclass_inheritance_method_generics_with_dataclass]
from typing import TypeVar, Generic, List
from dataclasses import dataclass

T = TypeVar("T")

@dataclass
class A(Generic[T]):
    x: T

    def foo(self) -> T: return self.x

@dataclass
class B(A[T]):
    y: str

b: B[str]
reveal_type(b.foo())  # N: Revealed type is "str"
x = B(1, "")
reveal_type(x)  # N: Revealed type is "__main__.B[int]"
reveal_type(x.foo())  # N: Revealed type is "int"

@dataclass
class C(A[List[T]]):
    y: str

C(1, "")  # E: Argument 1 to "C" has incompatible type "int"; expected "list[Never]"
y = C([1], "")
reveal_type(y.foo())  # N: Revealed type is "list[int]"

[case dataclass_inheritance_method_generics_with_dataclass_no_init]
from typing import TypeVar, Generic, List
from dataclasses import dataclass

T = TypeVar("T")

@dataclass
class A(Generic[T]):
    x: T

    def foo(self) -> T: return self.x

@dataclass(init=False)
class B(A[T]):
    y: str

b: B[str]
reveal_type(b.foo())  # N: Revealed type is "str"
x = B(1)
reveal_type(x)  # N: Revealed type is "__main__.B[int]"
reveal_type(x.foo())  # N: Revealed type is "int"

@dataclass(init=False)
class C(A[List[T]]):
    y: str

C(1)  # E: Argument 1 to "C" has incompatible type "int"; expected "list[Never]"
y = C([1])
reveal_type(y.foo())  # N: Revealed type is "list[int]"

[case dataclass_self_in_inheritance]
from typing import Self
from dataclasses import dataclass

@dataclass
class A:
    x: int

    def foo(self) -> Self: return self

@dataclass()
class B(A):
    y: str

x = B(1, "").foo()
reveal_type(x)  # N: Revealed type is "__main__.B"
type(x)(2, "")
type(x)(2, 2)  # E: Argument 2 to "B" has incompatible type "int"; expected "str"

class C(A):
    y: str

y = C(1)
reveal_type(y)  # N: Revealed type is "__main__.C"
type(y)("")  # E: Argument 1 to "C" has incompatible type "str"; expected "int"
type(y)(1)

[case generic_dataclass_used_in_annotation]
from typing import TypeVar, Generic
from dataclasses import dataclass

T = TypeVar("T")

@dataclass
class D(Generic[T]):
    foo: T
def foo(x: D[int]) -> None:
    reveal_type(x.foo)  # N: Revealed type is "int"

[case dataclass__call__]
from dataclasses import dataclass

@dataclass
class A:
    x: int

    def __call__(self, x: int) -> None: ...

A(1)()  # E: Missing positional argument "x" in call to "__call__" of "A"
A(1)(1)

[case dataclass_invalid_options]
from dataclasses import dataclass
def f(b: bool):
    @dataclass(init=b)  # E: "init" argument must be a True or False literal
    class B:
        y: str

    @dataclass(**{'undefined': b})  # E: Unexpected argument to "dataclass()"
    class C:
        y: str

[case dataclass_invalid_field_options]
from dataclasses import dataclass, field

def f(b: bool):
    @dataclass
    class B:
        y: str = field(init=b)  # E: "init" argument must be a True or False literal
        z: str = field(kw_only=b)  # E: "kw_only" argument must be a True or False literal

[case dataclass_post_init_invalid_self_type_override]
from typing import TypeVar, Generic, List
from dataclasses import dataclass

T = TypeVar("T")

@dataclass
class A(Generic[T]):
    x: T

    def __post_init__(self: A[int]) -> None: ...  # E: Invalid self argument "Self" to attribute function "__post_init__" with type "Callable[[A[int]], None]"
    def y(self: A[int]) -> None: ...

[case dataclass_init_with_self_type]
from typing import TypeVar, Generic, overload, Any
from dataclasses import dataclass

T = TypeVar("T")

@dataclass()
class C(Generic[T]):
    lower: T
    upper: T
    what: bool

    def __repr__(self) -> str:
        return f"VR[{self.lower}, {self.upper}]"

    def __init__(self: C[int], lower: T, upper: T) -> None: ...

reveal_type(C(1, 1))  # N: Revealed type is "__main__.C[int]"
reveal_type(C('', ''))  # E: Argument 1 to "C" has incompatible type "str"; expected "int" \
                        # E: Argument 2 to "C" has incompatible type "str"; expected "int" \
                        # N: Revealed type is "__main__.C[Any]"

[case dataclass_init_with_self_type_overloaded]
from typing import TypeVar, Generic, overload, Any
from dataclasses import dataclass

T = TypeVar("T")

@dataclass()
class C(Generic[T]):
    lower: T
    upper: T
    what: bool

    def __repr__(self) -> str:
        return f"VR[{self.lower}, {self.upper}]"

    @overload
    def __init__(self: C[int], lower: int, upper: int) -> None: ...
    @overload
    def __init__(self: C[str], lower: str, upper: str) -> None: ...
    def __init__(self, lower: Any, upper: Any) -> None: ...

reveal_type(C(1, 1))  # N: Revealed type is "__main__.C[int]"
reveal_type(C('', ''))  # N: Revealed type is "__main__.C[str]"

[case custom_dataclass_stubs]
from dataclasses import dataclass

@dataclass
class A:
    x: int

A(1)
A(x=1)
A(1, y=1)  # E: Unexpected keyword argument "y" for "A"

[file dataclasses-stubs/__init__.pyi]
from typing import Any
def dataclass(cls: type[Any], /) -> type[Any]: ...

[case dataclass_descriptor_call]
from dataclasses import dataclass

class MyDescriptor:
    def __get__(self, obj: object | None, owner) -> int | "MyDescriptor": ...
    def __set__(self, obj: object | None, value: int) -> None: ...

@dataclass
class Foo:
    x: MyDescriptor
    y: MyDescriptor = MyDescriptor()

Foo(3, 3)  # E: Argument 1 to "Foo" has incompatible type "int"; expected "MyDescriptor"
Foo(MyDescriptor(), MyDescriptor())  # E: Argument 2 to "Foo" has incompatible type "MyDescriptor"; expected "int"
f = Foo(MyDescriptor(), 3)  # Currently a false positive error in pyright (and mypy)

f.y = 4

reveal_type(f.y)  # N: Revealed type is "int | __main__.MyDescriptor"
reveal_type(Foo.y)  # N: Revealed type is "int | __main__.MyDescriptor"

[case dataclass_with_or_should_not_panic]
from dataclasses import dataclass

@dataclass()
class Foo(): ...

Bar = Foo | int

[case dataclass_transform_metaclass_with_dataclass_inheritance1]
# flags: --python-version 3.11

from typing import dataclass_transform, overload, Any
from dataclasses import dataclass

@dataclass_transform()
class Metaclass(type): ...

class C(metaclass=Metaclass):
    x: int

@dataclass
class D(C):
    y: str

D()  # E: Missing positional arguments "x", "y" in call to "D"
d = D(1, "")
d.x
d.y
d.z  # E: "D" has no attribute "z"

[case dataclass_transform_metaclass_with_dataclass_inheritance2]
from typing import dataclass_transform, overload, Any
from dataclasses import dataclass

@dataclass_transform()
class Metaclass(type): ...

# This is a special case and it should probably just not crash
@dataclass
class C(Metaclass):
    x: int

C(1)
C()  # E: Missing positional argument "x" in call to "C"

@dataclass
class D(C):
    y: str

D()  # E: Missing positional arguments "x", "y" in call to "D"
d = D(1, "")
d.x
d.y
d.z  # E: "D" has no attribute "z"

[case dataclass_transform_invalid_arg]
from typing import dataclass_transform, overload, Any
from dataclasses import dataclass

@dataclass_transform(1)  # E: Unexpected argument to "dataclass_transform()"
class M1(type): ...

@dataclass_transform(*(1,))  # E: Unexpected argument to "dataclass_transform()"
class M2(): ...

@dataclass_transform(**dict(eq_default=True))  # E: Unexpected argument to "dataclass_transform()"
class M3(): ...

@dataclass_transform(**{'eq_default': True })  # E: Unexpected argument to "dataclass_transform()"
class M4(): ...

[case dataclass_transform_post_init_access]
from typing import dataclass_transform
from dataclasses import dataclass

@dataclass_transform()
class Meta(type): ...

class C(metaclass=Meta):
    key: str

class D(C):
    def __post_init__(self) -> None:
        super().__post_init__  # E: "__post_init__" undefined in superclass

@dataclass()
class E(C):
    def __post_init__(self) -> None:
        # TODO this is not correct, because it's wrapped as a dataclass again
        super().__post_init__  # E: "__post_init__" undefined in superclass

[case dataclass_transform_in_wrong_place]
from typing import dataclass_transform
# This is not correct, but for now we don't support it in a better way
reveal_type(dataclass_transform())  # N: Revealed type is "object"

[case dataclass_transform_wrong_args]
from typing import dataclass_transform, Any
@dataclass_transform(order_default=True)
def foo(x: int) -> Any: ...

@foo(order=False)  # E: Unexpected keyword argument "order" for "foo"
class D:
    x: int

[case dataclass_transform_on_first_overload]
# Copied from testDataclassTransformOverloadsDecoratorOnOverload, but with
# dataclass_transform on first overload
from typing import dataclass_transform, overload, Callable, Type

@dataclass_transform(frozen_default=True)
@overload
def my_dataclass(*, foo: str) -> Callable[[Type], Type]: ...
@overload
def my_dataclass(*, foo: int) -> Callable[[Type], Type]: ...
def my_dataclass(*, foo) -> Callable[[Type], Type]:
    return lambda cls: cls
@my_dataclass(foo="hello")
class A:
    a: int
@my_dataclass(foo=5)
class B:
    b: int

reveal_type(A)  # N: Revealed type is "def (a: int) -> __main__.A"
reveal_type(B)  # N: Revealed type is "def (b: int) -> __main__.B"
A(1, "hello")  # E: Too many arguments for "A"
a = A(1)
a.a = 2  # E: Property "a" defined in "A" is read-only

[case dataclass_transform_on_overload_with_reassignment]
from typing import dataclass_transform, overload, Callable, Type

@dataclass_transform(frozen_default=True)
@overload
def my_dataclass(*, foo: str) -> Callable[[Type], Type]: ...
@overload
def my_dataclass(*, foo: int) -> Callable[[Type], Type]: ...
def my_dataclass(*, foo) -> Callable[[Type], Type]: ...

# This needs to work, because attrs uses something like this
reassignment = other = my_dataclass

@reassignment(foo="hello")
class A:
    a: int

A(1, "hello")  # E: Too many arguments for "A"
a = A(1)

[case dataclass_transform_invalid_usage]
from typing import dataclass_transform

x = dataclass_transform(frozen_default=True)
x()  # E: "object" not callable
x.y # E: "object" has no attribute "y"
x[0]  # E: Value of type "object" is not indexable
reveal_type(x)  # N: Revealed type is "object"

[case dataclass_transform_conformance_tests]
# Copied from conformance tests (dataclasses_transform_class.py)
from typing import dataclass_transform, Any

class ModelField:
    def __init__(self, *, init: bool = True, default: Any | None = None) -> None: ...

def model_field(*, init: bool = True, default: Any | None = None, alias: str | None = None) -> Any: ...

@dataclass_transform(
    kw_only_default=True,
    field_specifiers=(ModelField, model_field),
)
class ModelBase: ...

class Customer1(ModelBase, frozen=True):
    id: int = model_field()
    name: str = model_field()
    name2: str = model_field(alias="other_name", default="None")

# This should generate an error because a non-frozen dataclass cannot
# derive from a frozen one.
class Customer1Subclass(Customer1):  # E: Non-frozen dataclass cannot inherit from a frozen dataclass
    salary: float = model_field()

c1_1 = Customer1(id=3, name="Sue", other_name="Susan")

[case dataclass_transform_overload]
# Copied from conformance tests (dataclasses_transform_func.py)
from typing import overload, dataclass_transform, Any, TypeVar, Callable
T = TypeVar("T")
@overload
@dataclass_transform(kw_only_default=True, order_default=True)
def create_model(cls: T) -> T: ...


@overload
@dataclass_transform(kw_only_default=True, order_default=True)
def create_model(
    *,
    frozen: bool = False,
    kw_only: bool = True,
    order: bool = True,
) -> Callable[[T], T]: ...


def create_model(*args: Any, **kwargs: Any) -> Any: ...

@create_model(kw_only=False, order=False)
class Customer1:
    id: int
    name: str

c1_1 = Customer1(id=3, name="Sue")
c1_1.id = 4

[case dataclass_enum_combination]
from dataclasses import dataclass
from enum import Enum

@dataclass
class C(Enum):  # E: An Enum cannot be a dataclass
    x = 1
    y: str

C()  # E: Missing positional argument "y" in call to "C"

[case dataclasses_isinstance_narrowing_no_crash]
from dataclasses import dataclass

class A:
    z: str

@dataclass
class X[T]:
    x: T

@dataclass
class Y[T](X[T]):
    y: T

def test(x: Y[int]) -> None:
    if isinstance(x, A):
        reveal_type(x)  # N: Revealed type is "<subclass of "__main__.Y[int]" and "__main__.A">"
        reveal_type(x.x)  # N: Revealed type is "int"
        reveal_type(x.y)  # N: Revealed type is "int"
        reveal_type(x.z)  # N: Revealed type is "str"

[case dataclass_typeddict_combination]
from typing import TypedDict
from dataclasses import dataclass

@dataclass
class C(TypedDict):  # E: A TypedDict cannot be a dataclass
    x = 1  # E: Invalid statement in TypedDict definition; expected "field_name: field_type"
    y: str


C()  # E: Missing keys ("x", "y") for TypedDict "C"

[case dataclass_post_init_should_not_crash1]
import m

def _construct_named_inputs_and_attrs(signature: m.OpSignature): ...

[file m.py]
import dataclasses
from typing import Any

EMPTY = bool()

@dataclasses.dataclass
class OpSignature:
    default: Any = EMPTY

    def __post_init__(self) -> None: ...

[case dataclass_post_init_should_not_crash2]
import m

def f(signature: m.OpSignature): ...

[file m.py]
import dataclasses
from typing import Any

EMPTY = bool()

@dataclasses.dataclass
class OpSignature:
    default: dataclasses.InitVar[Any] = EMPTY

    def __post_init__(self) -> None: ...  # E: Signature of "__post_init__" incompatible with supertype "dataclass" \
                                          # N:      Superclass: \
                                          # N:          def __post_init__(self, default: Any) -> None \
                                          # N:      Subclass: \
                                          # N:          def __post_init__(self) -> None
                                          #
[case dataclass_slots_access]
# Copied from conformance tests (dataclasses_slots.py)
from dataclasses import dataclass
@dataclass(slots=True)
class DC5:
    a: int
DC5.__slots__   
DC5(1).__slots__

[case invalid_frozen_dataclass_base_access]
from dataclasses import dataclass
@dataclass(frozen=True)
class C(Undefined):  # E: Name "Undefined" is not defined
    x: int

x = C(x=1, y=1)
reveal_type(x.x)  # N: Revealed type is "int"
reveal_type(x.y)  # N: Revealed type is "Any"
x.x = 1  # E: Property "x" defined in "C" is read-only
x.y = ""  # E: Property "y" defined in "C" is read-only

[case dataclass_transform_converter_errors]
# Copied from conformance tests (dataclasses_transform_converter.py)
from typing import Callable, TypeVar, dataclass_transform

T = TypeVar("T")
S = TypeVar("S")

def model_field(
    *,
    converter: Callable[[S], T],
    default: S | None = None,
    default_factory: Callable[[], S] | None = None,
) -> T: ...

@dataclass_transform(field_specifiers=(model_field,))
class ModelBase: ...

# > The converter must be a callable that must accept a single positional
# > argument (but may accept other optional arguments, which are ignored for
# > typing purposes).

def bad_converter1() -> int:
    return 0


def bad_converter2(*, x: int) -> int:
    return 0

class DC1(ModelBase):
    field1: int = model_field(converter=bad_converter1)  # E: Argument "converter" to "model_field" has incompatible type "Callable[[], int]"; expected "Callable[[Never], int]"
    field2: int = model_field(converter=bad_converter2)  # E: Argument "converter" to "model_field" has incompatible type "Callable[[NamedArg(int, 'x')], int]"; expected "Callable[[Never], int]"

[case dataclass_transform_converter_conformance]
# Copied from conformance tests (dataclasses_transform_converter.py)
from typing import Any, Callable, TypeVar, dataclass_transform, overload

T = TypeVar("T")
S = TypeVar("S")

def model_field(
    *,
    converter: Callable[[S], T],
    default: S | None = None,
    default_factory: Callable[[], S] | None = None,
) -> T: ...

@dataclass_transform(field_specifiers=(model_field,))
class ModelBase:
    ...

def converter_simple(s: str) -> int:
    return int(s)

def converter_with_param_before_args(s: str, *args: int, **kwargs: int) -> int:
    return int(s)

def converter_with_args(*args: str) -> int:
    return int(args[0])

@overload
def overloaded_converter(s: str) -> int: ...
@overload
def overloaded_converter(s: list[str]) -> int: ...
def overloaded_converter(s: str | list[str], *args: str) -> int | str:
    return 0

class ConverterClass:
    @overload
    def __init__(self, val: str) -> None: ...
    @overload
    def __init__(self, val: bytes) -> None: ...
    def __init__(self, val: str | bytes) -> None:
        pass


class DC2(ModelBase):
    field0: int = model_field(converter=converter_simple)
    field1: int = model_field(converter=converter_with_param_before_args)
    field2: int = model_field(converter=converter_with_args)
    field3: ConverterClass = model_field(converter=ConverterClass)
    field4: int = model_field(converter=overloaded_converter)
    # TODO remove this error
    field5: dict[str, str] = model_field(converter=dict, default=())  # E: Incompatible callable argument with type vars


DC2(1, "f1", "f2", b"f3", [])  # E: Argument 1 to "DC2" has incompatible type "int"; expected "str"
DC2("f0", "f1", "f2", 1, [])  # E: Argument 4 to "DC2" has incompatible type "int"; expected "str | bytes"
DC2("f0", "f1", "f2", "f3", 3j)  # E: Argument 5 to "DC2" has incompatible type "complex"; expected "str | list[str]"


dc1 = DC2("f0", "f1", "f2", b"f6", [])

dc1.field0 = "f1"
dc1.field3 = "f6"
dc1.field3 = b"f6"

dc1.field0 = 1  # E: Incompatible types in assignment of a dataclass converter (expression has type "int", expected type "str")
dc1.field3 = 1  # E: Incompatible types in assignment of a dataclass converter (expression has type "int", expected type "str | bytes")

dc2 = DC2("f0", "f1", "f2", "f6", "1", (("a", "1"), ("b", "2")))

[case dataclass_transform_converter_defaults]
# Copied from conformance tests (dataclasses_transform_converter.py)
from typing import Callable, TypeVar, dataclass_transform

T = TypeVar("T")
S = TypeVar("S")

def model_field(
    *,
    converter: Callable[[S], T],
    default: S | None = None,
    default_factory: Callable[[], S] | None = None,
) -> T: ...

@dataclass_transform(field_specifiers=(model_field,))
class ModelBase: ...

def converter_simple(s: str) -> int:
    return int(s)

# > If default or default_factory are provided, the type of the default value
# > should be assignable to the first positional parameter of the converter.

class DC3(ModelBase):
    field0: int = model_field(converter=converter_simple, default="")
    field1: int = model_field(converter=converter_simple, default=1)  # E: Argument "default" to "model_field" has incompatible type "int"; expected "str | None"

    field2: int = model_field(converter=converter_simple, default_factory=str)
    field3: int = model_field(converter=converter_simple, default_factory=int)  # E: Argument "default_factory" to "model_field" has incompatible type "type[int]"; expected "Callable[[], str] | None"

[case dataclass_transform_converter_generic]
from typing import Callable, TypeVar, dataclass_transform

T = TypeVar("T")
S = TypeVar("S")

def model_field(
    *,
    converter: Callable[[S], T],
    default: S | None = None,
    default_factory: Callable[[], S] | None = None,
) -> T: ...

@dataclass_transform(field_specifiers=(model_field,))
class ModelBase: ...

def converter_generic(s: list[T]) -> tuple[T, ...]:
    return tuple(s)

class DC(ModelBase):
    field0: tuple[int, ...] = model_field(converter=converter_generic)

DC((1,))  # E: Argument 1 to "DC" has incompatible type "tuple[int]"; expected "list[Any]"
d = DC([1])
reveal_type(d.field0)  # N: Revealed type is "tuple[int, ...]"
d.field0 = [1]
d.field0 = 1  # E: Incompatible types in assignment of a dataclass converter (expression has type "int", expected type "list[Any]")

[case dataclass_classmethod_initialization_type_checking]
from dataclasses import dataclass

@dataclass
class Foo:
    a: int
    b: str

    @classmethod
    def create(cls, a: int, b: str) -> Foo:
        Foo(a=a, b=a)  # E: Argument "b" to "Foo" has incompatible type "int"; expected "str"
        Foo(b=b, a=b)  # E: Argument "a" to "Foo" has incompatible type "str"; expected "int"
        Foo(b=b, a=a)
        Foo(b, a)  # E: Argument 1 to "Foo" has incompatible type "str"; expected "int" \
                   # E: Argument 2 to "Foo" has incompatible type "int"; expected "str"
        Foo(a, b)
        return cls(a=a, b=b)

[case avoid_dataclass_transform_converter_crash1]
from typing import cast, overload, Any, Callable, Literal, dataclass_transform

def field(converter: Any) -> Any: ...

@dataclass_transform(frozen_default=True, field_specifiers=(field,))
def frozen[_C](
    maybe_cls: _C,
) -> _C: ...

@overload

class Converter[In, Out]:
    def __init__(
        self,
        converter: Callable[[In, Any], Out],
    ) -> None: ...

@frozen
class Thing:
    foo: int
    bar: int = field(converter=Converter(lambda _, self: cast("Thing", self).foo))

[case avoid_dataclass_transform_converter_crash2]
from typing import cast, Callable, Any, dataclass_transform, overload

class Converter[In, Out]:
    def __init__(
        self,
        converter: Callable[[In, Any], Out],
    ) -> None: ...

@overload
def field(*, converter: None = ...) -> Any: ...
@overload
def field(*, converter: Converter) -> Any: ...
def field(*, converter: Converter | None = None) -> Any: ...

@dataclass_transform(frozen_default=True, field_specifiers=(field,))
def frozen[_C](maybe_cls: _C) -> _C: ...

@frozen
class Thing:
    foo: int
    bar: int = field(converter=Converter(lambda _, self: cast("Thing", self).foo))

[case avoid_dataclass_transform_crash_with_weird_generics]
from typing import Any, Self, TypeVar, dataclass_transform

@dataclass_transform()
class Concrete: ...


class Value[T, S](Concrete):
    value: T
    dtype: S

    @classmethod
    def __coerce__(cls, value: Any) -> Self:
        raise NotImplementedError

Scalar = Value[int, str]

class Literal[U](Scalar):
    dtype: U  # E: Incompatible types in assignment (expression has type "U", base class "Value" defined the type as "str")

Literal.__coerce__(1) == Literal(1, "")
reveal_type(Literal.__coerce__)  # N: Revealed type is "def [U] (value: Any) -> __main__.Literal[U]"

[case dataclass_attributes_on_class_are_preferred_over_dataclass]
# From GH #95
from dataclasses import dataclass

@dataclass(kw_only=True)
class Foo:
    a: int
    b: str
    __match_args__ = ("a", "b")

foo = Foo(a=1, b="2")

match foo:
    case Foo(a, b):
        pass

[case dataclass__getitem__]
# From GH #100
from dataclasses import dataclass

@dataclass
class Data:
    def __getitem__(self, value: int) -> str:
        return ""

data = Data()
reveal_type(data[1])  # N: Revealed type is "str"
data[""]  # E: Invalid index type "str" for "Data"; expected type "int"

[case dataclass_as_exceptions]
# From GH #102
from dataclasses import dataclass

@dataclass
class CustomError(Exception):
    foo: int

try:
    raise CustomError(foo=3)
except CustomError:
    print("Custom error")

[case dataclass_replace_on_incomplete_mro]
# From GH #105
from dataclasses import replace, dataclass

@dataclass
class A(X):  # E: Name "X" is not defined
    x: int

def f(a: A):
    replace(a, x=2)
    replace(a, x="")  # E: Argument "x" to "replace" of "A" has incompatible type "str"; expected "int"
    # Fine as well since we don't know the full MRO
    replace(a, y="")
    replace(a, y=1, z=3)
