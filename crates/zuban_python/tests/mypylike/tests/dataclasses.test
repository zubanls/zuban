[case dataclass_any_inherited_nested]
# Checks issues of testDataclassesAnyInherit but with additional inheritance
from dataclasses import dataclass
from typing import Any
A: Any
@dataclass
class B(A):
    a: int

@dataclass
class C(B):
    b: str

reveal_type(C) # N: Revealed type is "def (a: int, b: str, *Any, **Any) -> __main__.C"
C(a=1, b="", c=2)
C(1, 1)  # E: Argument 2 to "C" has incompatible type "int"; expected "str"
C(a="foo", b="")  # E: Argument "a" to "C" has incompatible type "str"; expected "int"

[case dataclass_method_binding1]
from dataclasses import dataclass
from typing import Self

@dataclass
class A:
    x: int

    def foo(self) -> Self:
        return self

class B(A):
    y: int

x = B(1).foo()
reveal_type(x)  # N: Revealed type is "__main__.B"
type(x)(x=3)

y = B.foo(A(1))
type(y)(x=3)
z = B.foo(B(1))
type(z)(x=3)

[case dataclass_method_binding2]
from dataclasses import dataclass
from typing import Self

@dataclass
class A:
    x: int

    def foo(self) -> Self:
        return self

@dataclass
class B(A):
    y: int

x = B(1, 2).foo()
reveal_type(x)  # N: Revealed type is "__main__.B"
type(x)(x=3, y=4)

y = B.foo(A(1))
type(y)(x=3)
z = B.foo(B(1, 2))
type(z)(x=3, y=2)

a = A.foo(A(1))
reveal_type(a)  # N: Revealed type is "__main__.A"
type(a)(x=3)

[case dataclass_inheritance_method_generics_with_normal_class]
from typing import TypeVar, Generic, List
from dataclasses import dataclass

T = TypeVar("T")

@dataclass
class A(Generic[T]):
    x: T

    def foo(self) -> T: return self.x

class B(A[T]):
    y: str

b: B[str]
reveal_type(b.foo())  # N: Revealed type is "str"
x = B(1)
reveal_type(x)  # N: Revealed type is "__main__.B[int]"
reveal_type(x.foo())  # N: Revealed type is "int"

class C(A[List[T]]): ...

C(1)  # E: Argument 1 to "C" has incompatible type "int"; expected "list[Never]"
y = C([1])
reveal_type(y.foo())  # N: Revealed type is "list[int]"

[case dataclass_inheritance_method_generics_with_dataclass]
from typing import TypeVar, Generic, List
from dataclasses import dataclass

T = TypeVar("T")

@dataclass
class A(Generic[T]):
    x: T

    def foo(self) -> T: return self.x

@dataclass
class B(A[T]):
    y: str

b: B[str]
reveal_type(b.foo())  # N: Revealed type is "str"
x = B(1, "")
reveal_type(x)  # N: Revealed type is "__main__.B[int]"
reveal_type(x.foo())  # N: Revealed type is "int"

@dataclass
class C(A[List[T]]):
    y: str

C(1, "")  # E: Argument 1 to "C" has incompatible type "int"; expected "list[Never]"
y = C([1], "")
reveal_type(y.foo())  # N: Revealed type is "list[int]"

[case dataclass_inheritance_method_generics_with_dataclass_no_init]
from typing import TypeVar, Generic, List
from dataclasses import dataclass

T = TypeVar("T")

@dataclass
class A(Generic[T]):
    x: T

    def foo(self) -> T: return self.x

@dataclass(init=False)
class B(A[T]):
    y: str

b: B[str]
reveal_type(b.foo())  # N: Revealed type is "str"
x = B(1)
reveal_type(x)  # N: Revealed type is "__main__.B[int]"
reveal_type(x.foo())  # N: Revealed type is "int"

@dataclass(init=False)
class C(A[List[T]]):
    y: str

C(1)  # E: Argument 1 to "C" has incompatible type "int"; expected "list[Never]"
y = C([1])
reveal_type(y.foo())  # N: Revealed type is "list[int]"

[case dataclass_self_in_inheritance]
from typing import Self
from dataclasses import dataclass

@dataclass
class A:
    x: int

    def foo(self) -> Self: return self

@dataclass()
class B(A):
    y: str

x = B(1, "").foo()
reveal_type(x)  # N: Revealed type is "__main__.B"
type(x)(2, "")
type(x)(2, 2)  # E: Argument 2 to "B" has incompatible type "int"; expected "str"

class C(A):
    y: str

y = C(1)
reveal_type(y)  # N: Revealed type is "__main__.C"
type(y)("")  # E: Argument 1 to "C" has incompatible type "str"; expected "int"
type(y)(1)

[case generic_dataclass_used_in_annotation]
from typing import TypeVar, Generic
from dataclasses import dataclass

T = TypeVar("T")

@dataclass
class D(Generic[T]):
    foo: T
def foo(x: D[int]) -> None:
    reveal_type(x.foo)  # N: Revealed type is "int"

[case dataclass__call__]
from dataclasses import dataclass

@dataclass
class A:
    x: int

    def __call__(self, x: int) -> None: ...

A(1)()  # E: Missing positional argument "x" in call to "__call__" of "A"
A(1)(1)

[case dataclass_invalid_options]
from dataclasses import dataclass
def f(b: bool):
    @dataclass(init=b)  # E: "init" argument must be a True or False literal
    class B:
        y: str

    @dataclass(**{'undefined': b})  # E: Unexpected argument to "dataclass()"
    class C:
        y: str

[case dataclass_invalid_field_options]
from dataclasses import dataclass, field

def f(b: bool):
    @dataclass
    class B:
        y: str = field(init=b)  # E: "init" argument must be a True or False literal
        z: str = field(kw_only=b)  # E: "kw_only" argument must be a True or False literal

[case dataclass_post_init_invalid_self_type_override]
from typing import TypeVar, Generic, List
from dataclasses import dataclass

T = TypeVar("T")

@dataclass
class A(Generic[T]):
    x: T

    def __post_init__(self: A[int]) -> None: ...  # E: Invalid self argument "Self" to attribute function "__post_init__" with type "Callable[[A[int]], None]"
    def y(self: A[int]) -> None: ...

[case dataclass_init_with_self_type]
from typing import TypeVar, Generic, overload, Any
from dataclasses import dataclass

T = TypeVar("T")

@dataclass()
class C(Generic[T]):
    lower: T
    upper: T
    what: bool

    def __repr__(self) -> str:
        return f"VR[{self.lower}, {self.upper}]"

    def __init__(self: C[int], lower: T, upper: T) -> None: ...

reveal_type(C(1, 1))  # N: Revealed type is "__main__.C[int]"
reveal_type(C('', ''))  # E: Argument 1 to "C" has incompatible type "str"; expected "int" \
                        # E: Argument 2 to "C" has incompatible type "str"; expected "int" \
                        # N: Revealed type is "__main__.C[Any]"

[case dataclass_init_with_self_type_overloaded]
from typing import TypeVar, Generic, overload, Any
from dataclasses import dataclass

T = TypeVar("T")

@dataclass()
class C(Generic[T]):
    lower: T
    upper: T
    what: bool

    def __repr__(self) -> str:
        return f"VR[{self.lower}, {self.upper}]"

    @overload
    def __init__(self: C[int], lower: int, upper: int) -> None: ...
    @overload
    def __init__(self: C[str], lower: str, upper: str) -> None: ...
    def __init__(self, lower: Any, upper: Any) -> None: ...

reveal_type(C(1, 1))  # N: Revealed type is "__main__.C[int]"
reveal_type(C('', ''))  # N: Revealed type is "__main__.C[str]"

[case custom_dataclass_stubs]
from dataclasses import dataclass

@dataclass
class A:
    x: int

A(1)
A(x=1)
A(1, y=1)  # E: Unexpected keyword argument "y" for "A"

[file dataclasses-stubs/__init__.pyi]
from typing import Any
def dataclass(cls: type[Any], /) -> type[Any]: ...

[case dataclass_descriptor_call]
from dataclasses import dataclass

class MyDescriptor:
    def __get__(self, obj: object | None, owner) -> int | "MyDescriptor": ...
    def __set__(self, obj: object | None, value: int) -> None: ...

@dataclass
class Foo:
    x: MyDescriptor
    y: MyDescriptor = MyDescriptor()

Foo(3, 3)  # E: Argument 1 to "Foo" has incompatible type "int"; expected "MyDescriptor"
Foo(MyDescriptor(), MyDescriptor())  # E: Argument 2 to "Foo" has incompatible type "MyDescriptor"; expected "int"
f = Foo(MyDescriptor(), 3)  # Currently a false positive error in pyright (and mypy)

f.y = 4

reveal_type(f.y)  # N: Revealed type is "int | __main__.MyDescriptor"
reveal_type(Foo.y)  # N: Revealed type is "int | __main__.MyDescriptor"

[case dataclass_with_or_should_not_panic]
from dataclasses import dataclass

@dataclass()
class Foo(): ...

Bar = Foo | int

[case dataclass_transform_metaclass_with_dataclass_inheritance1]
# flags: --python-version 3.11

from typing import dataclass_transform, overload, Any
from dataclasses import dataclass

@dataclass_transform()
class Metaclass(type): ...

class C(metaclass=Metaclass):
    x: int

@dataclass
class D(C):
    y: str

D()  # E: Missing positional arguments "x", "y" in call to "D"
d = D(1, "")
d.x
d.y
d.z  # E: "D" has no attribute "z"

[case dataclass_transform_metaclass_with_dataclass_inheritance2]
from typing import dataclass_transform, overload, Any
from dataclasses import dataclass

@dataclass_transform()
class Metaclass(type): ...

# This is a special case and it should probably just not crash
@dataclass
class C(Metaclass):
    x: int

C(1)
C()  # E: Missing positional argument "x" in call to "C"

@dataclass
class D(C):
    y: str

D()  # E: Missing positional arguments "x", "y" in call to "D"
d = D(1, "")
d.x
d.y
d.z  # E: "D" has no attribute "z"

[case dataclass_transform_invalid_arg]
from typing import dataclass_transform, overload, Any
from dataclasses import dataclass

@dataclass_transform(1)  # E: Unexpected argument to "dataclass_transform()"
class M1(type): ...

@dataclass_transform(*(1,))  # E: Unexpected argument to "dataclass_transform()"
class M2(): ...

@dataclass_transform(**dict(eq_default=True))  # E: Unexpected argument to "dataclass_transform()"
class M3(): ...

@dataclass_transform(**{'eq_default': True })  # E: Unexpected argument to "dataclass_transform()"
class M4(): ...

[case dataclass_transform_post_init_access]
from typing import dataclass_transform
from dataclasses import dataclass

@dataclass_transform()
class Meta(type): ...

class C(metaclass=Meta):
    key: str

class D(C):
    def __post_init__(self) -> None:
        super().__post_init__  # E: "__post_init__" undefined in superclass

@dataclass()
class E(C):
    def __post_init__(self) -> None:
        # TODO this is not correct, because it's wrapped as a dataclass again
        super().__post_init__  # E: "__post_init__" undefined in superclass

[case dataclass_transform_in_wrong_place]
from typing import dataclass_transform
# This is not correct, but for now we don't support it in a better way
reveal_type(dataclass_transform())  # N: Revealed type is "object"

[case dataclass_transform_wrong_args]
from typing import dataclass_transform, Any
@dataclass_transform(order_default=True)
def foo(x: int) -> Any: ...

@foo(order=False)  # E: Unexpected keyword argument "order" for "foo"
class D:
    x: int

[case dataclass_transform_on_first_overload]
# Copied from testDataclassTransformOverloadsDecoratorOnOverload, but with
# dataclass_transform on first overload
from typing import dataclass_transform, overload, Callable, Type

@dataclass_transform(frozen_default=True)
@overload
def my_dataclass(*, foo: str) -> Callable[[Type], Type]: ...
@overload
def my_dataclass(*, foo: int) -> Callable[[Type], Type]: ...
def my_dataclass(*, foo) -> Callable[[Type], Type]:
    return lambda cls: cls
@my_dataclass(foo="hello")
class A:
    a: int
@my_dataclass(foo=5)
class B:
    b: int

reveal_type(A)  # N: Revealed type is "def (a: int) -> __main__.A"
reveal_type(B)  # N: Revealed type is "def (b: int) -> __main__.B"
A(1, "hello")  # E: Too many arguments for "A"
a = A(1)
a.a = 2  # E: Property "a" defined in "A" is read-only

[case dataclass_transform_on_overload_with_reassignment]
from typing import dataclass_transform, overload, Callable, Type

@dataclass_transform(frozen_default=True)
@overload
def my_dataclass(*, foo: str) -> Callable[[Type], Type]: ...
@overload
def my_dataclass(*, foo: int) -> Callable[[Type], Type]: ...
def my_dataclass(*, foo) -> Callable[[Type], Type]: ...

# This needs to work, because attrs uses something like this
reassignment = other = my_dataclass

@reassignment(foo="hello")
class A:
    a: int

A(1, "hello")  # E: Too many arguments for "A"
a = A(1)

[case dataclass_transform_invalid_usage]
from typing import dataclass_transform

x = dataclass_transform(frozen_default=True)
x()  # E: "object" not callable
x.y # E: "object" has no attribute "y"
x[0]  # E: Value of type "object" is not indexable
reveal_type(x)  # N: Revealed type is "object"

[case dataclass_transform_conformance_tests]
# Copied from conformance tests (dataclasses_transform_class.py)
from typing import dataclass_transform, Any

class ModelField:
    def __init__(self, *, init: bool = True, default: Any | None = None) -> None: ...

def model_field(*, init: bool = True, default: Any | None = None, alias: str | None = None) -> Any: ...

@dataclass_transform(
    kw_only_default=True,
    field_specifiers=(ModelField, model_field),
)
class ModelBase: ...

class Customer1(ModelBase, frozen=True):
    id: int = model_field()
    name: str = model_field()
    name2: str = model_field(alias="other_name", default="None")

# This should generate an error because a non-frozen dataclass cannot
# derive from a frozen one.
class Customer1Subclass(Customer1):  # E: Non-frozen dataclass cannot inherit from a frozen dataclass
    salary: float = model_field()

c1_1 = Customer1(id=3, name="Sue", other_name="Susan")

[case dataclass_transform_overload]
# Copied from conformance tests (dataclasses_transform_func.py)
from typing import overload, dataclass_transform, Any, TypeVar, Callable
T = TypeVar("T")
@overload
@dataclass_transform(kw_only_default=True, order_default=True)
def create_model(cls: T) -> T: ...


@overload
@dataclass_transform(kw_only_default=True, order_default=True)
def create_model(
    *,
    frozen: bool = False,
    kw_only: bool = True,
    order: bool = True,
) -> Callable[[T], T]: ...


def create_model(*args: Any, **kwargs: Any) -> Any: ...

@create_model(kw_only=False, order=False)
class Customer1:
    id: int
    name: str

c1_1 = Customer1(id=3, name="Sue")
c1_1.id = 4

[case dataclass_enum_combination]
from dataclasses import dataclass
from enum import Enum

@dataclass
class C(Enum):  # E: An Enum cannot be a dataclass
    x = 1
    y: str

C()  # E: Missing positional argument "y" in call to "C"

[case dataclasses_isinstance_narrowing_no_crash]
from dataclasses import dataclass

class A:
    z: str

@dataclass
class X[T]:
    x: T

@dataclass
class Y[T](X[T]):
    y: T

def test(x: Y[int]) -> None:
    if isinstance(x, A):
        reveal_type(x)  # N: Revealed type is "<subclass of "__main__.Y[int]" and "__main__.A">"
        reveal_type(x.x)  # N: Revealed type is "int"
        reveal_type(x.y)  # N: Revealed type is "int"
        reveal_type(x.z)  # N: Revealed type is "str"

[case dataclass_typeddict_combination]
from typing import TypedDict
from dataclasses import dataclass

@dataclass
class C(TypedDict):  # E: A TypedDict cannot be a dataclass
    x = 1  # E: Invalid statement in TypedDict definition; expected "field_name: field_type"
    y: str


C()  # E: Missing keys ("x", "y") for TypedDict "C"

[case dataclass_post_init_should_not_crash1]
import m

def _construct_named_inputs_and_attrs(signature: m.OpSignature): ...

[file m.py]
import dataclasses
from typing import Any

EMPTY = bool()

@dataclasses.dataclass
class OpSignature:
    default: Any = EMPTY

    def __post_init__(self) -> None: ...

[case dataclass_post_init_should_not_crash2]
import m

def f(signature: m.OpSignature): ...

[file m.py]
import dataclasses
from typing import Any

EMPTY = bool()

@dataclasses.dataclass
class OpSignature:
    default: dataclasses.InitVar[Any] = EMPTY

    def __post_init__(self) -> None: ...  # E: Signature of "__post_init__" incompatible with supertype "dataclass" \
                                          # N:      Superclass: \
                                          # N:          def __post_init__(self, default: Any) -> None \
                                          # N:      Subclass: \
                                          # N:          def __post_init__(self) -> None
                                          #
[case dataclass_slots_access]
# Copied from conformance tests (dataclasses_slots.py)
from dataclasses import dataclass
@dataclass(slots=True)
class DC5:
    a: int
DC5.__slots__   
DC5(1).__slots__

[case invalid_frozen_dataclass_base_access]
from dataclasses import dataclass
@dataclass(frozen=True)
class C(Undefined):  # E: Name "Undefined" is not defined
    x: int

x = C(x=1, y=1)
reveal_type(x.x)  # N: Revealed type is "int"
reveal_type(x.y)  # N: Revealed type is "Any"
x.x = 1  # E: Property "x" defined in "C" is read-only
x.y = ""  # E: Property "y" defined in "C" is read-only
