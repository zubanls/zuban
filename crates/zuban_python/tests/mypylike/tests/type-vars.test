[case type_var_value_restriction_in_callable]
from typing import TypeVar, Callable
T = TypeVar('T', int, str)
def f(x: T) -> T: pass
def g1(f: Callable[[str], str]) -> None: pass
g1(f)
def g2(f: Callable[[int], int]) -> None: pass
g2(f)
def g3(f: Callable[[object], object]) -> None: pass
g3(f)  # E: Value of type variable "T" of "g3" cannot be "object"
def g4(f: Callable[[int], str]) -> None: pass
g4(f)  # E: Argument 1 to "g4" has incompatible type "Callable[[T], T]"; expected "Callable[[int], str]"

[case type_var_default_nested]
# From conformance tests
from typing import TypeVar
Y2 = TypeVar("Y2", int, str)
AlsoOk2 = TypeVar("AlsoOk2", int, str, bool, default=Y2)

[case type_var_syntax_bound_nested_type_variables_not_reachable_mypy_compatible]
# flags: --mode mypy
# From conformance tests generics_syntax_declarations.py
class ClassG[V]:
    class ClassD[T: dict[str, V]]:  # E: "V" may not be used, because it's defined in an outer class
        ...

[case type_var_syntax_bound_nested_type_variables_not_reachable_no_mypy_compatible]
# flags: --mode default
# From conformance tests generics_syntax_declarations.py
class ClassG[V]:
    class ClassD[T: dict[str, V]]:  # E: TypeVar bound must not contain type variables
        ...

[case other_type_var_syntax_nested_type_variables_not_reachable]
class C[V]:
    class D[T=list[V]]: ... # E: Type parameter "T" has a default type that refers to one or more type variables that are out of scope
    class E[*Ts=*tuple[V]]: ... # E: Type parameter "Ts" has a default type that refers to one or more type variables that are out of scope
    class F[**P=[V]]: ... # E: Type parameter "P" has a default type that refers to one or more type variables that are out of scope
    class G[T: (V, bytes)]: ... # E: TypeVar constraint type cannot be parametrized by type variables

[case type_var_syntax_allowed_in_keyword_arg_in_class]
# From conformance tests generics_syntax_scoping.py
class Foo[T]: ...
class BaseClassC[T]:
    def __init_subclass__(cls, param: type[Foo[T]]) -> None:
        ...
class ClassC[T](BaseClassC[T], param=Foo[T]):
    ...

[case dataclass_invariant_type_var]
from dataclasses import dataclass
@dataclass
class MutableDataclass[T]:
    x: T


a: MutableDataclass[float] = MutableDataclass[int](1)  # E: Incompatible types in assignment (expression has type "MutableDataclass[int]", variable has type "MutableDataclass[float]")

@dataclass(frozen=True)
class FrozenDataclass[T]:
    x: T

b: FrozenDataclass[float] = FrozenDataclass[int](1)

[case infer_variance_basic_errors]
# Copied partially from conformance tests (generics_syntax_infer_variance.py)
from typing import TypeVar


T = TypeVar("T", infer_variance=True)
S1 = TypeVar("S1", covariant=True, infer_variance=True)  # E: Cannot use covariant with infer_variance
S2 = TypeVar("S2", contravariant=True, infer_variance=True)  # E: Cannot use contravariant with infer_variance
S3 = TypeVar("S3", infer_variance=True, covariant=True)  # E: Cannot use covariant with infer_variance
S4 = TypeVar("S4", infer_variance=True, contravariant=True)  # E: Cannot use contravariant with infer_variance

S5 = TypeVar("S5", infer_variance="")  # E: TypeVar "infer_variance" may only be a literal bool
S6 = TypeVar("S6", infer_variance=False, covariant=True)
S7 = TypeVar("S7", covariant=True, infer_variance=False)

[case infer_variance_conformance_tests_valid1]
# Copied from conformance tests (generics_syntax_infer_variance.py)

from typing import Generic, Iterator, Sequence, TypeVar
from dataclasses import dataclass

T = TypeVar("T", infer_variance=True)

class ShouldBeCovariant1(Generic[T]):
    def __getitem__(self, index: int) -> T:
        ...

    def __iter__(self) -> Iterator[T]: ...

vco1_1: ShouldBeCovariant1[float] = ShouldBeCovariant1[int]()  # OK
vco1_2: ShouldBeCovariant1[int] = ShouldBeCovariant1[float]()  # E: Incompatible types in assignment (expression has type "ShouldBeCovariant1[float]", variable has type "ShouldBeCovariant1[int]")

class ShouldBeCovariant2(Sequence[T]):
    pass

vco2_1: ShouldBeCovariant2[float] = ShouldBeCovariant2[int]()  # OK
vco2_2: ShouldBeCovariant2[int] = ShouldBeCovariant2[float]()  # E: Incompatible types in assignment (expression has type "ShouldBeCovariant2[float]", variable has type "ShouldBeCovariant2[int]")

class ShouldBeCovariant3(Generic[T]):
    def method1(self) -> "ShouldBeCovariant2[T]": ...

vco3_1: ShouldBeCovariant3[float] = ShouldBeCovariant3[int]()  # OK
vco3_2: ShouldBeCovariant3[int] = ShouldBeCovariant3[float]()  # E: Incompatible types in assignment (expression has type "ShouldBeCovariant3[float]", variable has type "ShouldBeCovariant3[int]")

@dataclass(frozen=True)
class ShouldBeCovariant4(Generic[T]):
    x: T

[case class_type_var_should_be_self_generics_and_not_error]
# flags: --mode default
from typing import Final, Generic, TypeVar

T = TypeVar("T", covariant=True)

class C(Generic[T]):
    x: Final[T]

    def __init__(self, value: T):
        self.x = value

C[int](1)

[case infer_variance_conformance_tests_valid2]
# flags: --mode default
# Copied from conformance tests (generics_syntax_infer_variance.py)
from typing import Final, Generic, Iterator, Sequence, TypeVar
from dataclasses import dataclass

T = TypeVar("T", infer_variance=True)
K = TypeVar("K", infer_variance=True)
V = TypeVar("V", infer_variance=True)

class ShouldBeCovariant5(Generic[T]):
    def __init__(self, x: T) -> None:
        self._x = x

    @property
    def x(self) -> T:
        return self._x

vo5_1: ShouldBeCovariant5[float] = ShouldBeCovariant5[int](1)  # OK
vo5_2: ShouldBeCovariant5[int] = ShouldBeCovariant5[float](1.0)  # E: Incompatible types in assignment (expression has type "ShouldBeCovariant5[float]", variable has type "ShouldBeCovariant5[int]")

class ShouldBeCovariant6(Generic[T]):
    x: Final[T]

    def __init__(self, value: T):
        self.x = value

vo6_1: ShouldBeCovariant6[float] = ShouldBeCovariant6[int](1)  # OK
vo6_2: ShouldBeCovariant6[int] = ShouldBeCovariant6[float](1.0)  # E: Incompatible types in assignment (expression has type "ShouldBeCovariant6[float]", variable has type "ShouldBeCovariant6[int]")

class ShouldBeInvariant1(Generic[T]):
    def __init__(self, value: T) -> None:
        self._value = value

    @property
    def value(self) -> T:
        return self._value

    @value.setter
    def value(self, value: T):
        self._value = value

vinv1_1: ShouldBeInvariant1[float] = ShouldBeInvariant1[int](1)  # E: Incompatible types in assignment (expression has type "ShouldBeInvariant1[int]", variable has type "ShouldBeInvariant1[float]")
vinv1_2: ShouldBeInvariant1[int] = ShouldBeInvariant1[float](1.1)  # E: Incompatible types in assignment (expression has type "ShouldBeInvariant1[float]", variable has type "ShouldBeInvariant1[int]")

class ShouldBeInvariant2(Generic[T]):
    def __init__(self, value: T) -> None:
        self._value = value

    def get_value(self) -> T:
        return self._value

    def set_value(self, value: T):
        self._value = value

vinv2_1: ShouldBeInvariant2[float] = ShouldBeInvariant2[int](1)  # E: Incompatible types in assignment (expression has type "ShouldBeInvariant2[int]", variable has type "ShouldBeInvariant2[float]")
vinv2_2: ShouldBeInvariant2[int] = ShouldBeInvariant2[float](1.1)  # E: Incompatible types in assignment (expression has type "ShouldBeInvariant2[float]", variable has type "ShouldBeInvariant2[int]")

class ShouldBeInvariant3(dict[K, V]):
    pass

vinv3_1: ShouldBeInvariant3[float, str] = ShouldBeInvariant3[int, str]()  # E: Incompatible types in assignment (expression has type "ShouldBeInvariant3[int, str]", variable has type "ShouldBeInvariant3[float, str]")
vinv3_2: ShouldBeInvariant3[int, str] = ShouldBeInvariant3[float, str]()  # E: Incompatible types in assignment (expression has type "ShouldBeInvariant3[float, str]", variable has type "ShouldBeInvariant3[int, str]")
vinv3_3: ShouldBeInvariant3[str, float] = ShouldBeInvariant3[str, int]()  # E: Incompatible types in assignment (expression has type "ShouldBeInvariant3[str, int]", variable has type "ShouldBeInvariant3[str, float]")
vinv3_4: ShouldBeInvariant3[str, int] = ShouldBeInvariant3[str, float]()  # E: Incompatible types in assignment (expression has type "ShouldBeInvariant3[str, float]", variable has type "ShouldBeInvariant3[str, int]")

@dataclass
class ShouldBeInvariant4[T]:
    x: T

vinv4_1: ShouldBeInvariant4[float] = ShouldBeInvariant4[int](1)  # E: Incompatible types in assignment (expression has type "ShouldBeInvariant4[int]", variable has type "ShouldBeInvariant4[float]")

class ShouldBeInvariant5[T]:
    def __init__(self, x: T) -> None:
        self.x = x

vinv5_1: ShouldBeInvariant5[float] = ShouldBeInvariant5[int](1)  # E: Incompatible types in assignment (expression has type "ShouldBeInvariant5[int]", variable has type "ShouldBeInvariant5[float]")

class ShouldBeContravariant1(Generic[T]):
    def __init__(self, value: T) -> None:
        pass

    def set_value(self, value: T):
        pass

vcontra1_1: ShouldBeContravariant1[float] = ShouldBeContravariant1[int](1)  # E: Incompatible types in assignment (expression has type "ShouldBeContravariant1[int]", variable has type "ShouldBeContravariant1[float]")
vcontra1_2: ShouldBeContravariant1[int] = ShouldBeContravariant1[float](1.2)  # OK

[case type_var_default_with_never]
class C[T, U=T]: ...

reveal_type(C())  # N: Revealed type is "__main__.C[Any, Any]"

[case type_var_default_with_usage_before_generic]
from typing import TypeVar, Generic, Iterable
T = TypeVar("T")
U = TypeVar("U", default=T)

class Something[T]: ...
class C(Iterable[U], Something[T], Generic[T, U]): ...

def foo() -> C[int]: ...

reveal_type(foo())  # N: Revealed type is "__main__.C[int, int]"

[case type_vars_in_bounds_not_allowed_in_conformance_tests]
# flags: --mode default
from typing import TypeVar, Generic
T = TypeVar("T")

class Test(Generic[T]):
    T_Bad1 = TypeVar("T_Bad1", bound=list[T])  # E: TypeVar bound must not contain type variables

[case generics_default_not_allowed_after_type_var_tuple]
# Partially from conformance tests (generics_defaults.py)
from typing import TypeVarTuple, TypeVar, Generic
Ts = TypeVarTuple("Ts")
T5 = TypeVar("T5", default=bool)

class Foo5(Generic[*Ts, T5]): ...  # E: TypeVar defaults are ambiguous after a TypeVarTuple
class Other(Generic[*Ts, T5]): ...  # E: TypeVar defaults are ambiguous after a TypeVarTuple

[case generics_default_for_param_specs_after_type_var_tuple]
# From conformance tests (generics_defaults.py)
from typing import TypeVarTuple, ParamSpec, Generic, assert_type

Ts = TypeVarTuple("Ts")
P = ParamSpec("P", default=[float, bool])

class Foo6(Generic[*Ts, P]): ...  # OK

assert_type(Foo6[int, str], type[Foo6[int, str, [float, bool]]])
assert_type(Foo6[int, str, [bytes]], type[Foo6[int, str, [bytes]]])

[case type_var_default_with_method_access_and_self_resolution]
# Inspiered by conformance tests (generics_defaults.py)
from typing import TypeVar, Generic, assert_type, Callable, Self
DefaultIntT = TypeVar("DefaultIntT", default=int)
class Foo7(Generic[DefaultIntT]):
    def meth(self, /) -> Self:
        return self

    attr: DefaultIntT

reveal_type(Foo7.meth(Foo7[int]()))  # N: Revealed type is "__main__.Foo7[int]"
reveal_type(Foo7.meth(Foo7()))  # N: Revealed type is "__main__.Foo7[int]"
assert_type(Foo7().attr, int)

[case type_var_ensure_correct_variance_contravariance]
# Partially copied from conformance tests (generics_variance.py)
from typing import TypeVar, Generic

T_co = TypeVar("T_co", covariant=True)
T_contra = TypeVar("T_contra", contravariant=True)

class Co(Generic[T_co]): ...
class Contra(Generic[T_contra]): ...

Co_TA = Co[T_co]
Contra_TA = Contra[T_contra]

class CoToContraToContra_WithTA(Contra_TA[Co_TA[Contra_TA[T_contra]]]):  # E: Variance of TypeVar "T_contra" incompatible with variance in parent type
    ...

class CoToContraToContra_WithTA_valid(Contra_TA[Co_TA[Contra_TA[T_co]]]):
    ...

class ContraToContraToContra_WithTA(
    Contra_TA[Contra_TA[Contra_TA[T_co]]]  # E: Variance of TypeVar "T_co" incompatible with variance in parent type
):
    ...

class ContraToContraToContra_WithTA_valid(
    Contra_TA[Contra_TA[Contra_TA[T_contra]]]
):
    ...

[case narrowing_on_type_vars_from_syntax]
from typing import assert_type, TypeVar

T = int(0)

class Outer2[T]:
    T = int(1)

    assert_type(T, int)

    class Inner1:
        T = str("")

        assert_type(T, str)

        def inner_method(self):
            assert_type(T, TypeVar)

    def outer_method(self):
        T = 3j

        assert_type(T, complex)

        def inner_func():
            assert_type(T, complex)

[case class_type_param_in_closure]
def requires_int(arg: int):
    pass

class Outer[T: int]:
    def inner(self, arg: T) -> T:
        def closure(arg: T) -> T:
            requires_int(arg)
            return arg
        requires_int(arg)
        closure(arg) # OK
        closure(42) # E: Argument 1 to "closure" has incompatible type "int"; expected "T"
        return closure(arg) # OK

    def inner2(self, arg: T) -> T:
        def closure[U](arg: T) -> T:
            requires_int(arg)
            return arg
        requires_int(arg)
        closure(arg) # OK
        closure(42) # E: Argument 1 to "closure" has incompatible type "int"; expected "T"
        return closure(arg) # OK

[case generic_class_type_param_in_closure]
from typing import Generic, TypeVar

T = TypeVar("T", bound=int)

def requires_int(arg: int):
    pass

class Outer(Generic[T]):
    def inner(self, arg: T) -> T:
        def closure(arg: T) -> T:
            requires_int(arg)
            return arg
        requires_int(arg)
        closure(arg) # OK
        # Make sure T is bound to the value of T in Outer and not
        # just a free TypeVar
        closure(42) # E: Argument 1 to "closure" has incompatible type "int"; expected "T"
        return closure(arg) # OK

    def inner2(self, arg: T) -> T:
        def closure[U](arg: T) -> T:
            requires_int(arg)
            return arg
        requires_int(arg)
        closure(arg) # OK
        closure(42) # E: Argument 1 to "closure" has incompatible type "int"; expected "T"
        return closure(arg) # OK

[case generic_class_type_params_nested_access]
class Outer[T]:
    class Inner[S]:
        def foo[U](self, s: S, t: T, u: U):  # E: Type variable "T" is bound by an outer class
            x: S
            y: T  # E: Type variable "T" is bound by an outer class
            z: U
            def inner[V](s: S, t: T, u: U, v: V):  # E: Type variable "T" is bound by an outer class
                x: S
                y: T  # E: Type variable "T" is bound by an outer class
                z: U
                a: V

[case generic_class_in_function_in_generic_class]
from typing import Callable, assert_type

class Outer[T]:
    def inner(self, arg: T) -> Callable[[T], T]:
        class Inner:
            def __call__(self, arg: T) -> T:
                return arg
        assert_type(Inner()(arg), T) # OK
        return Inner() # OK

[case avoid_overflow_for_recursive_type_var_default]
# flags: --warn-no-return
# From GH #256
def a[T=T]() -> T:  # E: Missing return statement  # E: Type parameter "T" has a default type that refers to one or more type variables that are out of scope
    x: T = 1  # E: Incompatible types in assignment (expression has type "int", variable has type "T = Any")
