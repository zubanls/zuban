[case type_var_value_restriction_in_callable]
from typing import TypeVar, Callable
T = TypeVar('T', int, str)
def f(x: T) -> T: pass
def g1(f: Callable[[str], str]) -> None: pass
g1(f)
def g2(f: Callable[[int], int]) -> None: pass
g2(f)
def g3(f: Callable[[object], object]) -> None: pass
g3(f)  # E: Value of type variable "T" of "g3" cannot be "object"
def g4(f: Callable[[int], str]) -> None: pass
g4(f)  # E: Argument 1 to "g4" has incompatible type "Callable[[T], T]"; expected "Callable[[int], str]"

[case type_var_default_nested]
# From conformance tests
from typing import TypeVar
Y2 = TypeVar("Y2", int, str)
AlsoOk2 = TypeVar("AlsoOk2", int, str, bool, default=Y2)

[case type_var_syntax_bound_nested_type_variables_not_reachable]
# From conformance tests generics_syntax_declarations.py
class ClassG[V]:
    class ClassD[T: dict[str, V]]:  # E: "V" may not be used, because it's defined in an outer class
        ...

[case other_type_var_syntax_nested_type_variables_not_reachable]
class C[V]:
    class D[T=list[V]]: ... # E: Type parameter "T" has a default type that refers to one or more type variables that are out of scope
    class E[*Ts=*tuple[V]]: ... # E: Type parameter "Ts" has a default type that refers to one or more type variables that are out of scope
    class F[**P=[V]]: ... # E: Type parameter "P" has a default type that refers to one or more type variables that are out of scope
    class G[T: (V, bytes)]: ... # E: TypeVar constraint type cannot be parametrized by type variables

[case type_var_syntax_allowed_in_keyword_arg_in_class]
# From conformance tests generics_syntax_scoping.py
class Foo[T]: ...
class BaseClassC[T]:
    def __init_subclass__(cls, param: type[Foo[T]]) -> None:
        ...
class ClassC[T](BaseClassC[T], param=Foo[T]):
    ...

[case dataclass_invariant_type_var]
from dataclasses import dataclass
@dataclass
class MutableDataclass[T]:
    x: T


a: MutableDataclass[float] = MutableDataclass[int](1)  # E: Incompatible types in assignment (expression has type "MutableDataclass[int]", variable has type "MutableDataclass[float]")

@dataclass(frozen=True)
class FrozenDataclass[T]:
    x: T

b: FrozenDataclass[float] = FrozenDataclass[int](1)

[case infer_variance_basic_errors]
# Copied partially from conformance tests (generics_syntax_infer_variance.py)
from typing import TypeVar


T = TypeVar("T", infer_variance=True)
S1 = TypeVar("S1", covariant=True, infer_variance=True)  # E: Cannot use covariant with infer_variance
S2 = TypeVar("S2", contravariant=True, infer_variance=True)  # E: Cannot use contravariant with infer_variance
S3 = TypeVar("S3", infer_variance=True, covariant=True)  # E: Cannot use covariant with infer_variance
S4 = TypeVar("S4", infer_variance=True, contravariant=True)  # E: Cannot use contravariant with infer_variance

S5 = TypeVar("S5", infer_variance="")  # E: TypeVar "infer_variance" may only be a literal bool
S6 = TypeVar("S6", infer_variance=False, covariant=True)
S7 = TypeVar("S7", covariant=True, infer_variance=False)

[case infer_variance_conformance_tests_valid1]
# Copied from conformance tests (generics_syntax_infer_variance.py)

from typing import Generic, Iterator, Sequence, TypeVar
from dataclasses import dataclass

T = TypeVar("T", infer_variance=True)

class ShouldBeCovariant1(Generic[T]):
    def __getitem__(self, index: int) -> T:
        ...

    def __iter__(self) -> Iterator[T]: ...

vco1_1: ShouldBeCovariant1[float] = ShouldBeCovariant1[int]()  # OK
vco1_2: ShouldBeCovariant1[int] = ShouldBeCovariant1[float]()  # E: Incompatible types in assignment (expression has type "ShouldBeCovariant1[float]", variable has type "ShouldBeCovariant1[int]")

class ShouldBeCovariant2(Sequence[T]):
    pass

vco2_1: ShouldBeCovariant2[float] = ShouldBeCovariant2[int]()  # OK
vco2_2: ShouldBeCovariant2[int] = ShouldBeCovariant2[float]()  # E: Incompatible types in assignment (expression has type "ShouldBeCovariant2[float]", variable has type "ShouldBeCovariant2[int]")

class ShouldBeCovariant3(Generic[T]):
    def method1(self) -> "ShouldBeCovariant2[T]": ...

vco3_1: ShouldBeCovariant3[float] = ShouldBeCovariant3[int]()  # OK
vco3_2: ShouldBeCovariant3[int] = ShouldBeCovariant3[float]()  # E: Incompatible types in assignment (expression has type "ShouldBeCovariant3[float]", variable has type "ShouldBeCovariant3[int]")

@dataclass(frozen=True)
class ShouldBeCovariant4(Generic[T]):
    x: T

[case infer_variance_conformance_tests_valid2]
# Copied from conformance tests (generics_syntax_infer_variance.py)
from typing import Final, Generic, Iterator, Sequence, TypeVar
from dataclasses import dataclass

T = TypeVar("T", infer_variance=True)
K = TypeVar("K", infer_variance=True)
V = TypeVar("V", infer_variance=True)

class ShouldBeCovariant5(Generic[T]):
    def __init__(self, x: T) -> None:
        self._x = x

    @property
    def x(self) -> T:
        return self._x

vo5_1: ShouldBeCovariant5[float] = ShouldBeCovariant5[int](1)  # OK
vo5_2: ShouldBeCovariant5[int] = ShouldBeCovariant5[float](1.0)  # E: Incompatible types in assignment (expression has type "ShouldBeCovariant5[float]", variable has type "ShouldBeCovariant5[int]")

class ShouldBeCovariant6(Generic[T]):
    x: Final[T]  # E: Final name declared in class body cannot depend on type variables

    def __init__(self, value: T):
        self.x = value

vo6_1: ShouldBeCovariant6[float] = ShouldBeCovariant6[int](1)  # OK  # E: Incompatible types in assignment (expression has type "ShouldBeCovariant6[int]", variable has type "ShouldBeCovariant6[float]")
vo6_2: ShouldBeCovariant6[int] = ShouldBeCovariant6[float](1.0)  # E: Incompatible types in assignment (expression has type "ShouldBeCovariant6[float]", variable has type "ShouldBeCovariant6[int]")

class ShouldBeInvariant1(Generic[T]):
    def __init__(self, value: T) -> None:
        self._value = value

    @property
    def value(self) -> T:
        return self._value

    @value.setter
    def value(self, value: T):
        self._value = value

vinv1_1: ShouldBeInvariant1[float] = ShouldBeInvariant1[int](1)  # E: Incompatible types in assignment (expression has type "ShouldBeInvariant1[int]", variable has type "ShouldBeInvariant1[float]")
vinv1_2: ShouldBeInvariant1[int] = ShouldBeInvariant1[float](1.1)  # E: Incompatible types in assignment (expression has type "ShouldBeInvariant1[float]", variable has type "ShouldBeInvariant1[int]")

class ShouldBeInvariant2(Generic[T]):
    def __init__(self, value: T) -> None:
        self._value = value

    def get_value(self) -> T:
        return self._value

    def set_value(self, value: T):
        self._value = value

vinv2_1: ShouldBeInvariant2[float] = ShouldBeInvariant2[int](1)  # E: Incompatible types in assignment (expression has type "ShouldBeInvariant2[int]", variable has type "ShouldBeInvariant2[float]")
vinv2_2: ShouldBeInvariant2[int] = ShouldBeInvariant2[float](1.1)  # E: Incompatible types in assignment (expression has type "ShouldBeInvariant2[float]", variable has type "ShouldBeInvariant2[int]")

class ShouldBeInvariant3(dict[K, V]):
    pass

vinv3_1: ShouldBeInvariant3[float, str] = ShouldBeInvariant3[int, str]()  # E: Incompatible types in assignment (expression has type "ShouldBeInvariant3[int, str]", variable has type "ShouldBeInvariant3[float, str]")
vinv3_2: ShouldBeInvariant3[int, str] = ShouldBeInvariant3[float, str]()  # E: Incompatible types in assignment (expression has type "ShouldBeInvariant3[float, str]", variable has type "ShouldBeInvariant3[int, str]")
vinv3_3: ShouldBeInvariant3[str, float] = ShouldBeInvariant3[str, int]()  # E: Incompatible types in assignment (expression has type "ShouldBeInvariant3[str, int]", variable has type "ShouldBeInvariant3[str, float]")
vinv3_4: ShouldBeInvariant3[str, int] = ShouldBeInvariant3[str, float]()  # E: Incompatible types in assignment (expression has type "ShouldBeInvariant3[str, float]", variable has type "ShouldBeInvariant3[str, int]")

@dataclass
class ShouldBeInvariant4[T]:
    x: T

vinv4_1: ShouldBeInvariant4[float] = ShouldBeInvariant4[int](1)  # E: Incompatible types in assignment (expression has type "ShouldBeInvariant4[int]", variable has type "ShouldBeInvariant4[float]")

class ShouldBeInvariant5[T]:
    def __init__(self, x: T) -> None:
        self.x = x

vinv5_1: ShouldBeInvariant5[float] = ShouldBeInvariant5[int](1)  # E: Incompatible types in assignment (expression has type "ShouldBeInvariant5[int]", variable has type "ShouldBeInvariant5[float]")

class ShouldBeContravariant1(Generic[T]):
    def __init__(self, value: T) -> None:
        pass

    def set_value(self, value: T):
        pass

vcontra1_1: ShouldBeContravariant1[float] = ShouldBeContravariant1[int](1)  # E: Incompatible types in assignment (expression has type "ShouldBeContravariant1[int]", variable has type "ShouldBeContravariant1[float]")
vcontra1_2: ShouldBeContravariant1[int] = ShouldBeContravariant1[float](1.2)  # OK

[case type_var_default_with_never]
class C[T, U=T]: ...

reveal_type(C())  # N: Revealed type is "__main__.C[Never, Never]"

[case type_var_default_with_usage_before_generic]
from typing import TypeVar, Generic, Iterable
T = TypeVar("T")
U = TypeVar("U", default=T)

class Something[T]: ...
class C(Iterable[U], Something[T], Generic[T, U]): ...

def foo() -> C[int]: ...

reveal_type(foo())  # N: Revealed type is "__main__.C[int, int]"
