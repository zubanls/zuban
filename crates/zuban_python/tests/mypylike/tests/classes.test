[case duplicate_base_class_of_tuple]

class A(tuple, tuple): ...  # E: Duplicate base class "tuple"
class B(tuple[int, str], tuple): ...  # E: Duplicate base class "tuple"
class C(tuple, tuple[int, ...]): ...  # E: Duplicate base class "tuple"
class D(tuple[str], tuple[int, ...]): ...  # E: Duplicate base class "tuple"

class X(tuple[str, int]): ...
class Y(tuple[str, ...]): ...
class Z(tuple): ...

[case duplicate_base_class_of_type]

class A(type, type): ...  # E: Duplicate base class "type"
class B(type[int], type): ...  # E: Invalid base class "type[int]"
class C(type, type[int]): ...  # E: Invalid base class "type[int]"
class D(type[str], type[int]): ...  # E: Invalid base class "type[str]" # E: Invalid base class "type[int]"

class X(type): ...

[case base_class_of_type]
from typing import Type

class A(Type[int]): ...  # E: Invalid base class "Type[int]"
class B(type[int]): ...  # E: Invalid base class "type[int]"
class C(Type): ...  # E: Invalid base class "Type"
class D(type): ...

[case function_as_invalid_base_class]
def untyped(): ...
def typed() -> None: ...
class A(abs): ...  # E: Invalid base class "abs"
class B(untyped): ...  # E: Invalid base class "untyped"
class C(typed): ...  # E: Invalid base class "typed"

[case generic_metaclasses_are_invalid_according_to_mypy]
from typing import Generic, TypeVar

T = TypeVar("T")

class Meta(type, Generic[T]):
    def f(cls) -> T: ...

class A(metaclass=Meta[int]): ...  # E: Invalid metaclass "Meta[int]"

[case metaclass_inheritance]
class MyMeta1(type): ...
class MyMeta2(type): ...
class MyMeta3(MyMeta1, MyMeta2): ...
class A(metaclass=MyMeta1): ...
class B(metaclass=MyMeta2): ...
class C(metaclass=MyMeta3): ...

class Try1(A, B): ... # E: Metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases
class Try2(B, A): ... # E: Metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases
class Try3(C, A): ...
class Try4(A, C): ...

[case self_type_in_metaclass]
# Similar to testTypingSelfMetaClassDisabled, but with additional tests
from typing import Self, Any

class Meta(type):
    def __new__(cls, *args: Any) -> Self:  # E: Self type cannot be used in a metaclass
        return 1
    def meth(cls) -> Self: ...  # E: Self type cannot be used in a metaclass
    def other(cls, next: Self) -> None: ...  # E: Self type cannot be used in a metaclass
    x: Self  # E: Self type cannot be used in a metaclass

class Bar(metaclass=Meta): ...

reveal_type(Bar.x)  # N: Revealed type is "Any"
reveal_type(Bar.meth)  # N: Revealed type is "def () -> Any"
reveal_type(Bar.other)  # N: Revealed type is "def (next: Any)"

[case metaclass_descriptor]
from typing import TypeVar, Tuple
T = TypeVar("T")
S = TypeVar("S")
class Descriptor():
    def __get__(self, instance: S, cls: T) -> Tuple[S, T]:
        return instance, cls

class Meta(type):
    a = Descriptor()


class A(metaclass=Meta): ...

# This differs in Mypy and CPython:
# >>> A.a
# (<class '__main__.A'>, <class '__main__.Meta'>)
# However in mypy it's tuple[None, Type[x2.A@1369]]
reveal_type(A.a)  # N: Revealed type is "tuple[type[__main__.A], type[type[__main__.A]]]"
reveal_type(Meta(A()).a)  # N: Revealed type is "tuple[__main__.Meta, type[__main__.Meta]]"

[case metaclass_iter_on_type_bound]
# Similar to testInferringLvarTypesUnpackedFromIterableClassObject, but with
# bounds
from typing import Iterator, Type, TypeVar, Union, overload
class Meta(type):
    def __iter__(cls) -> Iterator[int]: raise NotImplementedError

class Meta2(type):
    def __iter__(cls) -> Iterator[str]: raise NotImplementedError

class Meta3(type): ...

class Foo(metaclass=Meta): ...
class Bar(metaclass=Meta2): ...
class Baz(metaclass=Meta3): ...
class Spam: ...

T = TypeVar("T", bound=Foo)
def check_bound1(x: Type[T]) -> None:
    for var in x:
        reveal_type(var)  # N: Revealed type is "int"

U = TypeVar("U", bound=Foo | Bar)
def check_bound2(x: Type[U]) -> None:
    for var in x:
        reveal_type(var)  # N: Revealed type is "int | str"

V = TypeVar("V", bound=Bar | Baz | Spam)
def check_bound3(x: Type[V]) -> None:
    for var in x:  # E: "type[Baz]" has no attribute "__iter__" (not iterable) \
                   # E: "type[Spam]" has no attribute "__iter__" (not iterable)
        reveal_type(var)  # N: Revealed type is "str | Any"

[case kwargs_base_class]
from typing import Type, Any
foo: dict[str, Type[Any]]

class Bar(**foo): ...

[case staticmethod_and_classmethod]
# This is tested in testClassMethodAndStaticMethod, but only one side, so test
# both here.
class C:
  @classmethod  # E: Cannot have both classmethod and staticmethod
  @staticmethod
  def foo(cls) -> None: pass

  @staticmethod  # E: Cannot have both classmethod and staticmethod
  @classmethod
  def bar(cls) -> None: pass

[case overloaded_property_not_possible]
# flags: --mode mypy
# There's also testOverloadedProperty, but it's not complete
from typing import overload
class A:
    @property  # E: An overload can not be a property
    @overload
    def f(self) -> int: pass
    @property  # E: An overload can not be a property # E: Name "f" already defined on line 5
    @overload
    def f(self) -> int: pass

class B:
    @property  # E: An overload can not be a property
    @overload
    def f(self) -> int: pass
    @property  # E: An overload can not be a property  # E: Name "f" already defined on line 13
    @overload
    def f(self) -> int: pass
    @property  # E: Name "f" already defined on line 13
    def f(self) -> int: pass

reveal_type(A().f)  # N: Revealed type is "Any"
reveal_type(B().f)  # N: Revealed type is "Any"

[case invalid_args_for_property]
# Similar to testInvalidArgCountForProperty, but a few more cases
from typing import Callable, Any

def any(f: Callable[[Any], int]) -> Callable[..., int]: ...

class A:
    @property
    @any
    def f(self) -> int: pass

[case property_generic_access]
# Make sure this is tested
from typing import Callable, TypeVar, Generic

T = TypeVar("T")

class A(Generic[T]):
    def __init__(self, x: T):
        self.x = x

    @property
    def f(self) -> T: return self.x

x: A[int]

reveal_type(x.f)  # N: Revealed type is "int"

reveal_type(A("").f)  # N: Revealed type is "str"

[case super_with_explicit_self]
# There's testSuperWithGenericSelf, but nothing with explict Self arguments
# AFAIK
from typing import Self

class B:
    def f(self) -> float: pass

class C(B):
    def f(self) -> int: pass

    def g(self: Self) -> Self:
        reveal_type(super(C, self).f) # N: Revealed type is "def () -> float"
        return self

[case super_self_lookup]
class Bar:
    def f1(self) -> None:
        self.bar = 1
class Foo(Bar):
    def f2(self) -> None:
        self.foo = 1
        reveal_type(super().foo)  # E: "foo" undefined in superclass # N: Revealed type is "Any"
        reveal_type(super().bar)  # E: "bar" undefined in superclass # N: Revealed type is "Any"

[case class_var_in_method_annotation]
from typing import ClassVar

class Foo:
    def method1(self, x: ClassVar) -> None: ...  # E: ClassVar can only be used for assignments in class body
    def method2(self, x: ClassVar[int]) -> None: ...  # E: ClassVar can only be used for assignments in class body
    def method3(self) -> ClassVar: ...  # E: ClassVar can only be used for assignments in class body
    def method4(self) -> ClassVar[int]: ...  # E: ClassVar can only be used for assignments in class body

[case self_callable]
from typing import Callable
class Foo:
    def __init__(self) -> None:
        o: Callable[[], Callable[[Foo, int], None]]
        self.foo: Callable[[Foo, int], str]
        self.bar = self.foo
        self.bla = o()

reveal_type(Foo().foo)  # N: Revealed type is "def (__main__.Foo, int) -> str"
reveal_type(Foo().bar)  # N: Revealed type is "def (__main__.Foo, int) -> str"
reveal_type(Foo().bla)  # N: Revealed type is "def (__main__.Foo, int)"
Foo.foo  # E: "type[Foo]" has no attribute "foo"

[case callable_on_class_with_classvar]
from typing import Callable, ClassVar
class Foo:
    o: ClassVar[Callable[[], Callable[[Foo, int], None]]]
    foo: ClassVar[Callable[[Foo, int], str]]
    bar = foo
    bla = o()

reveal_type(Foo.foo)  # N: Revealed type is "def (__main__.Foo, int) -> str"
reveal_type(Foo.bar)  # N: Revealed type is "def (__main__.Foo, int) -> str"
reveal_type(Foo.bla)  # N: Revealed type is "def (__main__.Foo, int)"

reveal_type(Foo().foo)  # N: Revealed type is "def (int) -> str"
reveal_type(Foo().bar)  # N: Revealed type is "def (int) -> str"
reveal_type(Foo().bla)  # N: Revealed type is "def (int)"

[case callable_on_class_without_classvar_mypy_compatible]
# flags: --mode mypy
from typing import Callable
class Foo:
    o: Callable[[], Callable[[Foo, int], None]]
    foo: Callable[[Foo, int], str]
    bar = foo
    bla = o()

reveal_type(Foo.foo)  # N: Revealed type is "def (__main__.Foo, int) -> str"
reveal_type(Foo.bar)  # N: Revealed type is "def (__main__.Foo, int) -> str"
reveal_type(Foo.bla)  # N: Revealed type is "def (__main__.Foo, int)"

reveal_type(Foo().foo)  # N: Revealed type is "def (__main__.Foo, int) -> str"
reveal_type(Foo().bar)  # N: Revealed type is "def (__main__.Foo, int) -> str"
reveal_type(Foo().bla)  # N: Revealed type is "def (int)"

[case callable_on_class_without_classvar_no_mypy_compatible]
# flags: --mode default
from typing import Callable
class Foo:
    o: Callable[[], Callable[[Foo, int], None]]
    foo: Callable[[Foo, int], str]
    bar = foo
    bla = o()

reveal_type(Foo.foo)  # N: Revealed type is "def (__main__.Foo, int) -> str"
reveal_type(Foo.bar)  # N: Revealed type is "def (__main__.Foo, int) -> str"
reveal_type(Foo.bla)  # N: Revealed type is "def (__main__.Foo, int)"

reveal_type(Foo().foo)  # N: Revealed type is "def (int) -> str"
reveal_type(Foo().bar)  # N: Revealed type is "def (int) -> str"
reveal_type(Foo().bla)  # N: Revealed type is "def (int)"

[case self_method_assignment_mypy_compatible]
# flags: --mode mypy
# The conformance tests work want different behavior, but this is not how Mypy works.
from typing import Callable, Self
class CallableAttribute:
    def foo(self) -> int:
        return 0
    bar: Callable[[Self], int] = foo

reveal_type(CallableAttribute.bar)  # E: Access to generic instance variables via class is ambiguous  # N: Revealed type is "def (__main__.CallableAttribute) -> int"
reveal_type(CallableAttribute().bar)  # N: Revealed type is "def (__main__.CallableAttribute) -> int"

[case self_method_assignment_no_mypy_compatible]
# flags: --mode default
# From conformance tests (generics_self_usage.py)
from typing import Callable, Self
class CallableAttribute:
    def foo(self) -> int:
        return 0

    # Accepted (treated as an @property returning the Callable type)
    bar: Callable[[Self], int] = foo

# TODO this error should not be there
reveal_type(CallableAttribute.bar)  # E: Access to generic instance variables via class is ambiguous # N: Revealed type is "def (__main__.CallableAttribute) -> int"
reveal_type(CallableAttribute().bar)  # N: Revealed type is "def () -> int"

[case callable_mapped_via_class1]
from typing import Callable, ClassVar
class Foo:
    foo: ClassVar[Callable[[Foo, Bar, int], None]]
class Bar:
    bar = Foo().foo

reveal_type(Bar.bar)  # N: Revealed type is "def (__main__.Bar, int)"
reveal_type(Bar().bar)  # N: Revealed type is "def (int)"

[case callable_mapped_via_class2]
class Foo:
    def foo(self, bar: Bar, other: int) -> None: ...
class Bar:
    bar = Foo().foo

reveal_type(Bar.bar)  # N: Revealed type is "def (bar: __main__.Bar, other: int)"
# This might not work in Mypy. As of 47480a5dc, this leads to the same type,
# but also an error:
# Invalid self argument "Bar" to attribute function "bar" with type "Callable[[Bar, int], None]"
reveal_type(Bar().bar)  # N: Revealed type is "def (other: int)"

[case generic_descriptor]
from typing import Generic, TypeVar
T = TypeVar("T")

class Descriptor(Generic[T]):
    def __get__(self, instance, cls) -> T:
        raise NotImplementedError

class Foo(Generic[T]):
    def __init__(self, x: T):
        raise NotImplementedError

    d1: Descriptor[T]
    d2 = Descriptor[T]()

reveal_type(Foo(1).d1)  # N: Revealed type is "int"
reveal_type(Foo(1).d2)  # N: Revealed type is "int"
reveal_type(Foo[int].d1)  # E: Access to generic instance variables via class is ambiguous \
                          # N: Revealed type is "int"
reveal_type(Foo[int].d2)  # N: Revealed type is "int"

[case descriptor_with_wrong_annotations]
class Descriptor():
    def __get__(self, instance: None, cls: None) -> int:
        raise NotImplementedError

class Foo:
    d1: Descriptor
    d2 = Descriptor()

x: int
x = Foo().d1  # E: Argument 1 to "__get__" of "Descriptor" has incompatible type "Foo"; expected "None" \
              # E: Argument 2 to "__get__" of "Descriptor" has incompatible type "type[Foo]"; expected "None"
x = Foo().d2  # E: Argument 1 to "__get__" of "Descriptor" has incompatible type "Foo"; expected "None" \
              # E: Argument 2 to "__get__" of "Descriptor" has incompatible type "type[Foo]"; expected "None"
x = Foo.d1  # E: Argument 2 to "__get__" of "Descriptor" has incompatible type "type[Foo]"; expected "None"
x = Foo.d2  # E: Argument 2 to "__get__" of "Descriptor" has incompatible type "type[Foo]"; expected "None"

[case instance_self___call__]
def call(x: int) -> int:
    return 1
class Foo:
    def __init__(self) -> None:
        self.__call__ = call

Foo()()  # E: "Foo" not callable

[case class_context_super_class]
from typing import TypeVar, Generic

T = TypeVar('T')

class I(Generic[T]): ...
class A(I[list[T]]): ...

x = A() # type: I[list[int]]

a_object = A() # type: A[object]
y = a_object # type: I[int] # E: Incompatible types in assignment (expression has type "A[object]", variable has t>

z = A() # type: I[int]

[case cannot_determine_mro]
# Similar to testCannotDetermineMro, but a few more tests
class A: pass
class B(A): pass
class D(A, B): pass # E: Cannot determine consistent method resolution order (MRO) for "D"

class A2(A): pass
class B2(B): pass
class D2(A2, B2): pass  # This is fine

[case mro_linearization_with_common_base_is_fine]
class Base: ...
class A(Base): ...
class B(A): ...
class C(Base): ...

class X(B, A, C): ...

[case classes_with__and__]
# int() supports __and__, but int should not.
int & int  # E: Unsupported left operand type for & ("type[int]")
int() & int()

[case typed_dict_with_normal_bases]
# Adapted from testCannotCreateTypedDictWithClassOtherBases to test an additional case
from typing import TypedDict

class A: pass

class X(TypedDict, A): # E: All bases of a new TypedDict must be TypedDict types
    x: int
class Y(A, TypedDict): # E: All bases of a new TypedDict must be TypedDict types
    x: int

[case liskov_inheritance_with_changed_type_vars]
from typing import TypeVar, Generic, List
T = TypeVar('T')

class A(Generic[T]):
    def x(self, t: T) -> None: ...
class B(A[List[T]]):
    def x(self, t: T) -> None: ...  # E: Argument 1 of "x" is incompatible with supertype "A"; supertype defines the argument type as "list[T]" \
                                    # N: This violates the Liskov substitution principle \
                                    # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides

class C(A[List[T]]):
    def x(self, t: List[T]) -> None: ...

[case operator_shortcut_type_error]

class A:
    def __add__(self, x: int) -> str:
        return ""

A() + A()  # E: Unsupported operand types for + ("A" and "A")

[case generic_class_as_callable]
from typing import TypeVar, Generic, Callable

T = TypeVar('T')

class Foo(Generic[T]):
    def __init__(self, x: T):
        self.x = x

def foo(c: Callable[[int], Foo[int]]) -> None: ...
def bar(c: Callable[[int], Foo[str]]) -> None: ...

foo(Foo)
bar(Foo)  # E: Argument 1 to "bar" has incompatible type "type[Foo]"; expected "Callable[[int], Foo[str]]"

[case generic_class_as_callable_with_func_type_vars]
from typing import TypeVar, Generic, Callable

T = TypeVar('T')
S = TypeVar('S')

class Foo(Generic[T]):
    def __init__(self, x: T, y: S, z: S):
        self.x = x

def foo(c: Callable[[int, float, float], Foo[int]]) -> None: ...
def bar(c: Callable[[int, float, str], Foo[int]]) -> None: ...
def baz(c: Callable[[str, str, float], Foo[int]]) -> None: ...

foo(Foo)
bar(Foo)
baz(Foo)  # E: Argument 1 to "baz" has incompatible type "type[Foo]"; expected "Callable[[str, str, float], Foo[int]]"

[case generic_class_as_callable_with_func_type_vars_and_bounds]
from typing import TypeVar, Generic, Callable

T = TypeVar('T')
S = TypeVar('S', bound=int)

class Foo(Generic[T]):
    def __init__(self, x: T, y: S, z: S):
        self.x = x

def foo(c: Callable[[str, int, int], Foo[str]]) -> None: ...
def bar1(c: Callable[[str, int, bytes], Foo[str]]) -> None: ...
def bar2(c: Callable[[str, bytes, int], Foo[str]]) -> None: ...
def bar3(c: Callable[[str, str, float], Foo[int]]) -> None: ...

foo(Foo)
bar1(Foo)  # E: Value of type variable "S" of "bar1" cannot be "bytes"
bar2(Foo)  # E: Value of type variable "S" of "bar2" cannot be "bytes"
bar3(Foo)  # E: Value of type variable "S" of "bar3" cannot be "str"

[case class_init_with_mismatching_self_type_vars]
from typing import Generic, TypeVar

T = TypeVar("T")
U = TypeVar("U")

class Foo(Generic[T, U]):
    def __init__(self: Foo[int, U], y: U): ...

class Bar(Foo[str, U]): ...

x: Bar[float]  # Fine
y = Bar(1.0)  # E: Invalid self type in __init__
reveal_type(y)  # N: Revealed type is "__main__.Bar[float]"

[case class_init_with_mismatching_self_type_vars_overload]
from typing import Generic, TypeVar, overload

T = TypeVar("T")
U = TypeVar("U")

class Foo(Generic[T, U]):
    @overload
    def __init__(self: Foo[int, U], y: U): ...
    @overload
    def __init__(self: Foo[float, U], y: U): ...
    def __init__(self, y): ...

class Bar(Foo[str, U]): ...

x: Bar[float]  # Fine
y = Bar(1.0)  # E: No overload variant of "Bar" matches argument type "float" \
              # N: Possible overload variants: \
              # N:     def [T, U] __init__(self: Foo[int, U], y: U) -> Bar[U] \
              # N:     def [T, U] __init__(self: Foo[float, U], y: U) -> Bar[U]

reveal_type(y)  # N: Revealed type is "Any"

[case class_union_attribute_assignment]
from typing import Union

class Foo:
    x: Union[str, int] = ''

f = Foo()
f.x = ''
f.x = 1

[case self_attr_context]
class Foo:
    def __init__(self, x: list[int]):
        self.x = x

f: Foo
f.x = []

[case avoid_losing_context_when_self_attr_doesnt_exist]
class Foo: ...
x = [1]
Foo().undefined = x = []  # E: "Foo" has no attribute "undefined"

[case avoid_context_of_getattr]
# flags: --disallow-untyped-globals
class Foo:
    def __getattr__(self, name: str) -> list[int]: ...

class Bar(Foo):
    x = []  # E: Need type annotation for "x" (hint: "x: List[<type>] = ...")

[case initialize_type]
type("A", (), {})
type("B", 1, 1)

[out]
__main__:2: error: No overload variant of "type" matches argument types "str", "int", "int"
__main__:2: note: Possible overload variants:
__main__:2: note:     def __init__(self, object, /) -> type
__main__:2: note:     def __init__(self, str, tuple[type[Any], ...], dict[str, Any], /, **kwds: Any) -> type

[case assign_in_subclass_to_callable_mypy_compatible]
# flags: --mode mypy
# Inspired a bit by testTypedDictUnpackSingleWithSubtypingNoCrash
from typing import Callable

def f(pseudo_self, x: int) -> None:
    pass
def g(pseudo_self, y: str) -> None:
    pass
def h(x: int) -> None:
    pass

class C:
    foo: Callable[[int], None]
    bar: Callable[[int], None]
    baz: Callable[[int], None]

# Currently we fail
class D(C):
    foo = f
    bar = g  # E: Argument 1 of "bar" is incompatible with supertype "C"; supertype defines the argument type as "int" \
             # N: This violates the Liskov substitution principle \
             # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
    baz = h  # E: Invalid self argument "D" to attribute function "h" with type "Callable[[int], None]" \
             # E: Signature of "baz" incompatible with supertype "C" \
             # N:      Superclass: \
             # N:          def (int, /) -> None \
             # N:      Subclass: \
             # N:          Callable[[], None]

[case assign_in_subclass_to_callable_no_mypy_compatible]
# flags: --mode default
# Inspired a bit by testTypedDictUnpackSingleWithSubtypingNoCrash
from typing import Callable

def f(pseudo_self, x: int) -> None:
    pass
def g(pseudo_self, y: str) -> None:
    pass
def h(x: int) -> None:
    pass

class C:
    foo: Callable[[int], None]
    bar: Callable[[int], None]
    baz: Callable[[int], None]

# Currently we fail
class D(C):
    foo = f
    bar = g
    baz = h  # E: Invalid self argument "D" to attribute function "h" with type "Callable[[int], None]"

[case total_ordering_missing_method]
from functools import total_ordering

@total_ordering
class Ord:  # E: No ordering operation defined when using "functools.total_ordering": < > <= >=
    def __eq__(self, other: object) -> bool:
        return False

reveal_type(Ord() < Ord())  # E: Unsupported left operand type for < ("Ord")  # N: Revealed type is "Any"
reveal_type(Ord() <= Ord())  # E: Unsupported left operand type for <= ("Ord")  # N: Revealed type is "Any"
reveal_type(Ord() == Ord())  # N: Revealed type is "bool"

[case self_annotation_eq_mismatch]
from typing import Generic, TypeVar

T = TypeVar("T")
class A(Generic[T]):
    def __init__(self, x: T):
        self.x = x
    def __eq__(self: A[int], other: object) -> bool: ...

aint = A(1)
astr = A("")
aint == None
astr == None  # E: Invalid self argument "A[str]" to attribute function "__eq__" with type "Callable[[A[int], object], bool]"

[case self_annotation_add_mismatch]
from typing import Generic, TypeVar, Self

T = TypeVar("T")
class A(Generic[T]):
    def __init__(self, x: T):
        self.x = x
    def __add__(self: A[int], other: object) -> Self: ...  # E: Self argument missing for a non-static method (or an invalid type for self)

aint = A(1)
astr = A("")
aint + aint
astr + astr  # E: Invalid self argument "A[str]" to attribute function "__add__" with type "Callable[[A[int], object], Self]"

aint += aint
astr += astr  # E: Invalid self argument "A[str]" to attribute function "__add__" with type "Callable[[A[int], object], Self]"

[case self_annotation_radd_mismatch]
from typing import Generic, TypeVar, Self

T = TypeVar("T")
class A(Generic[T]):
    def __init__(self, x: T):
        self.x = x
    def __radd__(self: A[int], other: object) -> int: ...

x = 1
y = 1
aint = A(1)
astr = A("")
x + aint
y + astr  # E: Invalid self argument "A[str]" to attribute function "__radd__" with type "Callable[[A[int], object], int]"

x += aint
y += astr  # E: Invalid self argument "A[str]" to attribute function "__radd__" with type "Callable[[A[int], object], int]"

[case self_annotation_contains_mismatch]
from typing import Generic, TypeVar, Self

T = TypeVar("T")
class A(Generic[T]):
    def __init__(self, x: T):
        self.x = x
    def __contains__(self: A[int], other: object) -> bool: ...

aint = A(1)
astr = A("")
1 in aint
"" in astr  # E: Invalid self argument "A[str]" to attribute function "__contains__" with type "Callable[[A[int], object], bool]"

[case self_annotation_call_mismatch]
from typing import Generic, TypeVar, Callable

T = TypeVar("T")
class A(Generic[T]):
    def __init__(self, x: T):
        self.x = x
    def __call__(self: A[int]) -> bool: ...

aint = A(1)
astr = A("")

def f(x: Callable[[], bool]) -> None: ...
f(aint)
f(astr)  # E: Argument 1 to "f" has incompatible type "A[str]"; expected "Callable[[], bool]"

[case self_annotation_setitem_mismatch]
from typing import Generic, TypeVar

T = TypeVar("T")
class A(Generic[T]):
    def __init__(self, x: T):
        self.x = x
    def __setitem__(self: A[int], index, other) -> None: ...

aint = A(1)
astr = A("")

aint[1] = 1
astr[1] = 1  # E: Invalid self argument "A[str]" to attribute function "__setitem__" with type "Callable[[A[int], Any, Any], None]"

[case unannotated_class_init_with_self_def_no_check_untyped_defs]
# flags: --no-check-untyped-defs
class C:
    def __init__(self):
        self.x = 1
        self.y = None
        if bool():
            self.y = 1
        self.z = None
        self.lst = []
        self.lst.append(1)
        self.with_annotation: int = ""  # N: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs
        self.with_type_comment = ""  # type: int  # N: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs
        self.wrong_aug_assign += ""

c = C()
reveal_type(c.x)  # N: Revealed type is "Any"
reveal_type(c.y)  # N: Revealed type is "Any"
reveal_type(c.z)  # N: Revealed type is "Any"
reveal_type(c.lst)  # N: Revealed type is "Any"
reveal_type(c.with_annotation)  # N: Revealed type is "int"
reveal_type(c.with_type_comment)  # N: Revealed type is "int"
reveal_type(c.wrong_aug_assign)  # N: Revealed type is "Any"


[case unannotated_class_init_with_self_def_check_untyped_defs]
# flags: --check-untyped-defs --no-local-partial-types
class C:
    def __init__(self):
        self.x = 1
        self.y = None
        if bool():
            self.y = 1
        self.z = None
        self.lst = []
        self.lst.append(1)
        self.with_annotation: int = ""  # E: Incompatible types in assignment (expression has type "str", variable has type "int")
        self.with_type_comment = ""  # type: int  # E: Incompatible types in assignment (expression has type "str", variable has type "int")
        self.wrong_aug_assign += ""  # E: "Self" has no attribute "wrong_aug_assign"

c = C()
reveal_type(c.x)  # N: Revealed type is "int"
reveal_type(c.y)  # N: Revealed type is "int | None"
reveal_type(c.z)  # N: Revealed type is "None"
reveal_type(c.lst)  # N: Revealed type is "list[int]"
reveal_type(c.with_annotation)  # N: Revealed type is "int"
reveal_type(c.with_type_comment)  # N: Revealed type is "int"
reveal_type(c.wrong_aug_assign)  # N: Revealed type is "Any"

[case aug_assign_had_issue]
class M:
    def __init__(self) -> None:
        self.next_id = 0
        self.next_id += 1
        reveal_type(self.next_id)  # N: Revealed type is "int"

[case multi_inheritance_with_generic_nested]
from typing import Generic, TypeVar
from abc import abstractmethod

T = TypeVar("T")

class S(Generic[T]):
    @abstractmethod
    def foo(self, x: T) -> T: ...
    @abstractmethod
    def bar(self, x: T) -> T: ...

class A(S[T]): ...

class B:
    def foo(self, x: str) -> str: ...
    def bar(self, x: int) -> int: ...

class M1(B, A[int]): ...  # E: Definition of "foo" in base class "B" is incompatible with definition in base class "A"
class M2(A[int], B): ...

[case multi_inheritance_self_type_mismatch]
from typing import Generic, TypeVar
from abc import abstractmethod

T = TypeVar("T")

class A(Generic[T]):
    def foo(self: A[int]) -> None: ...

class B(Generic[T]):
    def foo(self: B[int]) -> None: ...

class C(Generic[T]):
    def bar(self: C[int]) -> None: ...

class D(Generic[T]):
    def bar(self: D[str]) -> None: ...

class M1(B[int], A[int]): ...
class M2(A[int], B[int]): ...

class M3(C[int], D[int]): ...  # E: Definition of "bar" in base class "C" is incompatible with definition in base class "D"
class M4(D[int], C[int]): ...  # E: Definition of "bar" in base class "D" is incompatible with definition in base class "C"

class M5(B[str], A[int]): ...  # E: Definition of "foo" in base class "B" is incompatible with definition in base class "A"
class M6(A[int], B[str]): ...  # E: Definition of "foo" in base class "A" is incompatible with definition in base class "B"

class M7(D[str], C[int]): ...
class M8(C[int], D[str]): ...

[case closure_self_access]
class Foo:
    x: int
    def foo(self) -> None:
        def bar() -> None:
            reveal_type(self.x)  # N: Revealed type is "int"

        def bar2() -> None:
            def bar3() -> None:
                reveal_type(self.x)  # N: Revealed type is "int"

        def bar4(self) -> None:
            reveal_type(self.x)  # N: Revealed type is "Any"

[case weird_type_executions]
from typing import Any, TypeVar, NewType
import typing

T = TypeVar("T")
N = NewType("N", int)

def foo(
        a: type[Any],
        b: type[int],
        n: N,
        ):
    reveal_type(type(a))  # N: Revealed type is "type[Any]"
    reveal_type(type(b))  # N: Revealed type is "type[object]"
    reveal_type(type(()))  # N: Revealed type is "def (typing.Iterable[Never] =) -> tuple[()]"
    reveal_type(type(T))  # N: Revealed type is "type[typing.TypeVar]"

    reveal_type(type(n))  # N: Revealed type is "type[__main__.N]"
    reveal_type(type(N))  # N: Revealed type is "type[object]"
    reveal_type(type(N))  # N: Revealed type is "type[object]"
    reveal_type(type(typing))  # N: Revealed type is "type[types.ModuleType]"
    reveal_type(type(abs))  # N: Revealed type is "type[Any]"

[case weird_type_executions_in_class]
from typing import Generic, ParamSpec, TypeVarTuple
Ts = TypeVarTuple("Ts")
P = ParamSpec("P")
class Foo(Generic[*Ts, P]):
    def foo(self, *x: P.args, **y: P.kwargs) -> None:
        reveal_type(type(super()))  # N: Revealed type is "type[super]"
        reveal_type(type(Ts))  # N: Revealed type is "type[typing.TypeVarTuple]"
        reveal_type(type(P))  # N: Revealed type is "type[typing.ParamSpec]"
        reveal_type(type(x))  # N: Revealed type is "def (typing.Iterable[object] =) -> tuple[object, ...]"
        reveal_type(type(y))  # N: Revealed type is "type[dict[str, object]]"
        reveal_type(type(self))  # N: Revealed type is "type[Self]"

[case type_executions_of_special_types]
from enum import Enum
from dataclasses import dataclass
from typing import TypedDict, NamedTuple

class E(Enum):
    x = "x"
    y = "y"

@dataclass
class D:
    x: int

class N(NamedTuple):
    x: int

class T(TypedDict):
    x: int

def foo(e: E, d: D, n: N, t: T):
    reveal_type(type(E))  # N: Revealed type is "type[object]"
    reveal_type(type(e))  # N: Revealed type is "type[__main__.E]"
    reveal_type(type(E.x))  # N: Revealed type is "type[__main__.E]"

    reveal_type(type(D))  # N: Revealed type is "type[object]"
    reveal_type(type(d))  # N: Revealed type is "def (x: int) -> __main__.D"

    reveal_type(type(N))  # N: Revealed type is "type[object]"
    reveal_type(type(n))  # N: Revealed type is "type[tuple[int, fallback=__main__.N]]"

    reveal_type(type(T))  # N: Revealed type is "type[object]"
    reveal_type(type(t))  # N: Revealed type is "type[dict[str, object]]"

[case self_argument_against_generics]
from typing import Self, Generic, TypeVar

T = TypeVar("T")
class Parent(Generic[T]): ...

class A(Parent[int]):
    def foo(self, b: B) -> None:
        reveal_type(b.bar(self))  # N: Revealed type is "int"

class B:
    def bar(self, other: Parent[T]) -> T: ...

[case missing__init__decorator]
class F:
    @foo  # E: Name "foo" is not defined
    def __init__(self, x: int) -> None: ...

F(b'')

[case __init__decorator_with_invalid_type]
def foo(x) -> int: ...
class F:
    # TODO add an error that this is an invalid __init__
    @foo
    def __init__(self, x: int) -> None: ...

F(b'')

[case slots_no_slots_with_dict]

class A:
    __slots__ = ('a',)
    a: int
    x: int

class B(A):
    b: int

class C(B):
    __slots__ = ('c',)
    c: int

def foo(a: A, b: B, c: C) -> None:
    a.a = 1
    a.b = 1  # E: "A" has no attribute "b"
    a.c = 1  # E: "A" has no attribute "c"
    a.x = 1  # E: Trying to assign name "x" that is not in "__slots__" of type "__main__.A"
    a.undefined = 1  # E: "A" has no attribute "undefined"

    b.a = 1
    b.b = 1
    b.c = 1  # E: "B" has no attribute "c"
    b.x = 1
    b.undefined = 1  # E: "B" has no attribute "undefined"

    c.a = 1
    c.b = 1
    c.c = 1
    c.x = 1
    c.undefined = 1  # E: "C" has no attribute "undefined"

[case slots_conflicting_with_class_var_access_with_inheritance_with__dict__]
class A:
    __slots__ = ('a', '__dict__')
    a: int
    x: int

class B(A):
    b: int

class C(B):
    __slots__ = ('c',)
    c: int

A.a  # E: "a" in __slots__ conflicts with class variable access
A.b  # E: "type[A]" has no attribute "b"
A.c  # E: "type[A]" has no attribute "c"
A.x
A.undefined = 1  # E: "type[A]" has no attribute "undefined"

B.a  # E: "a" in __slots__ conflicts with class variable access
B.b
B.c  # E: "type[B]" has no attribute "c"
B.x
B.undefined = 1  # E: "type[B]" has no attribute "undefined"

C.a  # E: "a" in __slots__ conflicts with class variable access
C.b
C.c  # E: "c" in __slots__ conflicts with class variable access
C.x
C.undefined = 1  # E: "type[C]" has no attribute "undefined"

[case aug_assign_with_inheritance_context]
class Foo:
    x: list[int | str]
    y: list[int | str]

    def __init__(self) -> None:
        self.x += [1]

    def bar(self) -> None:
        self.x += [""]
        self.y += [""]

class Super:
    x: list[int | str]

    def __init__(self) -> None:
        self.y: list[int | str] = []
        self.z: list[int | str]

class Sub(Super):
    def __init__(self) -> None:
        self.x += [1]
        self.y += [""]
        self.z += [""]

[case type_mro_lookup]
from typing import Any

type.mro(type(object()))
type.mro(type(1))
type.mro(1)  # E: Argument 1 to "mro" of "type" has incompatible type "int"; expected "type"

def foo(a: type[Any]) -> None:
    type.mro(a)

[case mro_is_assignable_if_instance_attr]
class Foo:
    def __init__(self) -> None:
        self.mro: str = ""

Foo().mro = ""
Foo.mro = ""  # E: Cannot assign to a method \
              # E: Incompatible types in assignment (expression has type "str", variable has type "Callable[[], list[type[Any]]]")

[case var_defined_on_if_in_unannotated_self_function]
class F:
    def foo(self) -> None:
        self.f.read() + ""

    def bar(self):
        # This is obviously not code somebody would write, but we get a context
        # manager that way.
        with open("lala") as self.f:
            ...

[case weird_invalid__new__]
import typing
class C1:
    __new__ = typing  # E: Signature of "__new__" incompatible with supertype "object" \
                      # N:      Superclass: \
                      # N:          def [Self: object] __new__(cls) -> Self \
                      # N:      Subclass: \
                      # N:          ModuleType

C1()

import typing
class C2:
    def __new__() -> C1: ...  # E: Method must have at least one argument. Did you forget the "self" argument?
C2()

[case super_matching]
# flags: --disallow-redefinition
class Foo: ...
class Bar(Foo):
    def __init__(self) -> None:
        sup = super()
        if bool():
            sup = 1  # E: Incompatible types in assignment (expression has type "int", variable has type "super")
        if bool():
            sup = super()
        if bool():
            sup = super(Foo, self)  # E: Incompatible types in assignment (expression has type "super", variable has type "super")

[case type_against_unknown_metaclass_matching]
class WithType(type): ...
class Simple: ...
class UnknownBase(UNDEFINED): ...  # E: Name "UNDEFINED" is not defined
class UnknownMeta(metaclass=UNDEFINED): ...  # E: Name "UNDEFINED" is not defined

def f(with_type: WithType, simple: Simple, unknown_base: UnknownBase, unknown_meta_t: type[UnknownMeta]):
    with_type = unknown_meta_t
    simple = unknown_meta_t  # E: Incompatible types in assignment (expression has type "type[UnknownMeta]", variable has type "Simple")
    unknown_base = unknown_meta_t

[case unknown_metaclass_getitem]
class Simple: ...
class UnknownMeta(metaclass=UNDEFINED): ...  # E: Name "UNDEFINED" is not defined

UnknownMeta[int]
Simple[int]  # E: "Simple" expects no type arguments, but 1 given

[case metaclass_with_type_var]
from typing import Generic, TypeVar

T = TypeVar("T")
class Meta(Generic[T]): ...

class Foo(metaclass=Meta[T]): ...  # E: Invalid metaclass "Meta[T]"

[case dunder_class_getitem_with_star_args_kwargs]
from typing import Any
class Typed:
    def __class_getitem__(*args: Any, **kwargs: Any) -> None: ...
class Untyped:
    def __class_getitem__(*args, **kwargs): ...
# TODO these errors are probably wrong, because __class_getitem__, but for now just don't crash
Typed[int, str]  # E: "Typed" expects no type arguments, but 2 given
Untyped[int, str]  # E: "Untyped" expects no type arguments, but 2 given

[case invalid_overload_inits_used_as_callable]
from typing import Callable, overload, Any

class A:
    @overload
    def __init__(self, y: int) -> None: ...
    @overload
    def __init__() -> None: ...  # E: Method must have at least one argument. Did you forget the "self" argument?
    def __init__(*args: Any, **kwargs: Any) -> None: ...

class B:
    @overload
    def __init__(*, y: int) -> None: ...  # E: Method must have at least one argument. Did you forget the "self" argument?
    @overload
    def __init__() -> None: ...  # E: Method must have at least one argument. Did you forget the "self" argument?
    def __init__(*args: Any, **kwargs: Any) -> None: ...

def foo(x: Callable[[int], Any]) -> None: ...

foo(A)
foo(B)  # E: Argument 1 to "foo" has incompatible type "type[B]"; expected "Callable[[int], Any]"

[case nested_class_self_assignment]
class Foo:
    def __init__(self) -> None:
        self.x = 1
        class Bar:
            def __init__(bar) -> None:
                bar.z = ""
            def foo(bar) -> None:
                reveal_type(self.x)  # N: Revealed type is "int"
                reveal_type(self.y)  # N: Revealed type is "float"
                self.z  # E: "Foo" has no attribute "z"
                bar.x  # E: "Self" has no attribute "x"
                bar.y  # E: "Self" has no attribute "y"
                reveal_type(bar.z)  # N: Revealed type is "str"
                self.x += 1

        self.y = 1.0

        self.bar = Bar()

def check(f: Foo) -> None:
    reveal_type(f.x)  # N: Revealed type is "int"
    reveal_type(f.y)  # N: Revealed type is "float"
    reveal_type(f.z)  # E: "Foo" has no attribute "z" # N: Revealed type is "Any"
    f.bar.x  # E: "Bar" has no attribute "x"
    f.bar.y  # E: "Bar" has no attribute "y"
    f.bar.z

[case nested_function_in_class_self_assignment]
class Foo:
    def __init__(self) -> None:
        self.x = 1
        def init(bar) -> None:
            bar.z = ""
        def foo(bar) -> None:
            reveal_type(self.x)  # N: Revealed type is "int"
            reveal_type(self.y)  # N: Revealed type is "float"
            self.z  # E: "Self" has no attribute "z"
            bar.x
            bar.y
            reveal_type(bar.z)  # N: Revealed type is "Any"
            self.x += 1

        self.y = 1.0

def check(f: Foo) -> None:
    reveal_type(f.x)  # N: Revealed type is "int"
    reveal_type(f.y)  # N: Revealed type is "float"
    reveal_type(f.z)  # E: "Foo" has no attribute "z" # N: Revealed type is "Any"

[case class_lookup_of_methods_with_generics]
from typing import Callable, TypeVar, Generic, ClassVar

def simple_dec(x: T) -> T: ...
T = TypeVar("T")
class G(Generic[T]):
    def foo(self, x: T) -> T: ...

    @simple_dec
    def bar(self, x: T) -> T: ...

class H(G[list[T]]): ...

reveal_type(G.foo)  # N: Revealed type is "def [T] (self: __main__.G[T], x: T) -> T"
reveal_type(G.bar)  # N: Revealed type is "def [T] (self: __main__.G[T], x: T) -> T"

reveal_type(H.foo)  # N: Revealed type is "def [T] (self: __main__.G[list[T]], x: list[T]) -> list[T]"
reveal_type(H.bar)  # N: Revealed type is "def [T] (self: __main__.G[list[T]], x: list[T]) -> list[T]"

def check_g(g1: G[int], g2: G[list[int]], h: H[int], x: int, y: str, l: list[int], k: list[str]) -> None:
    G.foo(g1, x)
    G.foo(g1, y)  # E: Argument 2 to "foo" of "G" has incompatible type "str"; expected "int"
    G.bar(g1, x)
    G.bar(g1, y)  # E: Argument 2 to "bar" of "G" has incompatible type "str"; expected "int"

    H.foo(g2, l)
    H.foo(g2, k)  # E: Argument 2 to "foo" of "G" has incompatible type "list[str]"; expected "list[int]"
    H.bar(g2, l)
    H.bar(g2, k)  # E: Argument 2 to "bar" of "G" has incompatible type "list[str]"; expected "list[int]"

    H.foo(h, l)
    H.foo(h, k)  # E: Argument 2 to "foo" of "G" has incompatible type "list[str]"; expected "list[int]"
    H.bar(h, l)
    H.bar(h, k)  # E: Argument 2 to "bar" of "G" has incompatible type "list[str]"; expected "list[int]"

[case reassigning_with_self_types]
from typing import Callable, Self

def dec(f) -> Callable[[A, int], A]: pass

class A:
    x = int()
    if x:
        @dec
        def f(self): pass
    else:
        def f(self, x: int) -> Self: pass

[case classmethod_self_type_with_additional_type_vars]
from typing import TypeVar
T = TypeVar("T")
U = TypeVar("U")
class F:
    @classmethod
    def foo(cls: type[T], other: U) -> tuple[T, U]: ...

f1 = F.foo
f2 = F().foo
reveal_type(f1)  # N: Revealed type is "def [U] (other: U) -> tuple[__main__.F, U]"
reveal_type(f2)  # N: Revealed type is "def [U] (other: U) -> tuple[__main__.F, U]"

reveal_type(f1(1))  # N: Revealed type is "tuple[__main__.F, int]"
reveal_type(f2(1))  # N: Revealed type is "tuple[__main__.F, int]"

[case overloaded_setattr]
from typing import overload
class Foo:
    @overload
    def __setattr__(self, name: str, other: int) -> None: ...
    @overload
    def __setattr__(self, name: str, other: str) -> None: ...
    def __setattr__(self, name: str, other) -> None: ...

Foo().x = 3
Foo().x = ""
Foo().x = b""  # E: Incompatible types in assignment (expression has type "bytes", variable has type "int | str")

[case iter_without_next]
from typing import Self
class Foo:
    def __iter__(self) -> Self: ...

for x in Foo(): ...  # E: "Foo" has no attribute "__next__"

[case yield_from_iter_without_next]
from typing import Self
class Foo:
    def __iter__(self) -> Self: ...

def f(x: int):
    yield from Foo()  # E: "Foo" has no attribute "__next__"

[case contains_iter_without_next]
from typing import Self
class Foo:
    def __iter__(self) -> Self: ...

def f(x: int):
    1 in Foo()  # E: "Foo" has no attribute "__next__"

[case overlapping_of_ops_with_incompatible_self_types]
from typing import TypeVar, Generic, Any
T = TypeVar('T')

class A(Generic[T]):
    def __add__(self: A[int], other: Any) -> int: ...

class B(A[T]):
    def __radd__(self: A[str], other: A[str]) -> str: ...  # E: Signatures of "__radd__" of "B[T]" and "__add__" of "A[str]" are unsafely overlapping

[case avoid_complex_decorator_crash_on_method]
from typing import no_type_check
class C:
    @no_type_check
    @undefined   # E: Name "undefined" is not defined
    def foo(self) -> None: ...

[case __init_subclass__with_never_or_any_return]
from typing import Any, Never
class C:
    def __init_subclass__(self) -> Never: ...
class D:
    def __init_subclass__(self) -> Any: ...  # E: The return type of "__init_subclass__" must be None

[case class_decorator_after_staticmethod_without_args]
from typing import Any
class Decorator:
    def __init__(self, other: Any): ...
    def __call__(self, other: int) -> int: ...
class C:
    @staticmethod
    @Decorator
    def s() -> None: ...

reveal_type(C().s(1))  # N: Revealed type is "int"

[case overlapping_op_methods_checking_with_valid_self_type]
from typing import Self

class C:
    def __or__(self, value: Self, /) -> Self: ...
    def __ror__(self, value: Self, /) -> Self: ...

[case overwrite_any_with_property_setter_should_be_fine]
from typing import Any
class X:
    x = ...  # type: Any
    @property  # E: Name "x" already defined on line 3
    def x(self): ...
    @x.setter
    def x(self, value): ...

reveal_type(X().x)  # N: Revealed type is "Any"

[case override_property_setter_with_generics]
# Like testOverridePropertyGeneric, but passes in one case
from typing import TypeVar, Generic

T = TypeVar("T")

class B(Generic[T]):
    @property
    def foo(self) -> int: ...
    @foo.setter
    def foo(self, x: T) -> None: ...

    @property
    def bar(self) -> int: ...
    @bar.setter
    def bar(self, x: T) -> None: ...

class C(B[str]):
    @property
    def foo(self) -> int: ...
    @foo.setter  # E: Incompatible override of a setter type \
                 # N:  (base class "B" defined the type as "str", \
                 # N:  override has type "int")
    def foo(self, x: int) -> None: ...

    @property
    def bar(self) -> int: ...
    @bar.setter
    def bar(self, x: str) -> None: ...

[case intersection_execution_should_not_fail]
class Foo:
    def __init__(self, x: bytes): ...
class Bar:
    def __call__(self, f: int) -> str: ...

def f(x: Foo, y: Bar):
    if isinstance(x, Bar):
        # TODO this is wrong
        a: str = x()  # E: "Foo" not callable
    if isinstance(y, Foo):
        b: str = y()  # E: Missing positional argument "f" in call to "__call__" of "Bar"

def g(x: type[Foo], y: type[Bar]):
    # TODO these are questionable and wrong
    if issubclass(x, Bar):
        reveal_type(x(b''))  # N: Revealed type is "__main__.Foo"
    if issubclass(y, Foo):
        reveal_type(y())  # N: Revealed type is "__main__.Bar"

[case join_undefined_generics_in_class_types_should_not_panic]
# flags: --use-joins
from collections import defaultdict
m = set([dict, defaultdict])
reveal_type(m)  # N: Revealed type is "set[type[dict[Any, Any]]]"

[case class_name_resolving_if_member_has_same_name]
import m

class A:
    a: int
    m: m.C

def foo(b: A):
    reveal_type(b.m)  # N: Revealed type is "m.C"
    reveal_type(b.a)  # N: Revealed type is "int"

[file m.py]
class C: ...

[case class_name_resolving_if_member_has_same_name_but_is_defined_later]
class A:
    a: int
    m: m.C

import m

def foo(b: A):
    reveal_type(b.m)  # N: Revealed type is "m.C"
    reveal_type(b.a)  # N: Revealed type is "int"

[file m.py]
class C: ...

[case class_name_in_func_resolving_if_member_has_same_name]
import m

def f() -> None:
    import n as m
    class A:
        a: int
        m: m.C

    def foo(b: A):
        reveal_type(b.m)  # N: Revealed type is "bytes"
        reveal_type(b.a)  # N: Revealed type is "int"

[file m.py]
class C: ...

[file n.py]
C = bytes

[case class_name_in_nested_class_resolving_if_member_has_same_name]
import m

class Nested:
    import n as m
    class A:
        a: int
        m: m.C


def foo(b: Nested.A):
    reveal_type(b.m)  # N: Revealed type is "m.C"
    reveal_type(b.a)  # N: Revealed type is "int"

[file m.py]
class C: ...

[file n.py]
C = bytes

[case explicit_any_for_class_arg_with_super_should_not_crash]
from typing import Any
class B:
    def foo(self) -> int: ...
class C(B):
    def __new__(cls: Any):
        super().__new__()
    def foo(self: Any) -> int:
        return super().foo()

[case bound_cycles1]
from typing import TypeVar

CT = TypeVar("CT", bound="C[str]")  # E: Type argument "str" of "C" must be a subtype of "D[int]"
DT = TypeVar("DT", bound="D[int]")  # E: Type argument "int" of "D" must be a subtype of "C[str]"

class C(list[DT]): ...
class D(list[CT]): ...

[case bound_cycles2]
from m import C
C()

[file m.py]
from typing import TypeVar, Generic

MemberT = TypeVar("MemberT", bound="Member")
class Member(list["UserMessage"]): ...
class ChatGroup(Generic[MemberT]): ...

T = TypeVar("T")
ChannelT = TypeVar("ChannelT")

class Message(Generic[ChannelT, T]): ...
class UserMessage(Message[T, "UserChannel"]): ...

GroupT = TypeVar("GroupT")
CT = TypeVar("CT", bound="C")

class Channel(Generic[CT]): ...
class UserChannel(Channel[UserMessage]): ...  # E: Type argument "UserMessage[Any]" of "Channel" must be a subtype of "C"

class C(ChatGroup): ...

[case avoid_uncalculated_class_crash_in_recursive_definitions_with_flow_analysis]
# flags: --mode mypy
from m import Base
class M(Base): ...

[file m.py]
from typing import dataclass_transform
from mf import Field

@dataclass_transform(field_specifiers=(Field,))
class ModelMetaclass(type): ...

class Base(metaclass=ModelMetaclass): ...

[file mf.py]
from typing import Optional, Any
from mt import Alias

def Field(default_factory: Alias) -> Any: ...

class ModelField:
    def __init__(self) -> None:
        self.sub_fields: int = 1
        from m import Base
        Base()

[file mt.py]
if bool(): ...  # Enable flow analysis
Alias = int | str

from mf import ModelField

def update_field_forward_refs(field: ModelField):
    field.sub_fields

[case metaclass_loop]
import m
reveal_type(m.C.c)  # N: Revealed type is "int"
reveal_type(m.C.d)  # N: Revealed type is "str"

[file m.py]
import n
class C(type, metaclass=n.D):
    c: int

[file n.py]
import m
class D(type, metaclass=m.C):  # E: Cannot resolve name "C" (possible cyclic definition)
    d: str

[case class_decorator_depends_on_class]
def dec(x) -> C: ...

@dec
class C: ...

[case simple_class_annotation_through_complex_narrowing]
import m
def foo() -> m.X: ...

reveal_type(foo())  # N: Revealed type is "int"

[file m.py]
if bool():
    X = int

[case invalid_nested_class_forward_reference]
class C(list['D.X']): ...  # E: Name "D.X" is not defined

class D: ...

[case class_forward_reference_annotated_attribute_with_same_name1]
import x
import x as z
class C:
    x: "x.D"
    z: "z.D"

    def foo(self) -> None:
        x: "x.D"
        z: "z.D"

def foo(self) -> None:
    x: "x.D"
    z: "z.D"

reveal_type(C.x)  # N: Revealed type is "x.D"
z: z.D # E: Name "z" already defined (by an import)

[file x.py]
class D: ...

[case class_forward_reference_annotated_attribute_with_same_name2]
class C:
    x: "x.D"  # E: Name "x" is not defined

    def foo(self) -> None:
        x: "x.D"  # E: Name "x" is not defined

def foo(self) -> None:
    x: "x.D"  # E: Name "x" is not defined

reveal_type(C.x)  # N: Revealed type is "Any"

[case class_forward_reference_annotated_attribute_with_same_name3]
class C:
    x: "x.D"

    def foo(self) -> None:
        x: "x.D"

def foo(self) -> None:
    x: "x.D"

reveal_type(C.x)  # N: Revealed type is "Any"
x: x.D  # E: Name "x" is not defined

[case class_forward_reference_annotated_attribute_with_same_name4]
x: x.D  # E: Name "x" is not defined
class C:
    x: "x.D"

    def foo(self) -> None:
        x: "x.D"

def foo(self) -> None:
    x: "x.D"

reveal_type(C.x)  # N: Revealed type is "Any"

[case class_forward_reference_annotated_attribute_with_same_name5]
class C:
    x: "x.D"

    def foo(self) -> None:
        x: "x.D"

def foo(self) -> None:
    x: "x.D"

reveal_type(C.x)  # N: Revealed type is "Any"
x: "x.D"  # E: Name "x" is not defined

[case class_forward_reference_annotated_attribute_with_same_name6]
x: "x.D"  # E: Name "x" is not defined
class C:
    x: "x.D"

    def foo(self) -> None:
        x: "x.D"

def foo(self) -> None:
    x: "x.D"

reveal_type(C.x)  # N: Revealed type is "Any"

[case class_any_base]
from typing import Any
def foo() -> Any: ...
X: Any = foo()
Y: Any

class C1(X): ...
class C2(Y): ...
class C3(A): ...  # E: Name "A" is used before definition
class C4(B): ...  # E: Name "B" is used before definition

A: Any = foo()
B: Any

[case final_as_class_attr_should_not_crash_when_tuple_is_used]
from typing import Literal
from n import C

def f(name: Literal[C.X]) -> int: ...  # E: Parameter 1 of Literal[...] is invalid

[file n.py]
from typing import Final
class C:
    X: Final = '', 1

[case class_with_self_type_attr_acess]
from typing import Generic, TypeVar, Self
T = TypeVar("T", bound="Foo")

class Foo:
    def __init__(self: T, y: int):
        self.x: str = ''
        self.y = y
        self.z = ''

class Bar:
    def __init__(self: Self, y: int):
        self.x: str = ''
        self.y = y
        self.z = ''

class Baz:
    def __init__(self: Baz, y: int):
        self.x: str = ''
        self.y = y
        self.z = ''

reveal_type(Foo(1).y)  # N: Revealed type is "int"
reveal_type(Bar(1).y)  # N: Revealed type is "int"
reveal_type(Baz(1).y)  # N: Revealed type is "int"

[case nested_class_func_definition_scoping]
class X:
    x = 1
    z = int
    class Y:
        x  # E: Name "x" is not defined
        y: z  # E: Name "z" is not defined
    def f(self) -> None:
        x  # E: Name "x" is not defined
        y: z  # E: Name "z" is not defined

[case class_type_var_in_literal_base_class_should_error]
from typing import Generic, TypeVar, Self, Literal
T = TypeVar("T")

class Foo(list[Literal[T]]): ...  # E: Parameter 1 of Literal[...] is invalid

def f(x: Foo):
    reveal_type(x)  # N: Revealed type is "__main__.Foo"

[case common_base_type_variance_not_ready]
# Like testPEP695InferVarianceNotReadyForJoin, but adapted a bit
from m import Invariant

# TODO: this should actually not be invariant, because the file is finished and
# the variance that was initially wrong, could just be recalculated.
reveal_type([Invariant(1), Invariant(object())])   # N: Revealed type is "list[m.Invariant[object]]"

[file m.py]
class Invariant[T]:
    def __init__(self, x: T) -> None:
        # At this point the variance is definitely not ready
        reveal_type([Invariant(1), Invariant(object())])  # N: Revealed type is "list[m.Invariant[object]]"
        self.x = x or None

[case type_variance_should_not_recurse_with_decorator]
def callback[CT](func: CT) -> CT: ...

class C[T]:
    @callback
    def f(self, x: T) -> T: ...


[case type_variance_recursive_definitions_should_not_crash]
from typing import TypeVar, Generic, Any

class C[DT](tuple[DT, "E"]):
    x: DT

class D[CT: "C"]:
    y: CT

class E(D[C[Any]]):
    def f(self, x: C[object], y: C[int]) -> None:
        if bool():
            x = y  # E: Incompatible types in assignment (expression has type "C[int]", variable has type "C[object]")
        y = x  # E: Incompatible types in assignment (expression has type "C[object]", variable has type "C[int]")

[case override_error_code]
# flags: --show-error-codes

class C:
    x = 1

class D:
    @property
    def x(self) -> int: ...

class E(C):
    @property
    def x(self) -> int: ...  # E: Cannot override writeable attribute with read-only property  [override]

class F(D, C): ...  # E: Cannot override writeable attribute "x" in base "C" with read-only property in base "D"  [override]

[case override_cached_property_mypy_compatible]
# flags: --mode mypy --show-error-codes
from functools import cached_property

class X:
    @cached_property
    def x(self) -> int: return 1

    @property
    def y(self) -> int: return 1
    @y.setter
    def y(self, other) -> None: ...

class Y:
    @property
    def x(self) -> int: return 1
    @property
    def y(self) -> int: return 1

class Z(X):
    @property
    def x(self) -> int: return 1

    @property  # E: Read-only property cannot override read-write property  [misc]
    def y(self) -> int: return 1

class Multi1(X, Y): ...
class Multi2(Y, X): ...  # E: Cannot override writeable attribute "y" in base "X" with read-only property in base "Y"  [override]

[case override_cached_property_no_mypy_compatible]
# flags: --mode default --show-error-codes
from functools import cached_property

class X:
    @cached_property
    def x(self) -> int: return 1

    @property
    def y(self) -> int: return 1
    @y.setter
    def y(self, other) -> None: ...

class Y:
    @property
    def x(self) -> int: return 1
    @property
    def y(self) -> int: return 1

class Z(X):
    @property  # E: Read-only property cannot override read-write property  [misc]
    def x(self) -> int: return 1

    @property  # E: Read-only property cannot override read-write property  [misc]
    def y(self) -> int: return 1

class Multi1(X, Y): ...
class Multi2(Y, X): ...  # E: Cannot override writeable attribute "x" in base "X" with read-only property in base "Y"  [override] \
                         # E: Cannot override writeable attribute "y" in base "X" with read-only property in base "Y"  [override]

[case override_cached_property_with_final_mypy_compatible]
# flags: --mode mypy --show-error-codes
from typing import final
from functools import cached_property

class X:
    @cached_property
    def x(self) -> int: return 1

    @property
    def y(self) -> int: return 1
    @y.setter
    def y(self, other) -> None: ...

class Y:
    @final
    @cached_property
    def x(self) -> int: return 1
    @cached_property
    @final
    def y(self) -> int: return 1

class Z(X):
    @cached_property
    @final
    def x(self) -> int: return 1

    @final
    @cached_property
    def y(self) -> int: return 1  # E: Cannot override writable attribute "y" with a final one  [misc]

class Multi1(X, Y): ...  # E: Cannot override final attribute "x" (previously declared in base class "Y")  [misc] \
                         # E: Cannot override final attribute "y" (previously declared in base class "Y")  [misc]
class Multi2(Y, X): ...  # E: Cannot override writable attribute "y" with a final one  [misc]

[case override_cached_property_with_final_no_mypy_compatible]
# flags: --mode default --show-error-codes
from typing import final
from functools import cached_property

class X:
    @cached_property
    def x(self) -> int: return 1

    @property
    def y(self) -> int: return 1
    @y.setter
    def y(self, other) -> None: ...

class Y:
    @final
    @cached_property
    def x(self) -> int: return 1
    @cached_property
    @final
    def y(self) -> int: return 1

class Z(X):
    @final
    @cached_property
    def x(self) -> int: return 1  # E: Cannot override writable attribute "x" with a final one  [misc]

    @final
    @cached_property
    def y(self) -> int: return 1  # E: Cannot override writable attribute "y" with a final one  [misc]

class Multi1(X, Y): ...  # E: Cannot override final attribute "x" (previously declared in base class "Y")  [misc] \
                         # E: Cannot override final attribute "y" (previously declared in base class "Y")  [misc]
class Multi2(Y, X): ...  # E: Cannot override writable attribute "x" with a final one  [misc] \
                         # E: Cannot override writable attribute "y" with a final one  [misc]

[case class_ambigous_write]
from typing import TypeVar, Generic
T = TypeVar("T")
# from conformance tests (generics_type_erasure.py)
class Node(Generic[T]):
    label: T
    def __init__(self, label: T | None = None) -> None:
        if label is not None:
            self.label = label

Node[int].label = 1  # E: Access to generic instance variables via class is ambiguous
Node[int].label      # E: Access to generic instance variables via class is ambiguous
Node.label = 1       # E: Access to generic instance variables via class is ambiguous
Node.label           # E: Access to generic instance variables via class is ambiguous

n1: Node[int] = Node()
type(n1).label       # E: Access to generic instance variables via class is ambiguous

[case __init_subclass__in_abcmeta]
from abc import ABC, ABCMeta
class B(metaclass=type, x=1): ...  # E: Unexpected keyword argument "x" for "__init_subclass__" of "object"
class C(ABC, x=1): ...  # E: Unexpected keyword argument "x" for "__init_subclass__" of "object"
class D(metaclass=ABCMeta, x=1): ...  # E: Unexpected keyword argument "x" for "__init_subclass__" of "object"

[case classvar_without_type]
from typing import ClassVar
class C:
    x: ClassVar  # E: Type in ClassVar[...] can only be omitted if there is an initializer

[case class_new_with_no_return_allowed]
from typing import NoReturn, assert_type
class C:
    def __new__(cls) -> NoReturn:
        raise NotImplementedError

    def __init__(self, x: int):
        pass

[case class_with_new_and_return_specialization]
# From conformance tests (constructors_call_new.py)
from typing import Generic, assert_type, TypeVar
T = TypeVar("T")
class Class8(Generic[T]):
    def __new__(cls, *args, **kwargs) -> "Class8[list[T]]": ...


assert_type(Class8[int](), Class8[list[int]])
assert_type(Class8[str](), Class8[list[str]])

[case type_call_should_work_on_all_types]
# From conformance tests (constructors_call_type.py)
from typing import TypeVar
T = TypeVar("T")
class Meta1(type):
    # Ignore possible errors related to incompatible override
    def __call__(cls: type[T], x: int, y: str) -> T:  # type: ignore
        return type.__call__(cls)

[case __class__call_with_type_vars]
from typing import Self

class D[T]:
    def __init__[S](self, t: T, y: S):
        self.t = t

    def foo(self) -> Self:
        if bool():
            return self.__class__(1, '')  # E: Argument 1 to "D" has incompatible type "int"; expected "T"
        else:
            return self.__class__(self.t, '')

[case metaclass_dunder_call_mypy_compatible]
# flags: --mode mypy
from typing import assert_type, Self
class Meta2(type):
    def __call__(cls, *args, **kwargs) -> "int | Meta2":
        return 1

class Class2(metaclass=Meta2):
    def __new__(cls, x: int) -> Self:
        return super().__new__(cls)

assert_type(Class2(1), Class2)

[case metaclass_dunder_call_no_mypy_compatible]
# flags: --mode default
# From conformance tests (constructors_call_metaclass.py)
from typing import NoReturn, Self, TypeVar, assert_type

class Meta1(type):
    def __call__(cls, *args, **kwargs) -> NoReturn:
        raise TypeError("Cannot instantiate class")

class Class1(metaclass=Meta1):
    def __new__(cls, x: int) -> Self:
        return super().__new__(cls)

if bool():
    assert_type(Class1(), NoReturn)

class Meta2(type):
    def __call__(cls, *args, **kwargs) -> "int | Meta2":
        return 1

class Class2(metaclass=Meta2):
    def __new__(cls, x: int) -> Self:
        return super().__new__(cls)

assert_type(Class2(), int | Meta2)

[case metaclass_dunder_call_with_generics]
# flags: --mode default
# From conformance tests (constructors_call_metaclass.py)

from typing import TypeVar, Self, assert_type

T = TypeVar("T")

class Meta3(type):
    def __call__(cls: type[T], *args, **kwargs) -> T:
        return super().__call__(cls, *args, **kwargs)

class Class3(metaclass=Meta3):
    def __new__(cls, x: int) -> Self:
        return super().__new__(cls)

Class3()  # E: Missing positional argument "x" in call to "Class3"
assert_type(Class3(1), Class3)

class Meta4(type):
    def __call__(cls, *args, **kwargs):
        return super().__call__(cls, *args, **kwargs)

class Class4(metaclass=Meta4):
    def __new__(cls, x: int) -> Self:
        return super().__new__(cls)

Class4()  # E: Missing positional argument "x" in call to "Class4"
assert_type(Class4(1), Class4)

[case deprecated_should_still_be_matchable_as_protocol]
# flags: --enable-error-code=deprecated
from typing import Protocol
from warnings import deprecated
class SupportsFoo2(Protocol):
    def foo(self) -> None: ...

class FooConcrete2:
    @deprecated("Deprecated")
    def foo(self) -> None: ...

def takes_foo(f: SupportsFoo2) -> None: ...

def caller(c: FooConcrete2) -> None:
    takes_foo(
        c
    )

[case should_be_able_to_assign_class_variable]
from typing import ClassVar

class Test:
    _results: ClassVar[list[int]]

    @classmethod
    def setUpClass(cls) -> None:
        cls._results = [1, 2, 3]  # error: Cannot assign to class variable "_results" via instance  [misc]
        cls.foo = 1  # E: "type[Self]" has no attribute "foo"
        cls.with_annotation: int = ""  # E: "type[Self]" has no attribute "with_annotation" \
                                       # E: Incompatible types in assignment (expression has type "str", variable has type "int") \
                                       # E: Type cannot be declared in assignment to non-self attribute

Test.foo = 1  # E: "type[Test]" has no attribute "foo"
y = Test().foo  # E: "Test" has no attribute "foo"
reveal_type(y)  # N: Revealed type is "Any"
Test().with_annotation  # E: "Test" has no attribute "with_annotation"

[case staticmethod_assignment_to_first_var]
class Test:
    x = 1
    @staticmethod
    def f(non_cls) -> None:
        non_cls.x = ""
        reveal_type(non_cls)  # N: Revealed type is "Any"
        non_cls.with_annotation1: int = ""  # E: Type cannot be declared in assignment to non-self attribute \
                                            # E: Incompatible types in assignment (expression has type "str", variable has type "int")

    @staticmethod
    def g(non_cls: bytes) -> None:
        non_cls.x = ""  # E: "bytes" has no attribute "x"
        non_cls.y = ""  # E: "bytes" has no attribute "y"
        reveal_type(non_cls)  # N: Revealed type is "bytes"
        non_cls.with_annotation2: int = ""  # E: Type cannot be declared in assignment to non-self attribute \
                                            # E: "bytes" has no attribute "with_annotation2" \
                                            # E: Incompatible types in assignment (expression has type "str", variable has type "int")

y = Test().y  # E: "Test" has no attribute "y"
reveal_type(y)  # N: Revealed type is "Any"
Test().y = ''  # E: "Test" has no attribute "y"
Test().with_annotation1  # E: "Test" has no attribute "with_annotation1"
Test().with_annotation2  # E: "Test" has no attribute "with_annotation2"

[case context_for_class_vars_should_not_be_instance_method]
import m

def wrap[T](obj: T) -> T: ...

class A(m.Base):
    y = wrap(m.Base.f)
    f = wrap(m.Base.f)

A().y()
A().f()

[file m.pyi]
class Base:
    def f(self) -> None: ...

[case container_with_never_explicit_unions_in_untyped_functions]
# flags: --mode default
from typing import Never
class X[T]:
    t: T

def f(x: X[Never], y: X[int]):
    if bool():
        return x
    else:
        return y

def g(x: X[int], y: X[Never]):
    if bool():
        return x
    else:
        return y

def test(x: X[Never], y: X[int]):
    reveal_type(f(x, y))  # N: Revealed type is "__main__.X[Never] | __main__.X[int]"
    reveal_type(g(y, x))  # N: Revealed type is "__main__.X[int] | __main__.X[Never]"

[case multiple_inheritance_overload_mismatch_no_crash]
# From GH #200
from tkinter_like import Canvas, Frame
class C(Canvas, Frame): ...

[file tkinter_like.pyi]
from collections import *
from typing import overload, Any

class Canvas:
    @overload
    def configure(self) -> str: ...
    @overload
    def configure(self, cnf: str) -> int: ...

class Frame:
    @overload
    def configure(self) -> str: ...
    @overload
    def configure(self, cnf: str) -> int: ...
    config = configure

[case metaclass_callable_initialization]
# flags: --mode default
# from conformance tests (constructors_call_type.py)
from typing import Self, TypeVar

T = TypeVar("T")

class Meta1(type):
    # Ignore possible errors related to incompatible override
    def __call__(cls: type[T], x: int, y: str) -> T:  # type: ignore
        return type.__call__(cls)

class Class1(metaclass=Meta1):
    def __new__(cls, *args, **kwargs) -> Self:
        return super().__new__(*args, **kwargs)

def func1(cls: type[Class1]):
    cls(x=1, y="")  # OK
    cls()  # E: Missing positional arguments "x", "y" in call to "Class1"

[case class_dunder_new_conformance_tests1]
# flags: --mode default
# from conformance tests (constructors_call_new.py)
from typing import Generic, Self, TypeVar, assert_type

T = TypeVar("T")


class Class1(Generic[T]):
    def __new__(cls, x: T) -> Self:
        return super().__new__(cls)


assert_type(Class1[int](1), Class1[int])
assert_type(Class1[float](1), Class1[float])
Class1[int](1.0)  # E: Argument 1 to "Class1" has incompatible type "float"; expected "int"

assert_type(Class1(1), Class1[int])
assert_type(Class1(1.0), Class1[float])


class Class2(Generic[T]):
    def __new__(cls, *args, **kwargs) -> Self:
        return super().__new__(cls)

    def __init__(self, x: T) -> None:
        pass


assert_type(Class2(1), Class2[int])
assert_type(Class2(""), Class2[str])

[case class_dunder_new_conformance_tests2]
# flags: --mode default
# from conformance tests (constructors_call_new.py)
from typing import assert_type, Any, NoReturn

class Class3:
    def __new__(cls) -> int:
        return 0

    # In this case, the __init__ method should not be considered
    # by the type checker when evaluating a constructor call.
    def __init__(self, x: int):
        pass

assert_type(Class3(), int)

# > For purposes of this test, an explicit return type of Any (or a union
# > containing Any) should be treated as a type that is not an instance of
# > the class being constructed.

class Class4:
    def __new__(cls) -> "Class4 | Any":
        return 0

    def __init__(self, x: int):
        pass

assert_type(Class4(), Class4 | Any)

class Class5:
    def __new__(cls) -> NoReturn:
        raise NotImplementedError

    def __init__(self, x: int):
        pass

try:
    assert_type(Class5(), NoReturn)
except:
    pass

class Class6:
    def __new__(cls) -> "int | Class6":
        return 0

    def __init__(self, x: int):
        pass

assert_type(Class6(), int | Class6)

# > If the return type of __new__ is not annotated, a type checker may assume
# > that the return type is Self and proceed with the assumption that the
# > __init__ method will be called.

class Class7:
    def __new__(cls, *args, **kwargs):
        return super().__new__(cls, *args, **kwargs)

    def __init__(self, x: int):
        pass

assert_type(Class7(1), Class7)

[case class_dunder_new_conformance_tests3]
# flags: --mode default
# from conformance tests (constructors_call_new.py)

from typing import Generic, Self, TypeVar, assert_type
T = TypeVar("T")

# > If the class is generic, it is possible for a __new__ method to override
# > the specialized class type and return a class instance that is specialized
# > with different type arguments.

class Class8(Generic[T]):
    def __new__(cls, *args, **kwargs) -> "Class8[list[T]]": ...


assert_type(Class8[int](), Class8[list[int]])
assert_type(Class8[str](), Class8[list[str]])


# > If the cls parameter within the __new__ method is not annotated,
# > type checkers should infer a type of type[Self].


class Class9(Generic[T]):
    def __new__(cls, *args, **kwargs) -> Self: ...


class Class10(Class9[int]):
    pass


c10: Class9[int] = Class10()

# > Regardless of whether the type of the cls parameter is explicit or
# > inferred, the type checker should bind the class being constructed to
# > the cls parameter and report any type errors that arise during binding.


class Class11(Generic[T]):
    def __new__(cls: "type[Class11[int]]") -> "Class11[int]": ...

Class11()  # OK
Class11[int]()  # OK
Class11[str]()  # E: Invalid self argument "type[Class11[str]]" to attribute function "__new__" with type "type[Class11[int]]"

[case class_dunder_new_callable_conformance_tests_with_explicit_any]
# flags: --mode default
# from conformance tests (constructors_callable.py)

from typing import Generic, Self, TypeVar, assert_type, Any, overload, ParamSpec, Callable
T = TypeVar("T")
P = ParamSpec("P")
R = TypeVar("R")

def accepts_callable(cb: Callable[P, R]) -> Callable[P, R]:
    return cb

class Class6Any:
    """__new__ that causes __init__ to be ignored via Any"""

    def __new__(cls) -> Any:
        return super().__new__(cls)

    def __init__(self, x: int) -> None:
        """This __init__ is ignored for purposes of conversion"""
        pass


r6_any = accepts_callable(Class6Any)
reveal_type(r6_any)  # N: Revealed type is "def () -> Any"
assert_type(r6_any(), Any)
r6_any(1)  # E: Too many arguments

# > If the __init__ or __new__ method is overloaded, the callable type should
# > be synthesized from the overloads. The resulting callable type itself will
# > be overloaded.


class Class7(Generic[T]):
    @overload
    def __init__(self: "Class7[int]", x: int) -> None: ...
    @overload
    def __init__(self: "Class7[str]", x: str) -> None: ...
    def __init__(self, x: int | str) -> None:
        pass


r7 = accepts_callable(Class7)
reveal_type(r7)  # N: Revealed type is "Overload(def (x: int) -> __main__.Class7[int], def (x: str) -> __main__.Class7[str])"

assert_type(r7(0), Class7[int])
assert_type(r7(""), Class7[str])

[case class_as_callable_conformance_tests_and_generics]
# flags: --mode default
# from conformance tests (constructors_callable.py)

from typing import Generic, Self, TypeVar, assert_type, Any, overload, ParamSpec, Callable
T = TypeVar("T")
P = ParamSpec("P")
R = TypeVar("R")

def accepts_callable(cb: Callable[P, R]) -> Callable[P, R]:
    return cb

class Class8(Generic[T]):
    def __new__(cls, x: list[T], y: list[T]) -> Self:
        return super().__new__(cls)


r8 = accepts_callable(Class8)
reveal_type(r8)  # N: Revealed type is "def [T] (x: list[T], y: list[T]) -> __main__.Class8[T]"
assert_type(r8([""], [""]), Class8[str])
r8([1], [""])  # E: List item 0 has incompatible type "str"; expected "int"


class Class9:
    def __init__(self, x: list[T], y: list[T]) -> None:
        pass


r9 = accepts_callable(Class9)
reveal_type(r9)  # N: Revealed type is "def [T] (x: list[T], y: list[T]) -> __main__.Class9"
assert_type(r9([""], [""]), Class9)
r9([1], [""])  # E: List item 0 has incompatible type "str"; expected "int"

[case staticmethod_self_disallowed]
# From conformance tests (generics_self_usage.py)
from typing import Self
class Base:
    @staticmethod
    # This should generate an error.
    def make() -> Self:  # E: Static methods cannot use Self type
        ...

    @staticmethod
    # This should generate an error.
    def return_parameter(foo: Self) -> Self:  # E: Static methods cannot use Self type    # E: Static methods cannot use Self type
        ...

[case assigning_of_callable_to_self]
# From conformance tests (generics_param_spec_semantics.py)
from typing import Callable, assert_type
class Y[U, **P]:
    f: Callable[P, str]
    prop: U

    def __init__(self, f: Callable[P, str], prop: U) -> None:
        self.f = f
        self.prop = prop

def callback_a(q: int, /) -> str: ...

def func(x: int) -> None:
    y1 = Y(callback_a, x)
    assert_type(y1, Y[int, [int]])
    y2 = y1.f
    assert_type(y2, Callable[[int], str])

[case consistent_type_variable_ordering]
from typing import TypeVar, Generic
T1 = TypeVar("T1")
T2 = TypeVar("T2")
class Grandparent(Generic[T1, T2]): ...
class Parent(Grandparent[T1, T2]): ...
class BadChild(Parent[T1, T2], Grandparent[T2, T1]): ...  # E: Cannot determine consistent method resolution order (MRO) for "BadChild"

[case multiple_inheritance_no_crash_for_multiple_mappings]
# Something similar to this used to crash in primer
from collections.abc import Mapping, MutableMapping

class Mapping1(Mapping): ...

class Mapping2(Mapping1, MutableMapping): ...

class Mapping3(MutableMapping, Mapping1): ...

[case typing_extensions_override]
# flags: --enable-error-code explicit-override --python-version 3.11
from typing_extensions import override

class Foo:
    @override
    def __str__(self) -> str:
        return "<Foo>"

[case dunder_new_no_type_check]
from typing import no_type_check

class C:
    @no_type_check
    def __new__(cls) -> "C":
        return 1

# Methods
def f() -> C:
    return C()

[case cached_property_customized_no_crash]
# flags: --mode default
# From GH #213
class cached_property:
    def __init__(self, other): ...
    def __get__(self, obj, cls):
        pass

class ResourceContainer:
    def __init__(self, finder):
        self.finder = finder

    @cached_property
    def resources(self):
        return self.finder

class ResourceFinder:
    def fn(self):
        ResourceContainer(self).resources

[case dunder_eq_vs_dunder_ne]
# From GH #227
from typing import assert_type

class Equal:
    pass

class NotEqual:
    pass

class Foo:
    def __eq__(self, other: object) -> Equal:  # type: ignore
        return Equal()

    def __ne__(self, other: object) -> NotEqual:  # type: ignore
        return NotEqual()

assert_type(Foo() == 3, Equal)
assert_type(Foo() != 3, NotEqual)

[case list_addition_inference]
# From GH #201
from typing import assert_type
class A:
    pass

class B(A):
    pass

objs: list[A] = [A()] + [B()]
objs2: list[A] = [B()] + [A()]

objs3 = [A()] + [B()]
assert_type(objs3, list[A])
objs4 = [B()] + [A()]
assert_type(objs4, list[A])

[case property_without_positional_param]
# From GH #236
class C(A):  # E: Name "A" is not defined
    @property
    def p(*, val: None):  # E: Method must have at least one argument. Did you forget the "self" argument?
        pass

[case self_as_star_args]
# flags: --check-untyped-defs
# From GH #250
class C[T]:
    def f(*args):
        args.a = 1  # E: "tuple[Any, ...]" has no attribute "a"

C().a  # E: "C[Any]" has no attribute "a"
C().f()

[case magic_mock_assignment]
# From GH #292
from dataclasses import dataclass
from unittest.mock import AsyncMock, MagicMock, Mock

@dataclass
class AClass:
    a: int = 1

def _some_func(a: AClass) -> None:
    print(a.a)

amock = AsyncMock(spec=AClass)
amock.a = 5  # ok
_some_func(amock)

mmock = MagicMock(spec=AClass)
mmock.a = 5  # ok
_some_func(mmock)

mock = Mock(spec=AClass)
mock.a = 5  # ok
_some_func(mock)

_some_func(5)  # E: Argument 1 to "_some_func" has incompatible type "int"; expected "AClass"
