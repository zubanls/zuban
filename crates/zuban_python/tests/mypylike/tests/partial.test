[case infer_partial_list_with_changes_to_non_self]
# flags: --disallow-untyped-globals
# Like testInferAttributeInitializedToEmptyNonSelf, but with an explicit annotation
from typing import Self

class C:
    def __init__(self) -> None:
        self.a = []  # E: Need type annotation for "a" (hint: "a: List[<type>] = ...")
        if bool():
            a: Self = self
            a.a = [1]
            a.a.append(1)
reveal_type(C().a)  # N: Revealed type is "list[Any]"

[case partial_list_any_aug_assignment]

x = []
x += [undefined]  # E: Name "undefined" is not defined
reveal_type(x)  # N: Revealed type is "list[Any]"

y = []
y += undefined  # E: Name "undefined" is not defined
reveal_type(y)  # N: Revealed type is "list[Any]"

[case partial_list_any_aug_assignment_in_self]

class Foo:
    def __init__(self) -> None:
        self.x = []
        self.x += [undefined]  # E: Name "undefined" is not defined
        reveal_type(self.x)  # N: Revealed type is "list[Any]"

        self.y = []
        self.y += undefined  # E: Name "undefined" is not defined
        reveal_type(self.y)  # N: Revealed type is "list[Any]"

[case partial_list_aug_assignment_in_self]

class Foo:
    def __init__(self) -> None:
        self.x = []
        self.x += [1]
        reveal_type(self.x)  # N: Revealed type is "list[int]"

[case partial_list_never_aug_assignment]
# flags: --disallow-untyped-globals
x = []
x += []
x += [1]
reveal_type(x)  # N: Revealed type is "list[int]"

y = []  # E: Need type annotation for "y" (hint: "y: List[<type>] = ...")
y += []
reveal_type(y)  # N: Revealed type is "list[Any]"

[case module_mutual_flow_analysis_partial_list]
# flags: --warn-unreachable
import a
reveal_type(a.foo)  # N: Revealed type is "list[int]"
[file a.py]
bar = []
bar.append(1)
foo = bar
reveal_type(foo)  # N: Revealed type is "list[int]"

[case walrus_with_partial_list]
# flags: --warn-unreachable
# Like testWalrusPartialTypes, but with a bit of additional code as well
from typing import List

def check_partial_list() -> None:
    if (z := []):
        print(1)  # Theoretically this would be unreachable and could be analyzed as such as well.
    else:
        z.append(4)
    reveal_type(z)  # N: Revealed type is "list[int]"

[case partial_dict]
class A:
    def f(self) -> None:
        self.x = dict()
        self.x[1] = ""
        reveal_type(self.x)  # N: Revealed type is "dict[int, str]"

[case partial_defaultdict_with_set]
from collections import defaultdict
x = defaultdict(set)
x[1].add("")
reveal_type(x)  # N: Revealed type is "collections.defaultdict[int, set[str]]"

y = defaultdict(set)
y[1].update([""])
reveal_type(x)  # N: Revealed type is "collections.defaultdict[int, set[str]]"

[case partial_nullable_defaultdict_with_list_mypy_compatible]
# flags: --mode mypy
from collections import defaultdict
class A:
    def __init__(self) -> None:
        self.x = None
        self.x = defaultdict(list)
        self.x[0].extend([""])
        reveal_type(self.x)  # N: Revealed type is "collections.defaultdict[int, list[str]]"

reveal_type(A().x)  # N: Revealed type is "collections.defaultdict[int, list[str]]"

[case partial_nullable_defaultdict_with_list_no_mypy_compatible]
# flags: --mode default
from collections import defaultdict
class A:
    def __init__(self) -> None:
        self.x = None
        self.x = defaultdict(list)
        self.x[0].extend([""])
        reveal_type(self.x)  # N: Revealed type is "collections.defaultdict[int, list[str]]"

reveal_type(A().x)  # N: Revealed type is "collections.defaultdict[int, list[str]] | None"

[case partial_nullable_defaultdict_with_initialized_list]
# flags: --disallow-untyped-globals
from foo import x
reveal_type(x)  # N: Revealed type is "collections.defaultdict[Any, list[int]]"

[file foo.py]
from collections import defaultdict
x = None  # E: Need type annotation for "x"
x = defaultdict(list[int])
x['?'].append(1)
reveal_type(x)  # N: Revealed type is "collections.defaultdict[Any, list[int]]"

[case partial_nullable_self_overwrite_mypy_compatible]
# flags: --mode mypy
class A:
    def __init__(self) -> None:
        self.x = None
        self.x = []
        self.x = [1]
        reveal_type(self.x)  # N: Revealed type is "list[int]"

reveal_type(A().x)  # N: Revealed type is "list[int]"

[case partial_nullable_self_overwrite_no_mypy_compatible]
# flags: --mode default
class A:
    def __init__(self) -> None:
        self.x = None
        self.x = []
        self.x = [1]
        reveal_type(self.x)  # N: Revealed type is "list[int]"

reveal_type(A().x)  # N: Revealed type is "list[int] | None"

[case partial_nullable_self_augassign_mypy_compatible]
# flags: --mode mypy
class A:
    def __init__(self) -> None:
        self.x = None
        self.x = []
        self.x += [1]
        reveal_type(self.x)  # N: Revealed type is "list[int]"

reveal_type(A().x)  # N: Revealed type is "list[int]"

[case partial_nullable_self_augassign_no_mypy_compatible]
# flags: --mode default
class A:
    def __init__(self) -> None:
        self.x = None
        self.x = []
        self.x += [1]
        reveal_type(self.x)  # N: Revealed type is "list[int]"

reveal_type(A().x)  # N: Revealed type is "list[int] | None"

[case partial_nullable_self_dict_assign_mypy_compatible]
# flags: --mode mypy
class A:
    def __init__(self) -> None:
        self.x = None
        self.x = {}
        self.x["a"] = 1
        reveal_type(self.x)  # N: Revealed type is "dict[str, int]"

reveal_type(A().x)  # N: Revealed type is "dict[str, int]"

[case partial_nullable_self_dict_assign_no_mypy_compatible]
# flags: --mode default
class A:
    def __init__(self) -> None:
        self.x = None
        self.x = {}
        self.x["a"] = 1
        reveal_type(self.x)  # N: Revealed type is "dict[str, int]"

reveal_type(A().x)  # N: Revealed type is "dict[str, int] | None"

[case narrowed_partial1_mypy_compatible]
# flags: --mode mypy
import foo
reveal_type(foo.x)  # N: Revealed type is "list[str]"

[file foo.py]
x = None
x = []
x.append("")
reveal_type(x)  # N: Revealed type is "list[str]"

[case narrowed_partial1_no_mypy_compatible]
# flags: --mode default
import foo
reveal_type(foo.x)  # N: Revealed type is "list[str] | None"

[file foo.py]
x = None
x = []
x.append("")
reveal_type(x)  # N: Revealed type is "list[str]"

[case narrowed_partial2_mypy_compatible]
# flags: --mode mypy
import foo
reveal_type(foo.x)  # N: Revealed type is "dict[int, str]"

[file foo.py]
x = None
x = {}
x[0] = ""
reveal_type(x)  # N: Revealed type is "dict[int, str]"

[case narrowed_partial2_no_mypy_compatible]
# flags: --mode default
import foo
reveal_type(foo.x)  # N: Revealed type is "dict[int, str] | None"

[file foo.py]
x = None
x = {}
x[0] = ""
reveal_type(x)  # N: Revealed type is "dict[int, str]"

[case narrowed_partial3_mypy_compatible]
# flags: --mode mypy
import foo
reveal_type(foo.x)  # N: Revealed type is "list[int]"

[file foo.py]
x = None
x = []
x = [1]
reveal_type(x)  # N: Revealed type is "list[int]"

[case narrowed_partial3_no_mypy_compatible]
# flags: --mode default
import foo
reveal_type(foo.x)  # N: Revealed type is "list[int] | None"
reveal_type(foo.y)  # N: Revealed type is "set[int] | None"

[file foo.py]
x = None
x = []
x = [1]
reveal_type(x)  # N: Revealed type is "list[int]"

y = None
y = set()
y = {1}
reveal_type(y)  # N: Revealed type is "set[int]"

[case narrowed_partial4_mypy_compatible]
# flags: --mode mypy
import foo
reveal_type(foo.x)  # N: Revealed type is "list[int]"
reveal_type(foo.y)  # N: Revealed type is "set[int]"

[file foo.py]
x = None
x = []
x += [1]
reveal_type(x)  # N: Revealed type is "list[int]"

y = None
y = set()
y |= {1}
reveal_type(y)  # N: Revealed type is "set[int]"

[case narrowed_partial4_no_mypy_compatible]
# flags: --mode default
import foo
reveal_type(foo.x)  # N: Revealed type is "list[int] | None"
reveal_type(foo.y)  # N: Revealed type is "set[int] | None"

[file foo.py]
x = None
x = []
x += [1]
reveal_type(x)  # N: Revealed type is "list[int]"

y = None
y = set()
y |= {1}
reveal_type(y)  # N: Revealed type is "set[int]"

[case invalid_aug_partial_change]
# flags: --disallow-untyped-globals
x = set()  # E: Need type annotation for "x" (hint: "x: Set[<type>] = ...")
x |= [1]  # E: Argument 1 to "__ior__" of "set" has incompatible type "list[int]"; expected "AbstractSet[Any]"
x |= {1}
reveal_type(x)  # N: Revealed type is "set[int]"

y = set()  # E: Need type annotation for "y" (hint: "y: Set[<type>] = ...")
y *= [1]  # E: Unsupported operand types for * ("set[Any]" and "list[int]")
reveal_type(y)  # N: Revealed type is "set[Any]"

[case walrus_defaultdict_partial1]
# flags: --disallow-untyped-globals
from collections import defaultdict
walrus = (x := defaultdict(set))  # E: Need type annotation for "x"
reveal_type(walrus)  # N: Revealed type is "collections.defaultdict[Any, Any]"
x[1].add("")
reveal_type(x)  # N: Revealed type is "collections.defaultdict[int, set[str]]"

[case walrus_defaultdict_partial2]
# flags: --disallow-untyped-globals
from collections import defaultdict
walrus = (x := defaultdict(int))  # E: Need type annotation for "x"
reveal_type(walrus)  # N: Revealed type is "collections.defaultdict[Any, int]"
x[""] = 1
reveal_type(x)  # N: Revealed type is "collections.defaultdict[str, int]"

[case walrus_defaultdict_partial3]
# flags: --disallow-untyped-globals
from collections import defaultdict
walrus = (x := defaultdict(int))
x[""] = 1
walrus[1] = 1  # E: Invalid index type "int" for "defaultdict[str, int]"; expected type "str"
reveal_type(walrus)  # N: Revealed type is "collections.defaultdict[str, int]"
reveal_type(x)  # N: Revealed type is "collections.defaultdict[str, int]"

[case list_no_partial_if_super_class_defines_attribute]
class Super:
    x: list[int]
    def __init__(self) -> None:
        self.y: list[int] = [1]
        self.z = [2]

class Foo(Super):
    def cache(self) -> None:
        self.x = []
        self.x.append("a")  # E: Argument 1 to "append" of "list" has incompatible type "str"; expected "int"
        self.x.append(1)

        self.y = []
        self.y.append("a")  # E: Argument 1 to "append" of "list" has incompatible type "str"; expected "int"
        self.y.append(1)

        self.z = []
        self.z.append("a")  # E: Argument 1 to "append" of "list" has incompatible type "str"; expected "int"
        self.z.append(1)

[case dict_update_fallback_if_any]
from typing import Any

def f(a: Any) -> None:
    x = {}
    x.update(a)
    reveal_type(x)  # N: Revealed type is "dict[Any, Any]"

[case partials_in_for_loop_input]
# flags: --disallow-untyped-globals
for _, x in ((1, {}), ("", {})):  # E: Need type annotation for "x" (hint: "x: Dict[<type>, <type>] = ...")
    reveal_type(x)  # N: Revealed type is "dict[Any, Any]"

for _, y in ((1, []), ("", [])):  # E: Need type annotation for "y" (hint: "y: List[<type>] = ...")
    reveal_type(y)  # N: Revealed type is "list[Any]"

for _, z in ((1, set()), ("", set())):  # E: Need type annotation for "z" (hint: "z: Set[<type>] = ...")
    reveal_type(z)  # N: Revealed type is "set[Any]"

[case defaultdict_with_tuple]
from collections import defaultdict
x: dict[str, tuple[str, ...]] = defaultdict(tuple)
y: dict[str, tuple[int, ...]]  = defaultdict(tuple[int])

[case partial_set_return_from_untyped_func1]
# flags: --mode default
def f(x, errors=None):
    if errors is None:
        errors = set()

    if x > 1:
        errors.add(x)
        return (0, errors)
    return ("", errors)

size, errors = f(1)
reveal_type(errors)  # N: Revealed type is "Any | set[Any]"

[case partial_set_return_from_untyped_func2]
# flags: --mode default
def f(x, errors=None):
    if errors is None:
        errors = set()

    if x > 1:
        return (0, errors)
    return ("", errors)

size, errors = f(1)
reveal_type(errors)  # N: Revealed type is "Any | set[Any]"

[case partial_set_return_from_untyped_func3]
# flags: --mode default
def f():
    return set()

x = f()
x.add(1)
reveal_type(x)  # N: Revealed type is "set[Any]"

y = f()
y.add("")
reveal_type(y)  # N: Revealed type is "set[Any]"

[case partial_defaultdict_return_from_untyped_func]
# flags: --mode default
from collections import defaultdict
def f(x, errors=None):
    if errors is None:
        errors = defaultdict(list)

    if x > 1:
        return (0, errors)
    return ("", errors)

size, errors = f(1)
reveal_type(errors)  # N: Revealed type is "Any | collections.defaultdict[Any, list[Any]]"

[case optional_backwards_global]
# From testOptionalBackwards3, but test access from outside of the module
import m

reveal_type(m.Z)  # N: Revealed type is "int | None"
m.Z = None
m.Z = 1

[file m.py]
if bool():
    Z = 10
else:
    Z = None
