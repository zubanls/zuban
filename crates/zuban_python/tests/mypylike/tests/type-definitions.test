[case class_var_without_type_qualifier]
from typing import ClassVar

class Foo:
    x: ClassVar = 1

reveal_type(Foo.x)  # N: Revealed type is "int"
reveal_type(Foo().x)  # N: Revealed type is "int"
Foo().x = 3  # E: Cannot assign to class variable "x" via instance
Foo.x = 4

[case invalid_classvar_attribute]
from typing import ClassVar
class Foo:
    x: ClassVar[str].upper  # E: Invalid type comment or annotation

[case double_classvar_getitem]
from typing import ClassVar
class Foo:
    x: ClassVar[str][str]  # E: Invalid type comment or annotation

[case any_getitem]
from typing import Any
x: Any[int]  # E: Invalid type comment or annotation

[case avoid_type_cycle]
class Foo:
    foo: foo  # E: Name "foo" is not defined
    bar: list[bar]  # E: Name "bar" is not defined
    baz += baz  # E: Name "baz" is not defined   # E: Name "baz" is not defined
    bla: baz  # E: Invalid type comment or annotation

    x = x  # E: Name "x" is not defined
    y: x
    a = list[a]  # E: Name "a" is not defined
    b: a

[case avoid_type_cycle_in_assignment_expr]
class Foo:
    l = (x := x)  # E: Name "x" is not defined
    y: x
    l = (a := list[a])  # E: Name "a" is not defined
    b: a  # E: Invalid type comment or annotation

[case avoid_type_cycle_in_lambda]
class Foo:
    x = lambda x=x: x  # E: Name "x" is not defined

[case avoid_type_cycle_in_param]
from typing import cast
def foo(
    foo: foo  # E: Function "__main__.foo" is not valid as a type  # N: Perhaps you need "Callable[...]" or a callback protocol?
    ) -> foo: ...  # E: Function "__main__.foo" is not valid as a type  # N: Perhaps you need "Callable[...]" or a callback protocol?
def bar(
    bar: list[bar]  # E: Function "__main__.bar" is not valid as a type  # N: Perhaps you need "Callable[...]" or a callback protocol?
    ) -> list[bar]: ...  # E: Function "__main__.bar" is not valid as a type  # N: Perhaps you need "Callable[...]" or a callback protocol?
def baz(x: undefined) -> undefined2: ...  # E: Name "undefined" is not defined # E: Name "undefined2" is not defined

x = 1
def oneline1() -> None: cast(oneline1, x)  # E: Function "__main__.oneline1" is not valid as a type \
                                           # N: Perhaps you need "Callable[...]" or a callback protocol?
def oneline2() -> None: cast(undefined, x)  # E: Name "undefined" is not defined
def default_param_cast1(z: int = cast(undefined, 1)) -> None: ...  # E: Name "undefined" is not defined
def default_param_cast2(z: int = cast(default_param_cast2, 1)) -> None: ...  # E: Name "default_param_cast2" is used before definition \
                                                                             # E: Function "__main__.default_param_cast2" is not valid as a type \
                                                                             # N: Perhaps you need "Callable[...]" or a callback protocol?
[case avoid_type_cycle_in_class_def]
from typing import List
class Foo(Foo): ...  # E: Name "Foo" is used before definition  # E: Cannot resolve name "Foo" (possible cyclic definition)
class Bar(List[Bar]): ...  # E: Name "Bar" is used before definition

[case invalid_usage_of_param_spec_attr]
from typing import ParamSpec
P = ParamSpec("P")
def foo(*args: P.args, **kwargs: P.kwargs) -> None:  # E: ParamSpec "P" is unbound
    x: P.args  # E: ParamSpec components are not allowed here
    y: P.kwargs  # E: ParamSpec components are not allowed here
    z: P.undefined  # E: Name "P.undefined" is not defined
    x = args
    y = kwargs
    if bool():
        x = y
    y = x

[case namespace_attr]
import foo
x: foo.bar.baz.X
[file foo/__init__.py]
from foo.bar import baz
[file foo/bar/baz.py]
class X: ...

[case namedtuple_additional_invalid_definitions]
from typing import NamedTuple

Bar1 = NamedTuple("Bar1", [('x', *int)])  # E: Star args are not supported
Bar2 = NamedTuple("Bar2", [(*'x', int)])  # E: Invalid "NamedTuple()" field name
Bar3 = NamedTuple("Bar3", [*int])  # E: Tuple expected as "NamedTuple()" field
Bar4 = NamedTuple("Bar4", [()])  # E: NamedTuple field should be a tuple of a string literal and a type
Bar5 = NamedTuple("Bar5", [(*int,)])  # E: NamedTuple field should be a tuple of a string literal and a type
Bar6 = NamedTuple("Bar6", [('x',)])  # E: NamedTuple field should be a tuple of a string literal and a type

[case namedtuple_invalid_bound]
from typing import NamedTuple, Generic, TypeVar
T = TypeVar("T", bound=int)
class Foo(NamedTuple, Generic[T]):
    t: T

Bar = NamedTuple("Bar", [('x', T)])

x: Foo[str]  # E: Type argument "str" of "Foo" must be a subtype of "int"
y: Bar[str]  # E: Type argument "str" of "Bar" must be a subtype of "int"

[case typed_dict_invalid_bound]
from typing import TypedDict, Generic, TypeVar
T = TypeVar("T", bound=int)
class Foo(TypedDict, Generic[T]):
    t: T

Bar = TypedDict("Bar", {'x': T})

x: Foo[str]  # E: Type argument "str" of "Foo" must be a subtype of "int"
y: Bar[str]  # E: Type argument "str" of "Bar" must be a subtype of "int"

[case typed_dict_non_generic_getitem]
from typing import TypedDict
Bar = TypedDict("Bar", {'x': int})
x: Bar[int]  # E: Bad number of arguments for type alias, expected 0, given 1

[case invalid_class_type_application]
from typing import Generic, TypeVar
T = TypeVar("T")
class Foo(Generic[T]): ...
Foo[int][int]  # E: Invalid type comment or annotation

[case invalid_callable]
from typing import Callable

c1: Callable[int:str, int]  # E: Invalid callable params

reveal_type(c1)  # N: Revealed type is "def (*Any, **Any) -> int"

[case never_in_unions]
from typing import Union, Never

u1: Union[Never, Never]
u2: Union[Never]
u3: Union[Never, int]
u4: Union[Never, int, str, Never]

reveal_type(u1)  # N: Revealed type is "Never"
reveal_type(u2)  # N: Revealed type is "Never"
reveal_type(u3)  # N: Revealed type is "int"
reveal_type(u4)  # N: Revealed type is "int | str"

[case invalid_type_type]
from typing import Type
x: Type[int, str]  # E: Invalid type comment or annotation

[case fstring_forward_reference]
x: f'int'  # E: Invalid type comment or annotation

[case invalid_type_application]
from typing import Protocol, Generic
Generic[int]  # E: Invalid type application
Protocol[int]  # E: Invalid type application

[case parens_in_annotation]
class X:
    foo: (int)
    bar: ()  # E: Syntax error in type annotation \
             # N: Suggestion: Use Tuple[T1, ..., Tn] instead of (T1, ..., Tn)
    baz: (int) = 1

def foo(
        x: (tuple[int, str]),
        y: (),  # E: Syntax error in type annotation \
                # N: Suggestion: Use Tuple[T1, ..., Tn] instead of (T1, ..., Tn)
        z: (a := int),  # E: Invalid type comment or annotation
        ): ...

[case func_in_class_should_not_be_looked_at_as_a_type_definition]
bar = int
class Foo:
    x: foo  # E: Name "foo" is not defined
    y: bar

    def foo(self) -> None: ...
    def bar(self) -> None: ...

reveal_type(Foo().x)  # N: Revealed type is "Any"
reveal_type(Foo().y)  # N: Revealed type is "int"

[case invalid_module_getattr]
from ok import undefined1
from not_ok import undefined2
reveal_type(undefined1)  # N: Revealed type is "str"
reveal_type(undefined2)  # N: Revealed type is "Any"

x: undefined1  # E: Invalid type comment or annotation
y: undefined2

[file ok.py]
def __getattr__(name: str) -> str: ...
[file not_ok.py]
__getattr__ = 1  # E: Invalid signature "int" for "__getattr__"

[case type_var_tuple_unpack_in_callable]
from typing import TypeVarTuple, Callable, Unpack
Ts = TypeVarTuple("Ts")
x: Callable[[Ts], int]  # E: TypeVarTuple "Ts" is only valid with an unpack
y: Callable[[Unpack[Ts]], int]
z: Callable[[*Ts], int]
reveal_type(x)  # N: Revealed type is "def [Ts] (Any) -> int"
reveal_type(y)  # N: Revealed type is "def [Ts] (*Unpack[Ts]) -> int"
reveal_type(z)  # N: Revealed type is "def [Ts] (*Unpack[Ts]) -> int"

[case mypy_extensions_invalid_callable_param_positional]
from typing import Callable
from mypy_extensions import Arg, DefaultArg

x1: Callable[[Arg(int, f"{1}")], int]  # E: Name argument should be a string literal
x2: Callable[[Arg(int, 1)], int] # E: Name argument should be a string literal \
                                 # E: No overload variant of "Arg" matches argument types "type[int]", "int" \
                                 # N: Possible overload variants: \
                                 # N:     def [_T] Arg(type: _T, name: str | None = ...) -> _T \
                                 # N:     def Arg(*, name: str | None = ...) -> Any

reveal_type(x2)  # N: Revealed type is "def (int) -> int"

[case mypy_extensions_invalid_callable_param_named]
from typing import Callable
from mypy_extensions import NamedArg, DefaultNamedArg

x1: Callable[[NamedArg()], int]
x2: Callable[[DefaultNamedArg()], int]

z: int = x1  # E: Incompatible types in assignment (expression has type "Callable[[Any], int]", variable has type "int")
z = x2  # E: Incompatible types in assignment (expression has type "Callable[[Any], int]", variable has type "int")

[case invalid_type_comment_with_star]
foo = 1  # type: *foo  # E: Star expressions are not allowed within a type comment
bar = (1, b'')  # type: (int, *str)  # E: Star expressions are not allowed within a type comment
reveal_type(foo)  # N: Revealed type is "Any"
reveal_type(bar)  # N: Revealed type is "tuple[int, Any]"

[case diverging_type_var_tuple_nesting]
from typing import TypeAlias, TypeVarTuple, Unpack
Ts = TypeVarTuple("Ts")
D = list[F[tuple[*Ts]]]  # E: Invalid recursive alias: type variable nesting on right hand side \
                      # E: Name "F" is used before definition
F = D[*Ts]  # Error reported above

# Is this fine?
A = list[B[*Ts]]  # E: Name "B" is used before definition
B = A[*Ts]

x: A[int]
y: D[int]

[case types_with_invalid_unpack1]
from typing import TypeAlias, TypeVarTuple, Unpack, TypeVar, Generic
T = TypeVar("T")
U = TypeVar("U")
Ts = TypeVarTuple("Ts")

class Foo(Generic[T, *Ts, U]): ...

def f1(x: tuple[*Ts]) -> Foo[int, *tuple[*Ts, str]]: ...
reveal_type(f1)  # N: Revealed type is "def [Ts] (x: tuple[Unpack[Ts]]) -> __main__.Foo[int, Unpack[Ts], str]"

def f2(x: tuple[*Ts]) -> Foo[int, *tuple[*Ts]]: ...  # E: TypeVarTuple cannot be split
reveal_type(f2)  # N: Revealed type is "def [Ts] (x: tuple[Unpack[Ts]]) -> __main__.Foo[int, Unpack[Ts], Any]"

def f3(x: tuple[*Ts]) -> Foo[int, *tuple[*tuple[bytes, ...]]]: ...
reveal_type(f3)  # N: Revealed type is "def [Ts] (x: tuple[Unpack[Ts]]) -> __main__.Foo[int, Unpack[Tuple[bytes, ...]], bytes]"

def f4(x: tuple[*Ts]) -> Foo[*tuple[int, *tuple[bytes, ...]]]: ...
reveal_type(f4)  # N: Revealed type is "def [Ts] (x: tuple[Unpack[Ts]]) -> __main__.Foo[int, Unpack[Tuple[bytes, ...]], bytes]"

def f5(x: tuple[*Ts]) -> Foo[*tuple[int, *Ts]]: ...  # E: TypeVarTuple cannot be split
reveal_type(f5)  # N: Revealed type is "def [Ts] (x: tuple[Unpack[Ts]]) -> __main__.Foo[int, Unpack[Ts], Any]"

def f6(x: tuple[*Ts]) -> Foo[*tuple[*Ts, str]]: ...  # E: TypeVarTuple cannot be split
reveal_type(f6)  # N: Revealed type is "def [Ts] (x: tuple[Unpack[Ts]]) -> __main__.Foo[Any, Unpack[Ts], str]"

[case types_with_invalid_unpack2]
from typing import TypeAlias, TypeVarTuple, Unpack, TypeVar, Generic
T = TypeVar("T")
U = TypeVar("U")
Ts = TypeVarTuple("Ts")

class Foo(Generic[T, *Ts, U]): ...

def f(x: tuple[*Ts]) -> Foo[*Ts]: ...  # E: TypeVarTuple cannot be split # E: TypeVarTuple cannot be split
reveal_type(f)  # N: Revealed type is "def [Ts] (x: tuple[Unpack[Ts]]) -> __main__.Foo[Any, Unpack[Ts], Any]"

[case type_var_likes_invalid_assignment]
from typing import TypeVar, TypeVarTuple, ParamSpec

A, B = TypeVar("A", bound=int)  # E: Invalid assignment form for TypeVar, please use the simple form "X = TypeVar(..)"
def foo(x: A): ...  # E: Invalid type comment or annotation

C, D = TypeVarTuple("C")  # E: Invalid assignment form for TypeVarTuple, please use the simple form "X = TypeVarTuple(..)"

E, F = ParamSpec("E")  # E: Invalid assignment form for ParamSpec, please use the simple form "X = ParamSpec(..)"

[case type_var_likes_invalid_param]
from typing import TypeVar, TypeVarTuple, ParamSpec
T = TypeVar("T", **{"x": "y"})  # E: Unexpected argument to "TypeVar()"
Ts = TypeVarTuple("Ts", **{"x": "y"})  # E: Unexpected argument to "TypeVarTuple()"
P = ParamSpec("P", **{"x": "y"})  # E: Unexpected argument to "ParamSpec()"

[case new_type_invalid_assignment_form]
from typing import NewType
A, B = NewType("A", int)  # E: Invalid assignment form for NewType, please use the simple form "X = NewType(..)"

[case new_type_recursion_same_module]
from typing import NewType
A = NewType("A", list["int | A"])
B = NewType("B", "B")  # E: Argument 2 to NewType(...) must be subclassable (got "B")
C = NewType("C", list["undefined | A"])  # E: Name "undefined" is not defined

a1: A = 1  # E: Incompatible types in assignment (expression has type "int", variable has type "A")
a2: A = A([1])
a3: A = A([a1])
b1: B = 1  # E: Incompatible types in assignment (expression has type "int", variable has type "B")
b2: B = B(b1)
c1: C = 1  # E: Incompatible types in assignment (expression has type "int", variable has type "C")
c2: C = C([c1])
c3: C = C([1])

[case new_type_recursion_other_module]
import m
a1: m.A = 1  # E: Incompatible types in assignment (expression has type "int", variable has type "A")
a2: m.A = m.A([1])
a3: m.A = m.A([a1])
b1: m.B = 1  # E: Incompatible types in assignment (expression has type "int", variable has type "B")
b2: m.B = m.B(b1)
c1: m.C = 1  # E: Incompatible types in assignment (expression has type "int", variable has type "C")
c2: m.C = m.C([c1])
c3: m.C = m.C([1])

[file m.py]
from typing import NewType
A = NewType("A", list["int | A"])
B = NewType("B", "B")  # E: Argument 2 to NewType(...) must be subclassable (got "B")
C = NewType("C", list["undefined | A"])  # E: Name "undefined" is not defined

[case double_string_in_annotation]
# flags: --show-column-numbers
x: 'list["str"]'
y: 'list["undefined"]'

[out]
__main__:3:11: error: Name "undefined" is not defined

[case union_alias_attr_access]
# flags: --show-error-codes
from typing import Union
X = Union[int, str]
Y = int | str

reveal_type(X.__args__)  # E: "_SpecialForm" has no attribute "__args__"  [attr-defined] \
                         # N: Revealed type is "Any"
reveal_type(Y.__args__)  # N: Revealed type is "tuple[Any, ...]"

reveal_type(Union[int, str].__args__)  # E: "_SpecialForm" has no attribute "__args__"  [attr-defined] \
                                       # N: Revealed type is "Any"
reveal_type((int | str).__args__)  # N: Revealed type is "tuple[Any, ...]"

X.undefined  # E: "_SpecialForm" has no attribute "undefined"  [attr-defined]
Y.undefined  # E: "UnionType" has no attribute "undefined"  [attr-defined]

[case annotated_in_alias]
from typing import Annotated, Optional, TypeVar
T = TypeVar("T")

X = Annotated[int, "foo"]

def check(x: X): ...

def foo(z: T) -> T: ...

reveal_type(foo(Annotated[int, "blabla"]))  # N: Revealed type is "typing._SpecialForm"
reveal_type(foo(Annotated[Optional[int], "blabla"]))  # N: Revealed type is "typing._SpecialForm"

[case typing_extensions_get_origin_import_should_not_crash]
from typing_extensions import get_origin

[case type_alias_weird_initializations]
from typing import TypeAlias
X = int | str # type: TypeAlias  # E: TypeAlias comment currently not supported
Y: TypeAlias = int | str
Z: TypeAlias  # E: Right side needed for TypeAlias
def f(x: X, y: Y, z: Z):
    reveal_type(x)  # N: Revealed type is "Any"
    reveal_type(y)  # N: Revealed type is "int | str"
    reveal_type(z)  # N: Revealed type is "Any"

[case no_crash_on_badly_defined_type_alias]
from typing import TypeAlias

M: TypeAlias = None  # type: can't parse me!  # E: Invalid syntax
N: TypeAlias = None  # type: int

def foo(x: M, y: N):
    reveal_type(x)  # N: Revealed type is "Any"
    reveal_type(y)  # N: Revealed type is "None"

[case invalid_param_types_should_not_crash]
def foo(a: str, b: int = 1, c = 1):
    x: a  # E: Variable "__main__.a" is not valid as a type \
          # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#variables-vs-type-aliases
    y: b  # E: Variable "__main__.b" is not valid as a type \
          # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#variables-vs-type-aliases
    z: c  # E: Variable "__main__.c" is not valid as a type \
          # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#variables-vs-type-aliases

[case constraint_matching_should_be_ignored_or_work_but_never_crash]
# Constraint was not implemented at the time of writing this test, here we ensure that it does at least not crash
from typing import TypeVar, Generic
T = TypeVar('T', str, bytes)
def f(x: T):
    foo(type(pattern))

def foo(o: object): ...

class C(Generic[T]):
    def __init__(self, pattern: T):
        foo(type(pattern))

[case getattr_on_module_with_specific_type]
import m

x: m.A  # E: Invalid type comment or annotation

[file m.py]
def __getattr__(name: str) -> int: ...

[case invalid_dunder_annotation_attrs]
class A:
    def f(
        self,
        a: __module__,  # E: Invalid type comment or annotation
        b: __debug__,  # E: Invalid type comment or annotation
        c: __name__,  # E: Invalid type comment or annotation
        c: __file__,  # E: Invalid type comment or annotation
    ) : ...

[case nested_class_annotation]
from m import D

class C:
    def f(self, x: D.F):
        pass

[file m.py]
class D:
    class E: ...
    class F(E): ...

[case avoid_alias_recursion_crash_with_annotated]
from typing import Annotated
AliasedType = Annotated[int, "aliased"]

def aliased() -> AliasedType: ...

[case avoid_alias_recursion_crash_with_unknown]
AliasedType = Unknown[int, "aliased"]  # E: Name "Unknown" is not defined

def aliased() -> AliasedType: ...  # E: Variable "__main__.AliasedType" is not valid as a type \
                                   # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#variables-vs-type-aliases

[case redefining_type_variables]
# flags: --disallow-redefinition
# From testRedefineVariableAsTypevar, but fully implemented
from typing import TypeVar
x = 0
x = TypeVar('x') # E: Incompatible types in assignment (expression has type "TypeVar", variable has type "int")

[case type_var_on_attribute_before_and_after_def]
import typing as t

class Foo(t.Generic['T']): ...

T = t.TypeVar('T')

class Bar(t.Generic['T']): ...

[case global_or_nonlocal_type_definition]
X = list[int]

def foo() -> None:
    global X
    x: X  # E: Invalid type comment or annotation

    Y = list[str]
    def bar() -> None:
        nonlocal Y
        y: Y  # E: Invalid type comment or annotation

[case param_name_used_in_type_definition]
from typing import Any

def foo(a: Any, b: int, c: str = "", *args: Any, d: bytes = b'', **kwargs: Any):
    a1: a  # E: Variable "__main__.a" is not valid as a type  # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#variables-vs-type-aliases
    b1: b  # E: Variable "__main__.b" is not valid as a type  # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#variables-vs-type-aliases
    c1: c  # E: Variable "__main__.c" is not valid as a type  # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#variables-vs-type-aliases
    d1: d  # E: Variable "__main__.d" is not valid as a type  # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#variables-vs-type-aliases
    args1: args  # E: Variable "__main__.args" is not valid as a type  # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#variables-vs-type-aliases
    kwargs2: kwargs  # E: Variable "__main__.kwargs" is not valid as a type  # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#variables-vs-type-aliases

[case module_getattr_types]
import m, n, o, p
a: m.X
b: n.X  # E: Invalid type comment or annotation
c: o.X
d: p.X  # E: Invalid type comment or annotation

[file m.py]
def __getattr__(n): ...

[file n.py]
def __getattr__(n) -> int: ...

[file o.py]
import typing
def __getattr__(n) -> typing.Any: ...

[file p.py]
__getattr__ = 1  # E: Invalid signature "int" for "__getattr__"

[case type_var_used_in_untyped_function]
# flags: --no-check-untyped-defs
from typing import TypeVar
def f():
    T = TypeVar("T")
    f: T  # N: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs \
          # E: Type variable "__main__.T" is unbound \
          # N: (Hint: Use "Generic[T]" or "Protocol[T]" base class to bind "T" inside a class) \
          # N: (Hint: Use "T" in function signature to bind "T" inside a function)


[case conditional_type_invalid_when_any_is_assigned]
# flags: --disallow-redefinition
from typing import TypeAlias, Any, Mapping
if bool():
    X: TypeAlias = int
else:
    X = Any  # E: Incompatible types in assignment (expression has type "object", variable has type "type[int]")

[case type_alias_invalid_star_in_type_var_bounds]
def f[T: (int, *str)](t: T) -> list[T]: ...  # E: Unpack is only valid in a variadic position

[case type_of_none_alias_in_different_module]
import m
def f(
    x: m.void,
    y: m.void,
    a: m.int_literal,  # E: Variable "m.int_literal" is not valid as a type  # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#variables-vs-type-aliases
    b: m.int_literal,  # E: Variable "m.int_literal" is not valid as a type  # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#variables-vs-type-aliases
):
    reveal_type(x)  # N: Revealed type is "type[None]"
    reveal_type(m.void)  # N: Revealed type is "type[None]"

[file m.py]
void = type(None)
int_literal = type(1)

[case type_alias_type_without_string_literal]
from typing import TypeAliasType

s = str()
TA = TypeAliasType(s, int)  # E: Argument 1 to TypeAliasType(...) must be a string literal

def f(x: TA) -> None:
    reveal_type(x)  # N: Revealed type is "int"

[case type_param_with_multiple_type_var_tuples]
# Ok
def x[*Ts, *Ts2](x: tuple[*Ts], *y: *Ts2) -> tuple[tuple[*Ts], tuple[*Ts2]]:
    reveal_type(x)  # N: Revealed type is "tuple[Unpack[Ts]]"
    reveal_type(y)  # N: Revealed type is "tuple[Unpack[Ts2]]"
    return (x, y)

x((1, 2), "", b'')

type A[*Ts, *Ts2] = tuple[tuple[*Ts], tuple[*Ts2]]  # E: Can only use one TypeVarTuple in type params \
                                                    # E: All type parameters should be declared ("Ts2" not declared)
class C[*Ts, *Ts2](tuple[tuple[*Ts], tuple[*Ts2]]): ...  # E: Can only use one TypeVarTuple in type params \
                                                         # E: All type parameters should be declared ("Ts2" not declared)

def f(a: A[int, str, bytes], c: C[int, str, bytes]):
    reveal_type(a)  # N: Revealed type is "tuple[tuple[int, str, bytes], tuple[Any, ...]]"
    reveal_type(c)  # N: Revealed type is "tuple[tuple[int, str, bytes], tuple[Any, ...], fallback=__main__.C[int, str, bytes]]"

[case type_of_complex_type_definition]
X = type(list[int])

def f(x: X) -> None: ... # E: Invalid type comment or annotation

[case type_reassignment_multiple_times]
x = y = int

def foo(a: x, b: y):
    reveal_type(a)  # N: Revealed type is "int"
    reveal_type(b)  # N: Revealed type is "int"

[case reassign_builtin_and_using_it_in_annotation_no_crash]
# TODO this test is wrong
import m
x: m.ExceptionGroup[int]  # E: Bad number of arguments for type alias, expected 0, given 1
reveal_type(x)  # N: Revealed type is "Any"

[file m.py]
ExceptionGroup = ExceptionGroup  # E: Name "ExceptionGroup" is used before definition \
                                 # E: Invalid recursive alias: a union item of itself \
                                 # E: Cannot resolve name "ExceptionGroup" (possible cyclic definition)

[case type_var_as_def]
from typing import TypeVar

T = TypeVar("T")

def f(a: T) -> T:
    check1(a)  # E: Argument 1 to "check1" has incompatible type "T"; expected "TypeVar"
    check1(1)  # E: Argument 1 to "check1" has incompatible type "int"; expected "TypeVar"
    check1(T)

    b = [a]
    check2(b)  # E: Argument 1 to "check2" has incompatible type "list[T]"; expected "list[TypeVar]"
    c = [T]
    check2(c)
    return a

def check1(y: TypeVar): ...
def check2(y: list[TypeVar]): ...

[case type_var_tuple_as_def]
from typing import TypeVarTuple

Ts = TypeVarTuple("Ts")

x: TypeVarTuple = Ts
y: int = Ts  # E: Incompatible types in assignment (expression has type "TypeVarTuple", variable has type "int")

[case param_spec_as_def]
from typing import ParamSpec

P = ParamSpec("P")

x: ParamSpec = P
y: int = P  # E: Incompatible types in assignment (expression has type "ParamSpec", variable has type "int")

[case invalid_type_when_inferred]
X = [int][0]
Y = 3[0]  # E: Value of type "int" is not indexable
def f(
    x: X,  # E: Variable "__main__.X" is not valid as a type  # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#variables-vs-type-aliases
    y: Y  # E: Variable "__main__.Y" is not valid as a type  # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#variables-vs-type-aliases
):
    reveal_type(x)  # N: Revealed type is "Any"

[case literal_nested]
# Copied from conformance tests (literals_parametrizations.py)
from typing import Literal
good11: Literal[Literal[Literal[1, 2, 3], "foo"], 5, None]

[case avoid_error_in_invalid_syntax_definition_when_used]
async def list  # E: Invalid syntax

@foo()  # E: Name "foo" is not defined
async def list_foo() -> list[str]:
    return []

[case type_alias_with_type_vars_in_parens]
from typing import TypeAlias, TypeVar

T = TypeVar("T")

A: TypeAlias = (
    list[T]
    | T
)

def f(x: A[int]):
    reveal_type(x)  # N: Revealed type is "list[int] | int"
    if isinstance(x, list):
        reveal_type(x[0])  # N: Revealed type is "int"

[case type_alias_no_confusion_with_bitwise_or_operations]
# From GH #87
import os

def unrelated(path: str) -> None:
    assert os.path.isabs(path)

def bar(path: str) -> None:
    flags = os.O_WRONLY | os.O_CREAT

[case implicit_alias_choices]
from typing import Any, Never, Annotated, Self, Literal, LiteralString, Union, \
    Optional, Type, Callable, Tuple, TypeVar

T = TypeVar("T")

X = 1
a1 = int | Optional[T]
i1: a1[int]
a2 = Optional[T] | int
i2: a2[int]
a3 = int | X[T]  # E: Value of type "int" is not indexable
i3: a3[int]  # E: Variable "__main__.a3" is not valid as a type \
             # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#variables-vs-type-aliases
a4 = int | Union[T]
i4: a4[int]

a5 = int | tuple[T]
i5: a5[int]
a6 = int | Tuple[T]
i6: a6[int]

a7 = int | type[T]
i7: a7[int]
a8 = int | Type[T]
i8: a8[int]

a9 = int | Callable[[T], int]
i9: a9[int]

a10 = int | Annotated[T, 1]
i10: a10[int]

a11 = list[T] | LiteralString
i11: a11[int]
a12 = list[T] | Literal[1]
i12: a12[int]

a13 = list[T] | Never
i13: a13[int]
a14 = list[T] | Any
i14: a14[int]

class C:
    a15 = list[T] | Self  # E: Self type cannot be used in type alias target
    i15: a15[int]

[case binary_or_is_no_type_definition]
# From GH #65
[file config.py]
from typing import TypedDict

class ConfigDict(TypedDict):
    env: dict[str, str]

CONFIG: ConfigDict = {
    'env': {},
}

[file env.py]
import os
MY_ENV = {
    'PATH': os.environ["PATH"],
}

[file process.py]
import os
from config import CONFIG

def run(env: dict[str, str]):
    env_vars = os.environ | CONFIG['env']
    if env is not None:
        env_vars |= env

[case multiline_forward_ref_no_crash]
# flags: --no-windows
# From https://github.com/zubanls/zuban/issues/80
a: """
1
2"""""

[out]
__main__:4: error: Invalid syntax

[case forward_ref_disallow_string_not_around_annotations]
# Copied from conformance tests (annotations_forward_refs.py)
bad1: ClassA  # E?: Runtime error prior to 3.14: requires quotes
bad2: list[ClassA]  # E?: Runtime error prior to 3.14: requires quotes
bad3: "ClassA" | int  # E: Forward reference unions cause runtime errors, consider wrapping the whole annotation with a string
bad4: int | "ClassA"  # E: Forward reference unions cause runtime errors, consider wrapping the whole annotation with a string

class ClassA:
    ...

[case avoid_recursion_problem_in_with]
with a as a:  # E: Name "a" is used before definition  # E: Cannot resolve name "a" (possible cyclic definition)
    pass

[case class_incomplete_definition_should_not_crash]
# See GH #78
class c[T:a]:
    pass

class c[a]  # E: Invalid syntax

[case type_redefinition_with_annotations]
# flags: --no-mypy-compatible
# Partially from GH #99
def check1() -> None:
    if bool():
        result: str = "low"
    else:
        result: str = "high"
    reveal_type(result)  # N: Revealed type is "str"

def check2() -> None:
    if bool():
        result: str = "low"
    else:
        result: int = 1  # E: Name "result" already defined on line 12
    reveal_type(result)  # N: Revealed type is "str"

def check3(result: str) -> None:
    if bool():
        result: str = "low"
    reveal_type(result)  # N: Revealed type is "str"

def check4(result: int) -> None:
    if bool():
        result: str = "low"  # E: Name "result" already defined on line 22
    reveal_type(result)  # N: Revealed type is "int"

def check5() -> None:
    if bool():
        result = "low"
    else:
        result: str = "high"
    reveal_type(result)  # N: Revealed type is "str"

def check6() -> None:
    if bool():
        result = 1
    else:
        result: str = "high"  # E: Name "result" already defined on line 36
    reveal_type(result)  # N: Revealed type is "int"

def check7() -> None:
    if bool():
        result: str = "low"
    else:
        result: str = 1  # E: Incompatible types in assignment (expression has type "int", variable has type "str")
    reveal_type(result)  # N: Revealed type is "str"

[case multiple_type_var_tuples_with_syntax_no_crash]
# From GH #131
class C[*T, *U, *V]():  # E: Can only use one TypeVarTuple in type params \
                        # E: Can only use one TypeVarTuple in type params
    pass

C[int]

[case type_alias_recursion_should_no_crash]
# From GH #144
from typing import Any
type T[U: T] = T[Any]  # E: Invalid recursive alias: a union item of itself

[case invalid_type_definition_no_crash]
# From GH #198
def f(a: T):
    pass

T = T()  # E: Name "T" is used before definition

[case type_definitions_and_local_partial_types]
# flags: --local-partial-types
from typing import TypeVar

TFloat = TypeVar("TFloat", bound=float)
X = list[TFloat]

def foo() -> None:
    p6: X[str]  # E: Type argument "str" of "X" must be a subtype of "float"

[case type_alias_type_conformance_tests_no_tuple]
# Copied from conformance tests (aliases_typealiastype.py)
from typing import TypeAliasType, TypeVar
S = TypeVar("S")
T = TypeVar("T")
my_tuple = (S, T)
BadAlias3 = TypeAliasType("BadAlias3", int, type_params=my_tuple)  # E: Tuple literal expected as the type_params argument to TypeAliasType

[case type_alias_type_in_class_with_outer_type_var]
# flags: --no-mypy-compatible
# Partially copied from conformance tests (aliases_typealiastype.py)
from typing import TypeAliasType, TypeVar, Generic
T = TypeVar("T")
class ClassA(Generic[T]):
    type good = list[T]
    GoodAlias6 = TypeAliasType("GoodAlias6", list[T])

[case multiline_annotation]
value: """
    int |
    str |
    list[int]
"""

[case recursive_type_should_not_hang]
# From GH #207
from typing import Any
class C[T, *Ts, **P]:
    pass

C[*C]  # E: Bad number of arguments, expected: at least 2, given: 1 \
       # E: "C[Any, Unpack[Tuple[Any, ...]], [*Any, **Any]]" cannot be unpacked (must be tuple or TypeVarTuple)
C[int, *tuple[Any, ...]]  # E: Invalid callable params

[case high_memory_for_type_definition]
# From GH #249
[for x in y: type z[T] = 0]  # E: Invalid syntax
T

[case load_type_var_despite_flow_analysis]
from m import T
from n import C

def f(x: C[int]):
    reveal_type(x)  # N: Revealed type is "n.C[int]"

[file m.py]
from typing import TypeVar
if bool():
    from n import some_definition
T = TypeVar("T")

[file n.py]
from typing import Generic
from m import T

if bool():
    some_definition = 1
else:
    some_definition = 2

class C(Generic[T]): ...

[case load_type_var_in_stub_cycle]
from n import some_definition

[file m.pyi]
from typing import TypeVar, Generic
from n import C
if bool():
    from n import some_definition
    T = TypeVar("T")

def f(x: C[int]):
    reveal_type(x)  # N: Revealed type is "n.C[int]"

[file n.pyi]
from typing import Generic
from m import T

if bool():
    some_definition = 1
else:
    some_definition = 2

class C(Generic[T]): ...
