[case enum_ignore_deleted]
# Similar to testEnumIgnoreIsDeleted, but additional cases
from enum import Enum
from typing import Literal

class C(Enum):
    _ignore_ = 'X'

    X = 1
    Y = 2

C._ignore_ # E: "type[C]" has no attribute "_ignore_"
C.Y._ignore_ # E: "C" has no attribute "_ignore_"

c: C
cy: Literal[C.Y]
c._ignore_ # E: "C" has no attribute "_ignore_"
cy._ignore_ # E: "Literal[C.Y]" has no attribute "_ignore_"

[case enum_multi_literal]
from enum import Enum

E = Enum("E", "Fo" "o Bar")

reveal_type(E.Foo)  # N: Revealed type is "Literal[__main__.E.Foo]?"
reveal_type(E.Bar)  # N: Revealed type is "Literal[__main__.E.Bar]?"

[case enum_str_passed]
from enum import Enum
x = "Foo"
E = Enum(x, 'a b') # E: Enum() expects a string literal as the first argument

[case functional_enum_dict_literal_errors]
from enum import Enum
x = "asdf"
E = Enum("E", {x: 1}) # E: Enum() with dict literal requires string literals

[case functional_enum_starred_dict_literal_errors]
from enum import Enum
c = {"x": 1}
E = Enum("E", {**c}) # E: Enum() with dict literal requires string literals

[case functional_enum_with_list_input]
from enum import Enum
def foo() -> list[str]: return []
c: list[str]
E = Enum("E", c) # E: Second argument of Enum() must be string, tuple, list or dict literal for mypy to determine Enum members
E = Enum("E", foo()) # E: Second argument of Enum() must be string, tuple, list or dict literal for mypy to determine Enum members

[case functional_enum_attempt_to_reuse_keys]
# functional cases for testEnumReusedKeys
from enum import Enum
from typing import Literal

E1 = Enum("E1", "A B A")  # E: Attempted to reuse member name "A" in Enum definition "E1"
E2 = Enum("E2", ["A",
                 "A",  # E: Attempted to reuse member name "A" in Enum definition "E2"
                 "B",
                 ])
E3 = Enum("E3", [("A", 1),
                 ("A",  # E: Attempted to reuse member name "A" in Enum definition "E3"
                  2),
                 ("B", 3),
                 ])
E4 = Enum("E4", {"A": 1,
                 "A":  # E: Attempted to reuse member name "A" in Enum definition "E4"
                  2,
                 "B": 3,
                 })
reveal_type(E4.A.value)  # N: Revealed type is "Literal[1]?"
reveal_type(E4.B.value)  # N: Revealed type is "Literal[3]?"

x: Literal["A B A"]
E5 = Enum("E5", x)  # E: Attempted to reuse member name "A" in Enum definition "E5"

[case flag_or_for_member]
from enum import Flag
E = Flag("E", 'x y')
x: E
reveal_type(E.x | E.y)  # N: Revealed type is "__main__.E"
reveal_type(x | E.y)  # N: Revealed type is "__main__.E"
reveal_type(E.x | x)  # N: Revealed type is "__main__.E"
reveal_type(x | x)  # N: Revealed type is "__main__.E"

[case enum_from_final]
# Like testEnumCreatedFromFinalValue, but without Final[str], which makes no sense.
from enum import Enum
from typing_extensions import Final

x: Final = 'ANT BEE CAT DOG'
Animal = Enum('Animal', x)
reveal_type(Animal.ANT)  # N: Revealed type is "Literal[__main__.Animal.ANT]?"
reveal_type(Animal.BEE)  # N: Revealed type is "Literal[__main__.Animal.BEE]?"
reveal_type(Animal.CAT)  # N: Revealed type is "Literal[__main__.Animal.CAT]?"
reveal_type(Animal.DOG)  # N: Revealed type is "Literal[__main__.Animal.DOG]?"

[case enum_formatting_distinct]
import a
import b
x: a.B
y: b.B
x = y  # E: Incompatible types in assignment (expression has type "b.B", variable has type "a.B")
[file a.py]
from enum import Enum
class B(Enum):
    b = 10

[file b.py]
from enum import Enum
class B(Enum):
    b = 10

[case enum_method_binding]
from enum import Enum
from typing import Self

class A(Enum):
    x = "x"

    def foo(self) -> Self:
        return self

x = A("x").foo()
reveal_type(x)  # N: Revealed type is "__main__.A"
type(x)("x")

y = A("x").foo()
reveal_type(y)  # N: Revealed type is "__main__.A"
type(y)("x")

[case enum_members_in_dict_inference_use_joins]
# flags: --use-joins
from typing import Final, Literal
from enum import Enum

class A(Enum):
    x = "x"
    y = "y"
    z = "z"

a1 = {"x": A.x, "y": A.y}
reveal_type(a1)  # N: Revealed type is "dict[str, __main__.A]"

a2 = dict(x=A.x, y=A.y)
reveal_type(a2)  # N: Revealed type is "dict[str, Literal[__main__.A.x]? | Literal[__main__.A.y]?]"

def expect_a(x: dict[str, A]) -> None: ...

def foo(x: Literal[A.x], y: Literal[A.y], z: A) -> None:
    a3 = {"x": x, "y": y}
    expect_a(a3)
    a4 = {"x": x, "x2": x}
    expect_a(a4)
    a5 = {"x": x, "x2": A.x}
    expect_a(a5)
    a6 = {"x": x, "x2": A.y}
    expect_a(a6)

    a7 = {"x": A.x, "x2": y}
    expect_a(a7)
    a8 = {"x": A.x, "x2": y}
    expect_a(a8)

[case enum_members_in_dict_inference_no_use_joins]
# flags: --no-use-joins
from typing import Final, Literal
from enum import Enum

class A(Enum):
    x = "x"
    y = "y"
    z = "z"

a1 = {"x": A.x, "y": A.y}
reveal_type(a1)  # N: Revealed type is "dict[str, __main__.A]"

a2 = dict(x=A.x, y=A.y)
reveal_type(a2)  # N: Revealed type is "dict[str, __main__.A]"

def expect_a(x: dict[str, A]) -> None: ...

def foo(x: Literal[A.x], y: Literal[A.y], z: A) -> None:
    a3 = {"x": x, "y": y}
    expect_a(a3)
    a4 = {"x": x, "x2": x}
    expect_a(a4)
    a5 = {"x": x, "x2": A.x}
    expect_a(a5)
    a6 = {"x": x, "x2": A.y}
    expect_a(a6)

    a7 = {"x": A.x, "x2": y}
    expect_a(a7)
    a8 = {"x": A.x, "x2": y}
    expect_a(a8)

[case enum__call__]
from typing import Literal
from enum import Enum

class A(Enum):
    x = "x"
    def __call__(self, x: int) -> None: ...

def foo(x: Literal[A.x], y: A) -> None:
    x()  # E: Missing positional argument "x" in call to "__call__" of "A"
    x(1)
    y()  # E: Missing positional argument "x" in call to "__call__" of "A"
    y(1)

[case enum__call__]
from typing import Literal
from enum import Enum

class A(Enum):
    x = "x"
    def __call__(self, x: int) -> None: ...

def foo(x: Literal[A.x], y: A) -> None:
    x()  # E: Missing positional argument "x" in call to "__call__" of "A"
    x(1)
    y()  # E: Missing positional argument "x" in call to "__call__" of "A"
    y(1)

[case enum_member_issues]
from enum import Enum
A = Enum("A", [[]])  # E: Enum() with tuple or list expects strings or (name, value) pairs
B = Enum("B", [["foo"]])  # E: Enum() with tuple or list expects strings or (name, value) pairs
lst = [""]
C = Enum("C", [[*lst]])  # E: Enum() with tuple or list expects strings or (name, value) pairs
D = Enum("D", [["x", *lst]])  # E: Enum() with tuple or list expects strings or (name, value) pairs
E = Enum("E", [[*lst, *lst]])  # E: Enum() with tuple or list expects strings or (name, value) pairs
F = Enum("F", [*lst])  # E: Enum() with tuple or list expects strings or (name, value) pairs
G = Enum("G", f"x {1}")  # E: Second argument of Enum() must be string, tuple, list or dict literal for mypy to determine Enum members

def f(x: A, y: B, z: C) -> None: ...

[case enum_with_or_should_not_panic]
from enum import Enum

class Foo(Enum):
    e = 1

Bar = Foo | int

[case invalid_enum_execution_with_attr_access]
from enum import Enum

Enum().x  # E: Too few arguments for Enum()

[case final_as_enum_attr_is_fine]
from typing import Literal
from n import C

def f(name: Literal[C.X]):
    reveal_type(name)  # N: Revealed type is "Literal[n.C.X]"

[file n.py]
from enum import Enum
from typing import Final
class C(Enum):
    X: Final = '', 1

[case func_with_enum_default_and_underscore]
from enum import Enum
class UndefinedType(Enum):
    _singleton = 0

UNDEFINED = UndefinedType._singleton
reveal_type(UNDEFINED)  # N: Revealed type is "__main__.UndefinedType"

def x(z: str | UndefinedType = UNDEFINED): ...

[case custom_enum_meta_still_valid_as_enum_literals]
# Copied from conformance tests (enums_definition.py)
from enum import EnumType
from typing import Literal, assert_type
class CustomEnumType(EnumType): pass
class CustomEnum2(metaclass=CustomEnumType): pass
class Color11(CustomEnum2):
    RED = 1
    GREEN = 2

assert_type(Color11.RED, Literal[Color11.RED])
reveal_type(Color11.GREEN)  # N: Revealed type is "Literal[__main__.Color11.GREEN]?"

[case enum_annotations_are_not_members_in_stubs]
import m

class MyEnum(m.GEnum):
    ONE = 1

def my_enum_func(enum: MyEnum) -> None: ...
my_enum_func(MyEnum.ONE)

[file m.pyi]
from enum import Enum

class GEnum(Enum):
    value_nick: str

[case enum_comparison_with_member_with_strict_equality]
# flags: --strict
from enum import Enum

class PartitionTable(Enum):
    GPT = 'gpt'

    def is_gpt(self) -> bool:
        return self == PartitionTable.GPT

    def is_gpt2(self) -> bool:
        return PartitionTable.GPT == self

[case enum_classmethods_final]
# From GH #154
import enum
from typing import TYPE_CHECKING, Self, final

@final
class MyEnum(enum.StrEnum):
    FOO = "foo"

    @classmethod
    def build(cls) -> Self:
        if TYPE_CHECKING:
            reveal_type(cls.FOO)  # N: Revealed type is "Literal[__main__.MyEnum.FOO]?"
            reveal_type(MyEnum.FOO)  # N: Revealed type is "Literal[__main__.MyEnum.FOO]?"
        return cls.FOO

    @classmethod
    def build2(cls) -> Self:
        if TYPE_CHECKING:
            reveal_type(cls.FOO)  # N: Revealed type is "Literal[__main__.MyEnum.FOO]?"
            reveal_type(MyEnum.FOO)  # N: Revealed type is "Literal[__main__.MyEnum.FOO]?"
        return MyEnum.FOO

    @classmethod
    def cast(cls, value: str) -> Self:
        return cls(value)

[case enum_classmethods_non_final]
# From GH #154
import enum
from typing import TYPE_CHECKING, Self, final

class MyEnum(enum.StrEnum):
    FOO = "foo"

    @classmethod
    def build(cls) -> Self:
        if TYPE_CHECKING:
            reveal_type(cls.FOO)  # N: Revealed type is "Literal[__main__.MyEnum.FOO]?"
            reveal_type(MyEnum.FOO)  # N: Revealed type is "Literal[__main__.MyEnum.FOO]?"
        return cls.FOO

    @classmethod
    def build2(cls) -> Self:
        if TYPE_CHECKING:
            reveal_type(cls.FOO)  # N: Revealed type is "Literal[__main__.MyEnum.FOO]?"
            reveal_type(MyEnum.FOO)  # N: Revealed type is "Literal[__main__.MyEnum.FOO]?"
        return MyEnum.FOO

    @classmethod
    def cast(cls, value: str) -> Self:
        return cls(value)


[case enum_without_members_should_not_lead_to_creation_error]
import enum

class Color(enum.Enum):
    RED = 1
    GREEN = 2
    BLUE = 3

Color(str())


class ColorBad(enum.Enum):
    pass


ColorBad(str())

[case enum_ensure_valid_value]
# Copied from conformance tests (enums_member_values.py)
from enum import Enum
class Color3(Enum):
    _value_: int
    RED = 1  # OK
    GREEN = "green"  # E: Enum value type "str" does not match the type "int" of "_value_"

class Planet2(Enum):
    _value_: str

    def __init__(self, value: int, mass: float, radius: float):
        self._value_ = value  # E: Incompatible types in assignment (expression has type "int", variable has type "str")

    MERCURY = (1, 3.303e23, 2.4397e6)

[case enum_nonmember_access_in_different_ways]
from typing import Literal
from enum import Enum, member, nonmember

class A(Enum):
    x = member(1)
    y = nonmember(2)

def some_a(a: A, b: type[A], c: Literal[A.x]):
    reveal_type(a.x)  # N: Revealed type is "Literal[__main__.A.x]?"
    reveal_type(b.x)  # N: Revealed type is "Literal[__main__.A.x]?"
    reveal_type(c.x)  # N: Revealed type is "Literal[__main__.A.x]?"

    reveal_type(a.y)  # N: Revealed type is "int"
    reveal_type(b.y)  # N: Revealed type is "int"
    reveal_type(c.y)  # N: Revealed type is "int"

[case customized_staticmethod_and_classmethod_no_enum_members]
from enum import Enum

def identity(x: int) -> int:
    return x

def classm(c, x: int) -> int:
    return x

class E(Enum):
    x = staticmethod(identity)
    y = classmethod(classm)
    z = int()

reveal_type(E.x)  # N: Revealed type is "def (x: int) -> int"
reveal_type(E.y)  # N: Revealed type is "def (x: int) -> int"
reveal_type(E.z)  # N: Revealed type is "Literal[__main__.E.z]?"

[case enum_member_alias_lookup]
# Partially copied from conformance tests (enums_members.py)
from enum import Enum
from typing import Literal, assert_type
class TrafficLight(Enum):
    RED = 1
    GREEN = 2
    YELLOW = 3

    AMBER = YELLOW  # Alias for YELLOW

assert_type(TrafficLight.AMBER, Literal[TrafficLight.YELLOW])

def f(a: TrafficLight, b: type[TrafficLight], c: Literal[TrafficLight.YELLOW]):
    reveal_type(a.AMBER)  # N: Revealed type is "Literal[__main__.TrafficLight.YELLOW]?"
    reveal_type(b.AMBER)  # N: Revealed type is "Literal[__main__.TrafficLight.YELLOW]?"
    reveal_type(c.AMBER)  # N: Revealed type is "Literal[__main__.TrafficLight.YELLOW]?"

[case str_enum_as_a_tagged_union]
# flags: --warn-unreachable
# From GH #182
import dataclasses
import enum
from typing import Literal, assert_never


class ModelType(enum.StrEnum):
    A = "a"
    B = "b"
    C = "c"
    D = "d"


@dataclasses.dataclass
class A:
    value: int
    type: Literal[ModelType.A] = ModelType.A


@dataclasses.dataclass
class B:
    value: int
    type: Literal[ModelType.B] = ModelType.B


@dataclasses.dataclass
class CD:
    value: int
    type: Literal[ModelType.C, ModelType.D]


def foo(var: CD | B) -> None:
    if var.type == ModelType.B:
        reveal_type(var)  # N: Revealed type is "__main__.B"


def bar(var: A | B | CD) -> None:
    if var.type == ModelType.A:
        reveal_type(var)  # N: Revealed type is "__main__.A"
    elif var.type == ModelType.B:
        reveal_type(var)  # N: Revealed type is "__main__.B"
    elif var.type == ModelType.C:
        reveal_type(var)  # N: Revealed type is "__main__.CD"
    elif var.type == ModelType.D:
        reveal_type(var)  # N: Revealed type is "__main__.CD"
    else:
        assert_never(var)
