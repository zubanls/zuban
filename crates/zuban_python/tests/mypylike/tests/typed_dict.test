[case single_line_typed_dict]
from typing import TypedDict

class A(TypedDict): x = 1  # E: Invalid statement in TypedDict definition; expected "field_name: field_type"
class B(TypedDict): x: str

reveal_type(A)  # N: Revealed type is "def (*, x: Any) -> TypedDict('__main__.A', {'x': Any})"
reveal_type(B)  # N: Revealed type is "def (*, x: str) -> TypedDict('__main__.B', {'x': str})"

[case unpack_optional_args]
from typing import TypedDict, Unpack
from typing_extensions import NotRequired

class A(TypedDict, total=False):
    x: int
    y: int

class B(TypedDict):
    x: int
    y: NotRequired[int]

def foo(**kwargs: Unpack[A]) -> None: ...
def bar(**kwargs: Unpack[B]) -> None: ...

foo()
bar()  # E: Missing named argument "x" for "bar"
foo(y=1)
bar(y=1)  # E: Missing named argument "x" for "bar"
foo(x=1)
bar(x=1)

[case invalid_typed_dict_inference]
# This used to lead to stack overflows
from typing import TypeVar
T = TypeVar("T")
U = TypeVar("U")
def foo(x: T) -> T:
    def bar(x: U, y: T) -> U: ...

    bar(1, {})  # E: Argument 2 to "bar" has incompatible type "dict[Never, Never]"; expected "T"
    return x

[case accessing_special_implementations]
from typing import TypedDict

class TD(TypedDict):
    x: int

def foo(x: TD) -> None:
    x.get.__sizeof__

[case typed_dict_passing_to_callable]
from typing import TypedDict, Callable

class TD(TypedDict):
    x: int

def foo(x: type[TD]) -> None:
    def wanted(*, x: int) -> TD: ...
    y = wanted
    if bool():
        y = x
    y = TD

[case typed_dict_passing_to_callable_generic]
# flags: --disallow-redefinition
from typing import TypedDict, Callable, Generic, TypeVar

T = TypeVar("T")

class TD(TypedDict, Generic[T]):
    x: T

def foo(x: type[TD[int]], y: type[TD[str]]) -> None:
    def wanted(*, x: int) -> TD: ...
    w = wanted
    if bool():
        w = x
    if bool():
        w = y  # E: Incompatible types in assignment (expression has type "type[__main__.TD[str]]", variable has type "Callable[[NamedArg(int, 'x')], __main__.TD[Any]]")
    w = TD

[case invalid_typed_dict]
from typing import TypedDict

A = TypedDict()  # E: TypedDict() expects a string literal as the first argument
B, C = TypedDict("B", {'x': int})  # E: Invalid assignment form for TypedDict, please use the simple form "X = TypedDict(..)"
D = TypedDict("D", x=int)  # E: TypedDict() expects a dictionary literal as the second argument
E = TypedDict("E", lambda: None)  # E: TypedDict() expects a dictionary literal as the second argument

[case typed_dict_slice_index]
from typing import TypedDict

class TD(TypedDict):
    x: int

def f(x: TD):
    x['x']
    x['x':'x']  # E: TypedDict key must be a string literal; expected one of ("x")

[case typed_dict_invalid_arguments]
from typing import TypedDict

class TD(TypedDict):
    x: int
    y: str

TD(x=3, y="")
TD(3)  # E: Expected keyword arguments, {...}, or dict(...) in TypedDict constructor
TD(3, "")  # E: Expected keyword arguments, {...}, or dict(...) in TypedDict constructor
TD(x=3, **{"y": ""})  # E: Unexpected argument to "TD"
TD(x=3, **{"z": ""})  # E: Unexpected argument to "TD"

class Other(TypedDict):
    z: int

TD(Other(z=1))  # E: Expected keyword arguments, {...}, or dict(...) in TypedDict constructor
TD(TD(x=1, y=""))

[case typed_dict_fields_with_final_and_class_var]
# Copied testTypedDictFinalAndClassVar with changed messages
from typing import TypedDict, Final, ClassVar

class My(TypedDict):
    a: Final      # E: Final can be only used as an outermost qualifier in a variable annotation
    b: Final[int] # E: Final can be only used as an outermost qualifier in a variable annotation
    c: ClassVar       # E: Invalid Type: ClassVar nested inside other type
    d: ClassVar[int]  # E: Invalid Type: ClassVar nested inside other type

Func = TypedDict('Func', {
    'a': Final,         # E: Final can be only used as an outermost qualifier in a variable annotation
    'b': Final[int],    # E: Final can be only used as an outermost qualifier in a variable annotation
    'c': ClassVar,      # E: Invalid Type: ClassVar nested inside other type
    'd': ClassVar[int], # E: ClassVar can only be used for assignments in class body
})

[case invariant_typed_dict_matching]
from typing import TypedDict
class A(TypedDict):
    x: str
class B(TypedDict):
    x: str
    y: int
class C(TypedDict):
    x: str
    y: int
    z: bytes

def check_covariant(a: A, b: B, c: C):
    if bool():
        a = a
        a = b
        a = c
    b = a  # E: Incompatible types in assignment (expression has type "A", variable has type "B")
    b = b
    b = c

def check_invariant(a: set[A], b: set[B], c: set[C]):
    if bool():
        a = a
        a = b  # E: Incompatible types in assignment (expression has type "set[B]", variable has type "set[A]")
        a = c  # E: Incompatible types in assignment (expression has type "set[C]", variable has type "set[A]")
    b = a  # E: Incompatible types in assignment (expression has type "set[A]", variable has type "set[B]")
    b = b
    b = c  # E: Incompatible types in assignment (expression has type "set[C]", variable has type "set[B]")

[case typed_dict_name_resolving_if_member_has_same_name]
from typing import TypedDict
import m

class A(TypedDict):
    a: int

class B(A):
    m: m.C
    n: m.C  # E: Invalid type comment or annotation

def foo(b: B):
    b.m  # E: "B" has no attribute "m"
    reveal_type(b['a'])  # N: Revealed type is "int"
    reveal_type(b['m'])  # N: Revealed type is "m.C"
    reveal_type(b['n'])  # N: Revealed type is "Any"

[file m.py]
class C: ...

[case typed_dict_name_resolving_if_member_has_same_name_but_is_defined_later]
from typing import TypedDict

class A(TypedDict):
    a: int

class B(A):
    m: m.C
    n: m.C  # E: Invalid type comment or annotation

def foo(b: B):
    b.m  # E: "B" has no attribute "m"
    reveal_type(b['a'])  # N: Revealed type is "int"
    reveal_type(b['m'])  # N: Revealed type is "m.C"
    reveal_type(b['n'])  # N: Revealed type is "Any"

import m

[file m.py]
class C: ...

[case generic_typed_dict_alias]
from typing import TypedDict, TypeVar, Generic
T = TypeVar("T")

class TD(TypedDict, Generic[T]):
    a: T
A = TD[int]
reveal_type(A(a=1))  # N: Revealed type is "TypedDict('__main__.TD', {'a': int})"
A(a='')  # E: Incompatible types (expression has type "str", TypedDict item "a" has type "int")

class InvalidGeneric(TypedDict):
    a: T  # E: Type variable "__main__.T" is unbound \
          # N: (Hint: Use "Generic[T]" or "Protocol[T]" base class to bind "T" inside a class) \
          # N: (Hint: Use "T" in function signature to bind "T" inside a function)

B = InvalidGeneric[int]  # E: "InvalidGeneric" expects no type arguments, but 1 given
reveal_type(B(a=1))  # N: Revealed type is "TypedDict('__main__.InvalidGeneric', {'a': Any})"
B(a='')

[case typed_dict_alias_and_access]
# Like testTypedDictAliasGeneric, but with type access and a type alias from syntax
from typing import TypedDict

class A[T](TypedDict):
    x: T

A0 = A
class B(A0[str]):  # E: Bad number of arguments for type alias, expected 0, given 1
    y: int

def f(x: B) -> None:
    reveal_type(x['x'])  # N: Revealed type is "Any"

[case typed_dict_in_callable_unpack_for_conformance_tests]
# Copied in parts from conformance tests (callables_kwargs.py)
from typing import TypedDict, Required, NotRequired, Unpack
class TD1(TypedDict):
    v1: Required[int]
    v2: NotRequired[str]


class TD2(TD1):
    v3: Required[str]

def func1(**kwargs: Unpack[TD2]) -> None: ...
def func2(v3: str, **kwargs: Unpack[TD1]) -> None: ...
def func3() -> None:
    td2 = TD2(v1=2, v3="4")
    func2(**td2)  # OK
    func1(v1=2, **td2)  # E: "func1" gets multiple values for keyword argument "v1"
    func2(1, **td2)  # E: "func2" gets multiple values for keyword argument "v3" \
                     # E: Argument 1 to "func2" has incompatible type "int"; expected "str"
    func2(v1=1, **td2)  # E: "func2" gets multiple values for keyword argument "v1"

[case typed_dict_in_callable_unpack_protocol_matching]
# Copied in parts from conformance tests (callables_kwargs.py)
from typing import TypedDict, Required, NotRequired, Unpack, Protocol
class TD1(TypedDict):
    v1: Required[int]
    v2: NotRequired[str]


class TD2(TD1):
    v3: Required[str]

def func1(**kwargs: Unpack[TD2]) -> None: ...
def func2(v3: str, **kwargs: Unpack[TD1]) -> None: ...

class TDProtocol1(Protocol):
    def __call__(self, *, v1: int, v3: str) -> None: ...
class TDProtocol2(Protocol):
    def __call__(self, *, v1: int, v3: str, v2: str = "") -> None: ...
class TDProtocol3(Protocol):
    def __call__(self, *, v1: int, v2: int, v3: str) -> None: ...
class TDProtocol4(Protocol):
    def __call__(self, *, v1: int) -> None: ...
class TDProtocol5(Protocol):
    def __call__(self, v1: int, v3: str) -> None: ...
class TDProtocol6(Protocol):
    def __call__(self, **kwargs: Unpack[TD2]) -> None: ...

v1: TDProtocol1 = func1  # OK
v2: TDProtocol2 = func1  # OK
v3: TDProtocol3 = func1  # E: Incompatible types in assignment (expression has type "Callable[[**Unpack[TD2]], None]", variable has type "TDProtocol3")
v4: TDProtocol4 = func1  # E: Incompatible types in assignment (expression has type "Callable[[**Unpack[TD2]], None]", variable has type "TDProtocol4")
v5: TDProtocol5 = func1  # E: Incompatible types in assignment (expression has type "Callable[[**Unpack[TD2]], None]", variable has type "TDProtocol5")
v6: TDProtocol6 = func1  # OK

[case invalid_typed_dict_definitions_in_class_args]
# Copied from conformance tests (typeddicts_class_syntax.py)
from typing import TypedDict
class BadTypedDict2(TypedDict, metaclass=type):  # E: Unexpected keyword argument "metaclass" for "TypedDict"
    name: str

# This should generate an error because "other" is not an allowed keyword argument.
class BadTypedDict3(TypedDict, other=True):  # E: Unexpected keyword argument "other" for "TypedDict"
    name: str

[case typed_dict_not_assignable_to_any_dict]
# Copied from conformance tests (typeddicts_type_consistency.py)
from typing import TypedDict, Mapping, Any

class B3(TypedDict):
    x: int
    y: int


b3: B3 = {"x": 0, "y": 0}

# > A TypedDict isn’t consistent with any Dict[...] type.

d1: dict[str, int] = b3  # E: Incompatible types in assignment (expression has type "B3", variable has type "dict[str, int]")
d2: dict[str, object] = b3  # E: Incompatible types in assignment (expression has type "B3", variable has type "dict[str, object]")
d3: dict[Any, Any] = b3  # E: Incompatible types in assignment (expression has type "B3", variable has type "dict[Any, Any]")

# > A TypedDict with all int values is not consistent with Mapping[str, int].

m1: Mapping[str, int] = b3  # E: Incompatible types in assignment (expression has type "B3", variable has type "Mapping[str, int]")
m2: Mapping[str, object] = b3  # OK
m3: Mapping[str, Any] = b3  # OK

[case typed_dict_extra_items_initialization]
# Copied from conformance tests (typeddicts_extra_items.py)
from typing_extensions import TypedDict, assert_type, ReadOnly

class Movie(TypedDict, extra_items=bool):
    name: str

a: Movie = {"name": "Blade Runner", "novel_adaptation": True}  # OK
b: Movie = {"name": "Blade Runner", "year": 1982}  # E: Incompatible types (expression has type "int", TypedDict item "year" has type "bool")

# > The alternative inline syntax is also supported::

MovieFunctional = TypedDict("MovieFunctional", {"name": str}, extra_items=bool)

c: MovieFunctional = {"name": "Blade Runner", "novel_adaptation": True}  # OK
d: MovieFunctional = {"name": "Blade Runner", "year": 1982}  # E: Incompatible types (expression has type "int", TypedDict item "year" has type "bool")

# > Accessing extra items is allowed. Type checkers must infer their value type from
# > the ``extra_items`` argument

def movie_keys(movie: Movie) -> None:
    assert_type(movie["name"], str)
    assert_type(movie["novel_adaptation"], bool)

# > ``extra_items`` is inherited through subclassing

class MovieBase(TypedDict, extra_items=ReadOnly[int | None]):
    name: str

class InheritedMovie(MovieBase):
    year: int

e: InheritedMovie = {"name": "Blade Runner", "year": None}  # E: Incompatible types (expression has type "None", TypedDict item "year" has type "int")
f: InheritedMovie = {
    "name": "Blade Runner",
    "year": 1982,
    "other_extra_key": None,
}  # OK

[case typed_dict_closed]
# Copied from conformance tests (typeddicts_extra_items.py)
from typing_extensions import TypedDict, ReadOnly, Never

class IllegalTD(TypedDict, closed=42 == 42):  # E: "closed" argument must be a True or False literal
    name: str

# > Passing ``closed=False`` explicitly requests the default TypedDict behavior,
# > where arbitrary other keys may be present and subclasses may add arbitrary items.

class BaseTD(TypedDict, closed=False):
    name: str

class ChildTD(BaseTD):  # OK
    age: int

# > It is a type checker error to pass ``closed=False`` if a superclass has
# > ``closed=True`` or sets ``extra_items``.

class ClosedBase(TypedDict, closed=True):
    name: str

class IllegalChild1(ClosedBase, closed=False):  # E: Cannot set "closed=False" when superclass is "closed=True"
    pass

class ExtraItemsBase(TypedDict, extra_items=int):
    name: str

class IllegalChild2(ExtraItemsBase, closed=False):  # E: Cannot set "closed=False" when superclass has "extra_items"
    pass

# > If ``closed`` is not provided, the behavior is inherited from the superclass.
# > If the superclass is TypedDict itself or the superclass does not have ``closed=True``
# > or the ``extra_items`` parameter, the previous TypedDict behavior is preserved:
# > arbitrary extra items are allowed. If the superclass has ``closed=True``, the
# > child class is also closed.

class BaseMovie(TypedDict, closed=True):
    name: str

class MovieA(BaseMovie):  # OK, still closed
    pass

class MovieB(BaseMovie, closed=True):  # OK, but redundant
    pass

class MovieC(MovieA):
    age: int  # E: TypedDict member "age" is required, but the extra_items of the super class are not

class MovieD(MovieB):
    age: int  # E: TypedDict member "age" is required, but the extra_items of the super class are not

# > It is possible to use ``closed=True`` when subclassing if the ``extra_items``
# > argument is a read-only type.

class MovieES(TypedDict, extra_items=ReadOnly[str]):
    pass

class MovieClosed(MovieES, closed=True):  # OK
    pass

class MovieNever(MovieES, extra_items=Never):  # OK, but 'closed=True' is preferred
    pass

class IllegalCloseNonReadOnly(ExtraItemsBase, closed=True):  # E: Cannot set "closed=True" when superclass has non-read-only "extra_items"
    pass

[case typed_dict_closed_with_read_only]
# Copied from conformance tests (typeddicts_extra_items.py)
from typing_extensions import TypedDict, ReadOnly, Never, Required, NotRequired

class ExtraItemsBase(TypedDict, extra_items=int):
    name: str

class MovieES(TypedDict, extra_items=ReadOnly[str]):
    pass

class MovieClosed(MovieES, closed=True):  # OK
    pass

class MovieNever(MovieES, extra_items=Never):  # OK, but 'closed=True' is preferred
    pass

class IllegalCloseNonReadOnly(ExtraItemsBase, closed=True):  # E: Cannot set "closed=True" when superclass has non-read-only "extra_items"
    pass

# > It is an error to use ``Required[]`` or ``NotRequired[]`` with ``extra_items``.

class IllegalExtraItemsTD(TypedDict, extra_items=Required[int]):  # E: "extra_items" value cannot be "Required[...]"
    name: str

class AnotherIllegalExtraItemsTD(TypedDict, extra_items=NotRequired[int]):  # E: "extra_items" value cannot be "NotRequired[...]"
    name: str

# > The extra items are non-required, regardless of the totality of the
# > TypedDict. Operations that are available to ``NotRequired`` items should also be available to the
# > extra items.

class MovieEI(TypedDict, extra_items=int):
    name: str

def del_items(movie: MovieEI) -> None:
    del movie["name"]  # E: Key "name" of TypedDict "MovieEI" cannot be deleted
    del movie["year"]  # OK: The value type of "year" is "NotRequired[int]"

class ReadOnlyBase(TypedDict, extra_items=ReadOnly[int]):
    pass

class ReadOnlyChild(ReadOnlyBase, extra_items=ReadOnly[bool]):  # OK
    pass

class MutableChild(ReadOnlyBase, extra_items=int):  # OK
    pass

# > Because a non-closed TypedDict type implicitly allows non-required extra items
# > of value type ``ReadOnly[object]``, its subclass can override the
# > ``extra_items`` argument with more specific types.

class NonClosedBase(TypedDict):
    name: str

class SpecificExtraItems(NonClosedBase, extra_items=bytes):  # OK
    year: int


[case typed_dict_extra_items_with_unpack]
# Copied mostly from conformance tests (typeddicts_extra_items.py)
from typing_extensions import TypedDict, Unpack

class MovieNoExtra(TypedDict):
    name: str

class MovieExtra(TypedDict, extra_items=int):
    name: str

def unpack_no_extra(**kwargs: Unpack[MovieNoExtra]) -> None: ...
def unpack_extra(**kwargs: Unpack[MovieExtra]) -> None: ...

unpack_no_extra(name="No Country for Old Men", year=2007) # E: Unexpected keyword argument "year" for "unpack_no_extra"
unpack_extra(name="No Country for Old Men", year=2007) # OK

dct_int = {"": 1}
unpack_extra(**dct_int)  # E: Argument 1 to "unpack_extra" has incompatible type "**dict[str, int]"; expected "str"
unpack_extra(name="foo", **dct_int)

unpack_extra(foo=1, **dct_int)  # E: Argument 2 to "unpack_extra" has incompatible type "**dict[str, int]"; expected "str"
unpack_extra(name="foo", foo=1, **dct_int)

unpack_extra(name="foo", foo="", **dct_int)  # E: Argument "foo" to "unpack_extra" has incompatible type "str"; expected "int"

dct_str = {"": ""}
unpack_extra(name="foo", **dct_str)  # E: Argument 2 to "unpack_extra" has incompatible type "**dict[str, str]"; expected "int"

[case typed_dict_extra_items_subclassing]
# Copied from conformance tests (typeddicts_extra_items.py)
from typing_extensions import TypedDict, NotRequired, ReadOnly

# > First, it is not allowed to change the value of ``extra_items`` in a subclass
# > unless it is declared to be ``ReadOnly`` in the superclass.

class Parent(TypedDict, extra_items=int | None):
    pass

class Child(Parent, extra_items=int): # E: Cannot change "extra_items" type unless it is "ReadOnly" in the superclass
    pass

# > Second, ``extra_items=T`` effectively defines the value type of any unnamed
# > items accepted to the TypedDict and marks them as non-required. Thus, the above
# > restriction applies to any additional items defined in a subclass.

class MovieBase2(TypedDict, extra_items=int | None):
    name: str

class MovieRequiredYear(MovieBase2):
    year: int | None  # E: TypedDict member "year" is required, but the extra_items of the super class are not

class MovieNotRequiredYear(MovieBase2):
    year: NotRequired[int]  # E: TypedDict member "year" type "int" is not assignable, but the extra_items of the super class are of type "int | None"

class MovieWithYear(MovieBase2):  # OK
    year: NotRequired[int | None]

class BookBase(TypedDict, extra_items=ReadOnly[int | None]):
    name: str

class BookWithPublisher(BookBase):
    publisher: str  # E: TypedDict member "publisher" type "str" is not assignable, but the extra_items of the super class are of type "int | None"

class BookWithPublisher2(BookBase):
    publisher: NotRequired[int | None]

class BookWithPublisher3(BookBase):
    publisher: NotRequired[ReadOnly[int | None]]

[case typed_dict_extra_items_matching1]
# Mostly copied from conformance tests (typeddicts_extra_items.py)
from typing_extensions import TypedDict, NotRequired, ReadOnly

class MovieBase2(TypedDict, extra_items=int | None):
    name: str

class MovieDetails(TypedDict, extra_items=int | None):
    name: str
    year: NotRequired[int]

details2: MovieDetails = {"name": "Kill Bill Vol. 1", "year": 2003}
movie2: MovieBase2 = details2  # E: Incompatible types in assignment (expression has type "MovieDetails", variable has type "MovieBase2")
if bool:
    details2 = movie2  # E: Incompatible types in assignment (expression has type "MovieBase2", variable has type "MovieDetails")

class MovieWithYear2(TypedDict, extra_items=int | None):
    name: str
    year: int | None

details3: MovieWithYear2 = {"name": "Kill Bill Vol. 1", "year": 2003}
movie3: MovieBase2 = details3  # E: Incompatible types in assignment (expression has type "MovieWithYear2", variable has type "MovieBase2")

# > When ``extra_items`` is specified to be read-only on a TypedDict type, it is
# > possible for an item to have a :term:`narrower <narrow>` type than the
# > ``extra_items`` argument.

class MovieSI(TypedDict, extra_items=ReadOnly[str | int]):
    name: str

class MovieDetails4(TypedDict, extra_items=int):
    name: str
    year: NotRequired[int]

class MovieDetails5(TypedDict, extra_items=int):
    name: str
    actors: list[str]

details4: MovieDetails4 = {"name": "Kill Bill Vol. 2", "year": 2004}
details5: MovieDetails5 = {"name": "Kill Bill Vol. 2", "actors": ["Uma Thurman"]}
movie4: MovieSI = details4  # OK. 'int' is assignable to 'str | int'.
movie5: MovieSI = details5  # E: Incompatible types in assignment (expression has type "MovieDetails5", variable has type "MovieSI")

[case typed_dict_extra_items_matching2]
# Copied from conformance tests (typeddicts_extra_items.py)
from typing_extensions import TypedDict, NotRequired, ReadOnly, Mapping, assert_type

# > ``extra_items`` as a pseudo-item follows the same rules that other items have,
# > so when both TypedDicts types specify ``extra_items``, this check is naturally
# > enforced.

class MovieExtraInt(TypedDict, extra_items=int):
    name: str

class MovieExtraStr(TypedDict, extra_items=str):
    name: str

extra_int: MovieExtraInt = {"name": "No Country for Old Men", "year": 2007}
extra_str: MovieExtraStr = {"name": "No Country for Old Men", "description": ""}
extra_int = extra_str  # E: Incompatible types in assignment (expression has type "MovieExtraStr", variable has type "MovieExtraInt")
extra_str = extra_int  # E: Incompatible types in assignment (expression has type "MovieExtraInt", variable has type "MovieExtraStr")

# > A non-closed TypedDict type implicitly allows non-required extra keys of value
# > type ``ReadOnly[object]``. Applying the assignability rules between this type
# > and a closed TypedDict type is allowed.

class MovieNotClosed(TypedDict):
    name: str

extra_int2: MovieExtraInt = {"name": "No Country for Old Men", "year": 2007}
not_closed: MovieNotClosed = {"name": "No Country for Old Men"}
extra_int2 = not_closed  # E: Incompatible types in assignment (expression has type "MovieNotClosed", variable has type "MovieExtraInt")
not_closed = extra_int2  # OK

# > TypedDicts that allow extra items of type ``T`` also allow arbitrary keyword
# > arguments of this type when constructed by calling the class object.

class NonClosedMovie(TypedDict):
    name: str

NonClosedMovie(name="No Country for Old Men")  # OK
NonClosedMovie(name="No Country for Old Men", year=2007)  # E: Extra key "year" for TypedDict "NonClosedMovie"

class ExtraMovie(TypedDict, extra_items=int):
    name: str

ExtraMovie(name="No Country for Old Men")  # OK
ExtraMovie(name="No Country for Old Men", year=2007)  # OK
ExtraMovie(name="No Country for Old Men", language="English")  # E: Incompatible types (expression has type "str", TypedDict item "language" has type "int")

# This implies 'extra_items=Never',
# so extra keyword arguments would produce an error
class ClosedMovie(TypedDict, closed=True):
    name: str

ClosedMovie(name="No Country for Old Men")  # OK
ClosedMovie(name="No Country for Old Men", year=2007)  # E: Incompatible types (expression has type "int", TypedDict item "year" has type "Never")

[case typed_dict_extra_items_assignable_to_mapping]
# Copied from conformance tests (typeddicts_extra_items.py)
from typing_extensions import TypedDict, NotRequired, ReadOnly, Mapping, assert_type

class MovieExtraInt(TypedDict, extra_items=int):
    name: str

class MovieExtraStr(TypedDict, extra_items=str):
    name: str

# > A TypedDict type is :term:`assignable` to a type of the form ``Mapping[str, VT]``
# > when all value types of the items in the TypedDict
# > are assignable to ``VT``.

extra_str3: MovieExtraStr = {"name": "Blade Runner", "summary": ""}
str_mapping: Mapping[str, str] = extra_str3  # OK

extra_int3: MovieExtraInt = {"name": "Blade Runner", "year": 1982}
int_mapping: Mapping[str, int] = extra_int3  # E: Incompatible types in assignment (expression has type "MovieExtraInt", variable has type "Mapping[str, int]")
int_str_mapping: Mapping[str, int | str] = extra_int3  # OK

# > Type checkers should infer the precise signatures of ``values()`` and ``items()``
# > on such TypedDict types.

def foo(movie: MovieExtraInt) -> None:
    assert_type(list(movie.items()), list[tuple[str, int | str]])
    assert_type(list(movie.values()), list[int | str])

[case typed_dict_extra_items_assignable_to_mutable_mapping]
from typing import TypedDict, NotRequired, MutableMapping, Mapping

class OnlyStr(TypedDict, extra_items=str):
    name: str
class OnlyStrNonRequired(TypedDict, extra_items=str):
    name: NotRequired[str]

def f(x: OnlyStr, y: OnlyStrNonRequired):
    a: MutableMapping[str, str] = x  # E: Incompatible types in assignment (expression has type "OnlyStr", variable has type "MutableMapping[str, str]")
    a = y
    b: Mapping[str, str] = x
    b = y
    c: dict[str, str] = x  # E: Incompatible types in assignment (expression has type "OnlyStr", variable has type "dict[str, str]")
    c = y

    d: dict[str, int] = y  # E: Incompatible types in assignment (expression has type "OnlyStrNonRequired", variable has type "dict[str, int]")
    e: Mapping[str, int] = y  # E: Incompatible types in assignment (expression has type "OnlyStrNonRequired", variable has type "Mapping[str, int]")
    f: MutableMapping[str, int] = y  # E: Incompatible types in assignment (expression has type "OnlyStrNonRequired", variable has type "MutableMapping[str, int]")

[case typed_dict_extra_items_methods]
# Copied from conformance tests (typeddicts_extra_items.py)
from typing_extensions import TypedDict, NotRequired, ReadOnly, Mapping, assert_type

# > The TypedDict type is :term:`assignable` to ``dict[str, VT]`` if all
# > items on the TypedDict type satisfy the following conditions:
# > - The value type of the item is :term:`consistent` with ``VT``.
# > - The item is not read-only.
# > - The item is not required.

class IntDict(TypedDict, extra_items=int):
    pass

class IntDictWithNum(IntDict):
    num: NotRequired[int]

def clear_intdict(x: IntDict) -> None:
    v: dict[str, int] = x  # OK
    v.clear()  # OK

not_required_num_dict: IntDictWithNum = {"num": 1, "bar": 2}
regular_dict: dict[str, int] = not_required_num_dict  # OK
clear_intdict(not_required_num_dict)  # OK

# > In this case, methods that are previously unavailable on a TypedDict are allowed,
# > with signatures matching ``dict[str, VT]``
# > (e.g.: ``__setitem__(self, key: str, value: VT) -> None``).

not_required_num_dict.clear()  # OK

assert_type(not_required_num_dict.popitem(), tuple[str, int])

def nrnd(not_required_num_dict: IntDictWithNum, key: str):
    not_required_num_dict[key] = 42  # OK
    del not_required_num_dict[key]  # OK

# > ``dict[str, VT]`` is not assignable to a TypedDict type,
# > because such dict can be a subtype of dict.

class CustomDict(dict[str, int]):
    pass

def might_not_be(might_not_be_a_builtin_dict: dict[str, int]):
    int_dict: IntDict = might_not_be_a_builtin_dict # E: Incompatible types in assignment (expression has type "dict[str, int]", variable has type "IntDict")
    print(int_dict)

not_a_builtin_dict = CustomDict({"num": 1})
might_not_be(not_a_builtin_dict)

[case typed_dict_extra_items_methods_against_strings]
from typing import TypedDict, NotRequired

class IntOnly(TypedDict, extra_items=int):
    other: NotRequired[int]

class CanBeEmpty(TypedDict, extra_items=int):
    other: NotRequired[str]

class CannotBeEmpty(TypedDict, extra_items=int):
    other: str

def f(e: CanBeEmpty, n: CannotBeEmpty, s: str, i: int, int_only: IntOnly):
    reveal_type(e[""])  # N: Revealed type is "int"
    e[i]  # E: TypedDict key must be a string literal; expected one of ("other")
    reveal_type(e.get(s))  # N: Revealed type is "str | int | None"
    reveal_type(e.get(s, b''))  # N: Revealed type is "str | int | Literal[b'']?"
    e.get(i)  # E: No overload variant of "get" of "Mapping" matches argument type "int" \
              # N: Possible overload variants: \
              # N:     def get(self, str, /) -> object \
              # N:     def get(self, str, /, default: object) -> object \
              # N:     def [_T] get(self, str, /, default: _T) -> object
    reveal_type(e.popitem())  # N: Revealed type is "tuple[str, str | int]"
    del e[s]
    e[s] = 1  # E: TypedDict key must be a string literal; expected one of ("other")
    e.clear()

    n[s]  # E: TypedDict key must be a string literal; expected one of ("other")
    n[i]  # E: TypedDict key must be a string literal; expected one of ("other")
    n.get(s)
    n.get(i)  # E: No overload variant of "get" of "Mapping" matches argument type "int" \
              # N: Possible overload variants: \
              # N:     def get(self, str, /) -> object \
              # N:     def get(self, str, /, default: object) -> object \
              # N:     def [_T] get(self, str, /, default: _T) -> object
    n.popitem()  # E: "CannotBeEmpty" has no attribute "popitem"
    del n[s]  # E: Expected TypedDict key to be string literal
    n[s] = 1  # E: TypedDict key must be a string literal; expected one of ("other")
    n.clear()  # E: "CannotBeEmpty" has no attribute "clear"

    int_only[s] = 1
    int_only[s] = ''  # E: For a TypedDict with only types "str", "int" is expected

[case typed_dict_wrong_args]
from typing import TypedDict
X = TypedDict("X", {'x': int}, total=True, foo=1)  # E: Unexpected keyword argument "foo" for "TypedDict"

class Y(TypedDict, total=True, foo=1):    # E: Unexpected keyword argument "foo" for "TypedDict"
    x: int

kwargs = dict(closed=True)

A = TypedDict("A", {'x': int}, total=True, **kwargs)  # E: Unexpected arguments to TypedDict()

class B(TypedDict, total=True, **kwargs):  # E: Unexpected arguments to TypedDict()  # E: Invalid base class "**kwargs"
    x: int

C = TypedDict("C", {'x': int}, 1)  # E: Unexpected arguments to TypedDict()

[case typed_dict_extra_items_formatting]
from typing import TypedDict, ReadOnly

class IntDict(TypedDict, extra_items=int):
    pass

class X(TypedDict, extra_items=int):
    x: str

class Y(TypedDict, extra_items=ReadOnly[int]):
    x: str

class C(TypedDict, closed=True):
    x: str

class D(TypedDict, closed=False):
    x: str

def f(x: X, y: Y, i: IntDict, c: C, d: D):
    reveal_type(x)  # N: Revealed type is "TypedDict('__main__.X', {'x': str}, extra_items=int)"
    reveal_type(y)  # N: Revealed type is "TypedDict('__main__.Y', {'x': str}, extra_items=ReadOnly[int])"
    reveal_type(c)  # N: Revealed type is "TypedDict('__main__.C', {'x': str}, closed=True)"
    reveal_type(d)  # N: Revealed type is "TypedDict('__main__.D', {'x': str})"
    reveal_type(i)  # N: Revealed type is "TypedDict('__main__.IntDict', {}, extra_items=int)"
    x = i  # E: Incompatible types in assignment (expression has type "IntDict", variable has type "X")

[case typed_dict_extra_items_assert_type]
from typing import TypedDict, assert_type, ReadOnly

class IntDict(TypedDict, extra_items=int):
    pass

class X(TypedDict, extra_items=int):
    x: str

class StrDict(TypedDict, extra_items=int):
    pass

class StrDict2(TypedDict, extra_items=int):
    pass

class StrDictReadOnly(TypedDict, extra_items=ReadOnly[int]):
    pass

def f(x: X, i: IntDict, s: StrDict, sr: StrDictReadOnly):
    assert_type(x, IntDict)  # E: Expression is of type "X", not "IntDict"
    assert_type(i, IntDict)
    assert_type(s, StrDict)
    assert_type(s, StrDict2)
    assert_type(s, StrDictReadOnly)  # E: Expression is of type "StrDict", not "StrDictReadOnly"
    assert_type(sr, StrDictReadOnly)

[case typed_dict_extra_items_as_callable]
from typing import TypedDict, Callable

class X(TypedDict, extra_items=int):
    x: str

def f[T, **P](x: Callable[P, T]) -> Callable[P, tuple[T, float]]: ...

reveal_type(f(X))  # N: Revealed type is "def (*, x: str, **int) -> tuple[TypedDict('__main__.X', {'x': str}, extra_items=int), float]"

[case typed_dict_extra_items_as_args]
from typing import TypedDict

class X(TypedDict, extra_items=int):
    x: str

def a() -> None: ...
def b(x: str) -> None: ...
def c(x: int, **kwargs: int) -> None: ...
def d(x: str, **kwargs: str) -> None: ...
def e(x: str, **kwargs: int) -> None: ...

def f(x: X):
    a(**x)  # E: Extra argument "x" from **args for "a"  # E: Too many arguments for "a"
    b(**x)
    c(**x)  # E: Argument "x" to "c" has incompatible type "str"; expected "int"
    d(**x)  # E: Argument 1 to "d" has incompatible type "**X"; expected "str"
    e(**x)
    e(**x, **x)  # TODO this should also raise an error, because a param is used twice

[case additional_extra_items_inheritance]
from typing import TypedDict, ReadOnly

class A: ...
class B(A): ...
class C(B): ...

class Base(TypedDict, extra_items=ReadOnly[B]): ...
class X(Base, extra_items=A): ...  # E: Cannot change "extra_items" type unless it is "ReadOnly" in the superclass
class Y(Base, extra_items=C): ...

[case typed_dict_extra_items_read_only_in_subclass_members]
from typing_extensions import TypedDict, NotRequired, ReadOnly

class Base(TypedDict, extra_items=int | str):
    ...

class Sub1(Base):
    x: NotRequired[int | str]
    y: NotRequired[int]  # E: TypedDict member "y" type "int" is not assignable, but the extra_items of the super class are of type "int | str"

class Sub2(Base):
    x: NotRequired[ReadOnly[int | str]]  # E: TypedDict member "x" is read only, but the extra_items of the super class are
    y: NotRequired[ReadOnly[int]]  # E: TypedDict member "y" is read only, but the extra_items of the super class are

[case typed_dict_invalid_set_default_no_crash]
# From GH Issue #62
from typing import TypedDict

class TD(TypedDict):
    s: str

d: TD = {}  # E: Missing key "s" for TypedDict "TD"
d.setdefault('s')  # E: Argument 2 to "setdefault" of "TypedDict" has incompatible type "None"; expected "str"
