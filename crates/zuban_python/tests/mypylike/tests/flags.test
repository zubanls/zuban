[case reveal_type_defined_in_untyped_func]
# flags: --no-check-untyped-defs
def reveal_type(a: str) -> None: ...
def foo():
    reveal_type(1)

[case union_alias_disallowed_any_expr_simple]
# flags: --disallow-any-explicit
from typing import Any, TypeAlias, Tuple

x1: TypeAlias = Any | int  # E: Explicit "Any" is not allowed
y1: TypeAlias = int | Any  # E: Explicit "Any" is not allowed

x2 = Any | int  # E: Explicit "Any" is not allowed
y2 = int | Any  # E: Explicit "Any" is not allowed

x: Tuple[x1, y1, x2, y2]

[case union_alias_disallowed_any_expr_nested]
# flags: --disallow-any-explicit
from typing import Any, TypeAlias, Tuple

x1: TypeAlias = list[Any] | int  # E: Explicit "Any" is not allowed
y1: TypeAlias = int | list[Any]  # E: Explicit "Any" is not allowed

x2 = list[Any] | int  # E: Explicit "Any" is not allowed
y2 = int | list[Any]  # E: Explicit "Any" is not allowed

x: Tuple[x1, y1, x2, y2]

[case redundant_casts_with_any_nested]
# flags: --warn-redundant-casts
from typing import cast, Any

x: list[int]
cast(list[int], x) # E: Redundant cast to "list[int]"
cast(list[Any], x)

[case unannotated_return_in_method_with_disallow_untyped_defs]
# flags: --disallow-untyped-defs
# Like testUnannotatedReturnWithOnlySelfArgument, but fixed with context
class Foo:
    def f(self): pass
[out]
__main__:4: error: Function is missing a return type annotation
__main__:4: note: Use "-> None" if function does not return a value

[case show_error_codes_in_mypy_config]
a: str = 3  # E: Incompatible types in assignment (expression has type "int", variable has type "str")  [assignment]
[file mypy.ini]
[mypy]
show_error_codes = True

[case show_error_codes_in_pyproject_toml]
a: str = 3  # E: Incompatible types in assignment (expression has type "int", variable has type "str")  [assignment]
[file pyproject.toml]
[tool.mypy]
show_error_codes = true

[case show_column_numbers_in_mypy_config]
a: str = 3
[file mypy.ini]
[mypy]
show_column_numbers = True
show_error_end = True
[out]
__main__:1:10:1:11: error: Incompatible types in assignment (expression has type "int", variable has type "str")

[case show_column_numbers_in_pyproject_toml]
a: str = 3
[file pyproject.toml]
[tool.mypy]
show_column_numbers = true
show_error_end = true
[out]
__main__:1:10:1:11: error: Incompatible types in assignment (expression has type "int", variable has type "str")

[case strict_allows_explicit_any]
# flags: --strict
from typing import Any
def foo(x: Any) -> None: ...

[case cast_arbitrary_len_tuple_to_fixed_len]
# flags: --warn-redundant-casts
from typing import cast
def foo(x: tuple[int, ...], y: tuple[int, int]) -> tuple[int, int]:
    if bool():
        return cast(tuple[int, int], y)  # E: Redundant cast to "tuple[int, int]"
    return cast(tuple[int, int], x)

[case type_of_none_overlaps_with_object]
# flags: --strict-equality
#x: object = type(None)
def foo(obj: object) -> None:
    if obj is type(None): ...
    if 1 is type(None): ...  # E: Non-overlapping identity check (left operand type: "int", right operand type: "Type[None]")

[case type_overlaps_with_type]
# flags: --strict-equality
from typing import Any

def foo(i: type[int], x: type[Any], y: type, z: type[object]) -> None:
    i == x
    x == i
    x == y
    y == x
    i == y
    y == i

    z == x
    x == z
    z == y
    y == z
    z == i
    i == z

    type == i  # E: Non-overlapping equality check (left operand type: "Type[type]", right operand type: "Type[int]")
    i == type  # E: Non-overlapping equality check (left operand type: "Type[int]", right operand type: "Type[type]")
    type == x
    x == type
    type == y
    y == type
    type == z
    z == type

    type == type(x)
    type(x) == type
    type == type(y)
    type(y) == type
    type == type(z)
    type(z) == type
    type == type(i)
    type(i) == type

[case redundant_cast_with_new_type]
# flags: --warn-redundant-casts
from typing import cast, NewType

A = NewType("A", int)

x = 1
y = cast(A, x)
cast(A, y) # E: Redundant cast to "A"

[case mapping_against_dict_with_strict_equality]
# flags: --strict-equality
from typing import Mapping

def foo(x: dict[int, str], y: Mapping[int, str]) -> None:
    if x == y: ...
    if y == x: ...

[case strict_equality_no_crash_with_recursive_types]
# flags: --strict-equality
from typing import MutableMapping, Union

U = MutableMapping[str, "U"] | None

def generate_arg(value: U):
    if isinstance(value, MutableMapping) and value.get("class") in ("File",):  # E: Non-overlapping container check (element type: "MutableMapping[str, U] | None", container item type: "Literal['File']")
        pass

[case files_in_mypy_ini]
[file a.py]
1()  # E: "int" not callable
[file b.py]
1()  # E: "int" not callable
[file c.py]
1()

[file mypy.ini]
[mypy]
files =
    a.py,
    b.py,

[case files_in_pyproject_toml]
[file a.py]
1()  # E: "int" not callable
[file b.py]
1()  # E: "int" not callable
[file c.py]
1()

[file pyproject.toml]
[tool.mypy]
files = [
    "a.py",
    "b.py",
]

[case files_path_in_mypy_config1]
[file a/a.py]
1()  # E: "int" not callable
[file b/a/b.py]
1()
[file c/a/c.py]
1()  # E: "int" not callable

[file mypy.ini]
[mypy]
files =
    a,
    a,
    c

[case files_path_in_mypy_config2]
[file a/a.py]
1()  # E: "int" not callable
[file b/a/b.py]
1()
[file c/a/c.py]
1()  # E: "int" not callable

[file mypy.ini]
[mypy]
files =
    a/**,
    a/**,
    c/**


[case files_path_wild_cards_in_mypy_config1]
[file a/x.py]
def f(x: int): ...  # E: Function is missing a return type annotation
[file a/b/y.py]
def f(x: int): ...
[file a/c/z.py]
def f(x: int): ...  # E: Function is missing a return type annotation

[file mypy.ini]
[mypy-a.*]
disallow_untyped_defs = True
[mypy-a.b.y]
disallow_untyped_defs = False

[case files_path_wild_cards_in_mypy_config2]
[file a/x.py]
def f(x: int): ...  # E: Function is missing a return type annotation
[file a/b/y.py]
def f(x: int): ...
[file a/c/z.py]
def f(x: int): ...  # E: Function is missing a return type annotation

[file mypy.ini]
[mypy-a.b.y]
disallow_untyped_defs = False
[mypy-a.*]
disallow_untyped_defs = True

[case files_path_wild_cards_in_mypy_config3]
[file a/x.py]
def f(x: int): ...  # E: Function is missing a return type annotation
[file a/b/y.py]
def f(x: int): ...
[file a/c/z.py]
def f(x: int): ...  # E: Function is missing a return type annotation

[file mypy.ini]
[mypy-a.*]
disallow_untyped_defs = True
[mypy-a.*.y]
disallow_untyped_defs = False

[case files_path_wild_cards_in_mypy_config4]
[file a/x.py]
def f(x: int): ...  # E: Function is missing a return type annotation
[file a/b/y.py]
def f(x: int): ...
[file a/c/z.py]
def f(x: int): ...  # E: Function is missing a return type annotation

[file mypy.ini]
[mypy-a.*.y]
disallow_untyped_defs = False
[mypy-a.*]
disallow_untyped_defs = True

[case files_path_wild_cards_in_mypy_config5]
[file a/x.py]
def f(x: int): ...  # E: Function is missing a return type annotation
[file a/b/y.py]
def f(x: int): ...
[file a/c/z.py]
def f(x: int): ...

[file mypy.ini]
[mypy-a.*.y]
disallow_untyped_defs = False
[mypy-a.*]
disallow_untyped_defs = True
[mypy-a.c.z]
disallow_untyped_defs = False

[case multi_files_path_in_overrides]
[file a/x.py]
def f(x: int): ...
[file a/y.py]
def f(x: int): ...
[file a/z.py]
def f(x: int): ...  # E: Function is missing a return type annotation

[file mypy.ini]
[mypy]
disallow_untyped_defs = True
[mypy-a.x,a.y]
disallow_untyped_defs = False

[case error_code_for_invalid_unpack_and_iter]
# flags: --show-error-codes

def foo(*x) -> None: ...

def f(x: tuple[int, str] | None, y: tuple[int, str] | int):
    a, b = x  # E: "None" object is not iterable  [misc]
    a, b = y  # E: "int" object is not iterable  [misc]
    c, d = 1  # E: "int" object is not iterable  [misc]
    c, d = None  # E: "None" object is not iterable  [misc]

    [n for n in x]  # E: Item "None" of "tuple[int, str] | None" has no attribute "__iter__" (not iterable)  [union-attr]
    [n for n in y]  # E: Item "int" of "tuple[int, str] | int" has no attribute "__iter__" (not iterable)  [union-attr]
    [n for n in 1]  # E: "int" has no attribute "__iter__" (not iterable)  [attr-defined]
    [n for n in None]  # E: "None" has no attribute "__iter__" (not iterable)  [attr-defined]

    foo(*1)  # E: Expected iterable as variadic argument  [misc]
    foo(*x)  # E: Expected iterable as variadic argument  [misc]
    foo(*y)  # E: Expected iterable as variadic argument  [misc]

    [*1]  # E: Expected iterable as variadic argument  [misc]
    [*x]  # E: Expected iterable as variadic argument  [misc]
    [*y]  # E: Expected iterable as variadic argument  [misc]

    # TODO these errors shouldn't be duplicated
    (*1, )  # E: Expected iterable as variadic argument  [misc]  # E: Expected iterable as variadic argument  [misc]
    (*x, )  # E: Expected iterable as variadic argument  [misc]  # E: Expected iterable as variadic argument  [misc]
    (*y, )  # E: Expected iterable as variadic argument  [misc]  # E: Expected iterable as variadic argument  [misc]

[case untyped_override_check_untyped_defs_no_mypy_compatible]
# flags: --check-untyped-defs --no-mypy-compatible
import m

[file m.py]
from typing import Any

class C():
    @staticmethod
    def f(s, *x: Any) -> Any: ...
    def g(self, *x: Any) -> Any: ...

class D(C):
    @staticmethod
    def f(s, grad_output, *, foo): ...  # E: Signature of "f" incompatible with supertype "C" \
                                        # N:      Superclass: \
                                        # N:          @staticmethod \
                                        # N:          def f(s: Any, *x: Any) -> Any \
                                        # N:      Subclass: \
                                        # N:          @staticmethod \
                                        # N:          def [T1: Any, T2: Any, T3: Any] f(s: T1, grad_output: T2, *, foo: T3) -> None

    def g(self, grad_output, *, foo): ...  # E: Signature of "g" incompatible with supertype "C" \
                                           # N:      Superclass: \
                                           # N:          def g(self, *x: Any) -> Any \
                                           # N:      Subclass: \
                                           # N:          def [T2: Any, T3: Any] g(self, grad_output: T2, *, foo: T3) -> None

[case untyped_override_check_untyped_defs_mypy_compatible]
# flags: --check-untyped-defs --mypy-compatible
import m

[file m.py]
from typing import Any

class C():
    @staticmethod
    def f(s, *x: Any) -> Any: ...
    def g(self, *x: Any) -> Any: ...

class D(C):
    @staticmethod
    def f(s, grad_output, *, foo): ...
    def g(self, grad_output, *, foo): ...  # E: Signature of "g" incompatible with supertype "C" \
                                           # N:      Superclass: \
                                           # N:          def g(self, *x: Any) -> Any \
                                           # N:      Subclass: \
                                           # N:          def g(self, grad_output: Any, *, foo: Any) -> Any

[case mypy_comment_flag_change_after_docstring]
# flags: --disallow-untyped-defs

[file m.py]
def f(x): ...  # E: Function is missing a type annotation
[file n.py]
"hi"
# mypy: allow-untyped-defs
def f(x): ...
[file l.py]
"""
hi
"""

# mypy: allow-untyped-defs
def f(x): ...

[case strict_init_no_return_annotation_needed]
# flags: --strict
class C:
    def __init__(self): ...  # E: Function is missing a return type annotation \
                             # N: Use "-> None" if function does not return a value

class D:
    def __init__(self, x: int): ...

class E:
    def __init__(self, x): ...  # E: Function is missing a type annotation for one or more arguments

[case allow_untyped_globals_default_mypy_compatible]
# flags: --mypy-compatible
x = []  # E: Need type annotation for "x" (hint: "x: List[<type>] = ...")

[case allow_untyped_globals_default_no_mypy_compatible]
# flags: --no-mypy-compatible
x = []

[case local_partial_types_default_mypy_compatible]
# flags: --mypy-compatible --disallow-untyped-globals
x = []
def foo() -> None:
    x.append(1)
    reveal_type(x)  # N: Revealed type is "list[int]"

[case local_partial_types_default_no_mypy_compatible]
# flags: --no-mypy-compatible --disallow-untyped-globals
x = []  # E: Need type annotation for "x" (hint: "x: List[<type>] = ...")
def foo() -> None:
    x.append(1)
    reveal_type(x)  # N: Revealed type is "list[Any]"

[case no_mypy_compatible_disallows_untyped_globals]
# flags: --no-mypy-compatible --strict
x = []  # E: Need type annotation for "x" (hint: "x: List[<type>] = ...")
def foo() -> None:
    x.append(1)
    reveal_type(x)  # N: Revealed type is "list[Any]"

[case gradual_none1]
# flags: --allow-untyped-globals --local-partial-types
class MyClass:
    attr = None

foo = MyClass()

reveal_type(foo.attr)  # N: Revealed type is "Any | None"

foo.attr = 1

[case gradual_none2]
# flags: --allow-untyped-globals --local-partial-types
import m
reveal_type(m.foo.attr)  # N: Revealed type is "Any | None"

[file m.py]
class MyClass:
    attr = None

foo = MyClass()

reveal_type(foo.attr)  # N: Revealed type is "Any | None"

foo.attr = 1

[case gradual_none3]
# flags: --allow-untyped-globals --local-partial-types
import m
reveal_type(m.foo.attr)  # N: Revealed type is "Any | None"

[file m.py]
class MyClass:
    attr = None
    attr = None

foo = MyClass()

reveal_type(foo.attr)  # N: Revealed type is "Any | None"

foo.attr = 1

[case local_partial_in_function1]
# flags: --local-partial-types --disallow-untyped-globals
def f() -> None:
    a = []  # E: Need type annotation for "a" (hint: "a: List[<type>] = ...")

a = []
a.append(1)

[case local_partial_in_function2]
# flags: --local-partial-types --disallow-untyped-globals
a = []
def f() -> None:
    a = []  # E: Need type annotation for "a" (hint: "a: List[<type>] = ...")

a.append(1)

[case list_inference_mypy_no_compatible]
# flags: --no-mypy-compatible
x = [1, ""]
reveal_type(x[0])  # N: Revealed type is "int | str"

[case check_untyped_defs_no_mypy_compatible]
# flags: --no-mypy-compatible
def f():
    1()  # E: "int" not callable

[case set_inference_mypy_no_compatible]
# flags: --no-mypy-compatible
x = {1, ""}
reveal_type(next(iter(x)))  # N: Revealed type is "int | str"

[case dict_inference_mypy_no_compatible]
# flags: --no-mypy-compatible
x = {1: 1.0, "": b''}
reveal_type(x)  # N: Revealed type is "dict[int | str, float | bytes]"
reveal_type(x[0])  # N: Revealed type is "float | bytes"
reveal_type(x[""])  # N: Revealed type is "float | bytes"
x[b'']  # E: Invalid index type "bytes" for "dict[int | str, float | bytes]"; expected type "int | str"

y = {1: 1.0, **{"": b''}}
reveal_type(y)  # N: Revealed type is "dict[int | str, float | bytes]"
reveal_type(y[0])  # N: Revealed type is "float | bytes"
reveal_type(y[""])  # N: Revealed type is "float | bytes"
y[b'']  # E: Invalid index type "bytes" for "dict[int | str, float | bytes]"; expected type "int | str"

[case dict_inference_no_mypy_compatible_too_big]
# flags: --no-mypy-compatible
x = {
    "a01": "b01",
    "a02": "b02",
    "a03": "b03",
    "a04": "b04",
    "a05": "b05",
    "a06": "b06",
    "a07": "b07",
    "a08": "b08",
    "a09": "b09",
    "a10": "b10",
    "a11": "b11",
    "a12": "b12",
    "a13": "b13",
    "a14": "b14",
    "a15": "b15",
    "a16": "b16",
    "a17": "b17",
    "a18": "b18",
    "a19": "b19",
    "a20": "b20",
    "a21": "b21",
    "a22": "b22",
    "a23": "b23",
    "a24": "b24",
    "a25": "b25",
    "a26": "b26",
    "a27": "b27",
    "a28": "b28",
    "a29": "b29",
    "a30": "b30",
    "a31": "b31",
    "a32": "b32",
    "a33": "b33",
    "a34": "b34",
    "a35": "b35",
    "a36": "b36",
    "a37": "b37",
    "a38": "b38",
    "a39": "b39",
    "a30": "b30",
    "a31": "b31",
    "a32": "b32",
    "a33": "b33",
    "a34": "b34",
    "a35": "b35",
    "a36": "b36",
    "a37": "b37",
    "a38": "b38",
    "a39": "b39",
    "a40": "b40",
    "a41": "b41",
    "a42": "b42",
    "a43": "b43",
    "a44": "b44",
    "a45": "b45",
    "a46": "b46",
    "a47": "b47",
    "a48": "b48",
    "a49": "b49",
    "a50": "b50",
    "a51": "b51",
    "a52": "b52",
    "a53": "b53",
    "a54": "b54",
    "a55": "b55",
    "a56": "b56",
    "a57": "b57",
    "a58": "b58",
    "a59": "b59",
    "a60": "b60",
    "a61": "b61",
    "a62": "b62",
    "a63": "b63",
    "a64": "b64",
    "a65": "b65",
    "a66": "b66",
    "a67": "b67",
    "a68": "b68",
    "a69": "b69",
}
reveal_type(x)  # N: Revealed type is "dict[str, str]"

[case pretty_simple_flag]
# flags: --pretty
a = 1

b: str = a
# a
# b
# c

[out]
__main__:4: error: Incompatible types in assignment (expression has type "int", variable has type "str")
  |
1 | a = 1
2 | 
3 | b: str = a
4 | # a
5 | # b

[case pretty_simple_from_config]
def x(
    y: str = 1
): ...

[file pyproject.toml]
[tool.zuban]
pretty = true

[out]
__main__:2: error: Incompatible default for argument "y" (default has type "int", argument has type "str")
  |
0 | def x(
1 |     y: str = 1
2 | ): ...
3 |

[case pretty_overload_issue_multiline]
# flags: --pretty
from typing import overload

@overload
def f(x: str) -> str: ...
@overload
def f(x: int) -> int: ...
def f(x: int | str) -> int | str: ...

f(
  1,
  2
)
# a
# b
# c
[out]
__main__:10: error: No overload variant of "f" matches argument types "int", "int"
__main__:10: note: Possible overload variants:
__main__:10: note:     def f(x: str) -> str
__main__:10: note:     def f(x: int) -> int
   |
 7 | def f(x: int | str) -> int | str: ...
 8 | 
 9 | f(
10 |   1,
11 |   2
12 | )
13 | # a
14 | # b
