[case inlay_hints_basic_mypy_compatible]
# flags: --only-language-server --mypy-compatible
#? inlay-hints

def ret_int():
    return 0

constant = 1
a = constant
a = constant

# Constant assignments have no inlay hints
b = 1

[out]
__main__.py:3: Inlay Hints:
- 8:1: ": int"

[case inlay_hints_basic_no_mypy_compatible]
# flags: --only-language-server --no-mypy-compatible
#? inlay-hints

def ret_int():
    return 0

constant = 1
a = constant
a = constant

# Constant assignments have no inlay hints
b = 1

[out]
__main__.py:3: Inlay Hints:
- 4:13: " -> int"
- 8:1: ": int"

[case inlay_hints_with_range]
constant = 1
a = constant
#? inlay-hints --until-line 5

b = constant
c = constant

[out]
__main__.py:4: Inlay Hints:
- 5:1: ": int"

[case inlay_hints_avoid_generics]
# flags: --no-mypy-compatible
#? inlay-hints

def foo(x):
    return [x]

class C[T]:
    def __init__(self, x: T):
        self.x = x

    def bar(self, x):
        return (self.x, [x])

[out]
__main__.py:3: Inlay Hints:
- 4:10: " -> list[Any]"
- 9:14: ": T"
- 11:20: " -> tuple[T, list[Any]]"

[case inlay_hints_tuples]
#? inlay-hints

constant = 1
a = (1, 2, 3)
b = (1, 2, constant)
c = 1, 2, 3
d = 1, 2, constant

e, f = constant, constant
[out]
__main__.py:2: Inlay Hints:
- 5:1: ": tuple[int, int, int]"
- 7:1: ": tuple[int, int, int]"

[case inlay_hints_with_enums]
#? inlay-hints
from typing import Literal
import m
from enum import Enum
constant: Literal[1] = 1
class E(Enum):
    X = 1
    Y = constant

a = E.X
b = m.E.X

def f(e: E) -> None:
    a = e

[file m.py]
from enum import Enum
class E(Enum):
    X = 1

[out]
__main__.py:2: Inlay Hints:
- 8:5: ": Literal[1]"
- 14:5: ": E"

[case inlay_hints_with_classes]
# flags: --only-language-server
#? inlay-hints
from m import A, D, N1, N2, E1, E2, TD1, TD2

a = A()
i = int()
b = str()
d = D(1)
n1 = N1(1, 2)
n2 = N2(1)
e1 = E1("x")
e2 = E2("x")
td1 = TD1(x=1)
td2 = TD2(x=1)

[file indirect_import.py]
#? inlay-hints
import m

a = m.A()
d = m.D(1)
n1 = m.N1(1, 2)
n2 = m.N2(1)
e1 = m.E1("x")
e2 = m.E2("x")
td1 = m.TD1(x=1)
td2 = m.TD2(x=1)

[file m.py]
#? inlay-hints
from dataclasses import dataclass
from enum import Enum
from typing import NamedTuple, TypedDict

class A: pass
@dataclass
class D:
    x: int
N1 = NamedTuple("N1", [('x', int), ('y', int)])
class N2(NamedTuple):
    x: int
E1 = Enum("E1", ['x', 'y'])
class E2(Enum):
    x = "x"
TD1 = TypedDict("TD1", {"x": int})
class TD2(TypedDict):
    x: int

a = A()
i = int()
b = str()
d = D(1)
n1 = N1(1, 2)
n2 = N2(1)
e1 = E1("x")
e2 = E2("x")
td1 = TD1(x=1)
td2 = TD2(x=1)

[out]
__main__.py:3: Inlay Hints:
m.py:2: Inlay Hints:
indirect_import.py:2: Inlay Hints:
