[case name_used_before_definitions_in_match]
something # E: Name "something" is used before definition

x: int | str = ""

match x:
    case int():
        pass
    case something:
        pass

[case match_closed_typed_dict]
from typing import TypedDict

class TD(TypedDict, closed=True):
    x: int
    y: str

def f(td: TD): 
    match td:
        case { "x": 1, "y": y }:
            reveal_type(y)  # N: Revealed type is "str"
        case { "x": x }:
            reveal_type(x)  # N: Revealed type is "int"

    match td:
        case { "x": 1, "y": y }: pass
        case { **rest }:
            reveal_type(rest)  # N: Revealed type is "dict[str, int | str]"

[case match_extra_items_typed_dict]
from typing import TypedDict

class TD(TypedDict, extra_items=bytes):
    x: int
    y: str

def f(td: TD): 
    match td:
        case { "x": 1, "y": y }:
            reveal_type(y)  # N: Revealed type is "str"
        case { "x": x }:
            reveal_type(x)  # N: Revealed type is "int"

    match td:
        case { "x": 1, "y": y }: pass
        case { **rest }:
            reveal_type(rest)  # N: Revealed type is "dict[str, int | str | bytes]"

[case match_non_mapping_as_mapping]
match 1:
    case { "x": x }:
        reveal_type(x)  # N: Revealed type is "object"

[case multi_assign_pattern]
# flags: --no-mypy-compatible
# Like testMatchCapturePatternMultipleCases but for non-mypy compatibility
m: object

match m:
    case int(x):
        reveal_type(x)  # N: Revealed type is "int"
    case str(x):
        reveal_type(x)  # N: Revealed type is "str"

reveal_type(x)  # N: Revealed type is "int | str"
