[case name_used_before_definitions_in_match]
something # E: Name "something" is used before definition

x: int | str = ""

match x:
    case int():
        pass
    case something:
        pass

[case match_closed_typed_dict]
from typing import TypedDict

class TD(TypedDict, closed=True):
    x: int
    y: str

def f(td: TD): 
    match td:
        case { "x": 1, "y": y }:
            reveal_type(y)  # N: Revealed type is "str"
        case { "x": x }:
            reveal_type(x)  # N: Revealed type is "int"

    match td:
        case { "x": 1, "y": y }: pass
        case { **rest }:
            reveal_type(rest)  # N: Revealed type is "dict[str, int | str]"

[case match_extra_items_typed_dict]
from typing import TypedDict

class TD(TypedDict, extra_items=bytes):
    x: int
    y: str

def f(td: TD): 
    match td:
        case { "x": 1, "y": y }:
            reveal_type(y)  # N: Revealed type is "str"
        case { "x": x }:
            reveal_type(x)  # N: Revealed type is "int"

    match td:
        case { "x": 1, "y": y }: pass
        case { **rest }:
            reveal_type(rest)  # N: Revealed type is "dict[str, int | str | bytes]"

[case match_non_mapping_as_mapping]
match 1:
    case { "x": x }:
        reveal_type(x)  # N: Revealed type is "object"

[case multi_assign_pattern]
# flags: --no-mypy-compatible
# Like testMatchCapturePatternMultipleCases but for non-mypy compatibility
m: object

match m:
    case int(x):
        reveal_type(x)  # N: Revealed type is "int"
    case str(x):
        reveal_type(x)  # N: Revealed type is "str"

reveal_type(x)  # N: Revealed type is "int | str"

[case match_narrow_captured_variable_with_guard1]
# Copied partially from testMatchSubjectAssignExprWithGuard
from typing import Optional
def func() -> Optional[str]: ...

match func():
    case _ as m if not m:
        reveal_type(m)  # N: Revealed type is "Union[Literal[''], None]"
    case m:
        reveal_type(m)  # N: Revealed type is "str"

match func():
    case m if not m:
        reveal_type(m)  # N: Revealed type is "Union[Literal[''], None]"
    case m:
        reveal_type(m)  # N: Revealed type is "str"

[case match_narrow_captured_variable_with_guard2]
from typing import Optional
def func() -> Optional[str]: ...

var = func()
match var:
    case _ as m if not m:
        reveal_type(m)  # N: Revealed type is "Union[Literal[''], None]"
        reveal_type(var)  # N: Revealed type is "Union[Literal[''], None]"
    case m:
        reveal_type(m)  # N: Revealed type is "str"
        reveal_type(var)  # N: Revealed type is "str"

match var:
    case m if not m:
        reveal_type(m)  # N: Revealed type is "Union[Literal[''], None]"
        reveal_type(var)  # N: Revealed type is "Union[Literal[''], None]"
    case m:
        reveal_type(m)  # N: Revealed type is "str"
        reveal_type(var)  # N: Revealed type is "str"

[case match_literal_as_int]
# flags: --warn-unreachable
match 0:
    case int(i):
        reveal_type(i)  # N: Revealed type is "Literal[0]?"
    case other:
        other  # E: Statement is unreachable

[case match_classes_with_wrong_attr]
class A: ...

def f(m: object):
    match m:
        case A(a=j):  # E: Class "__main__.A" has no attribute "a"
            reveal_type(m)  # N: Revealed type is "__main__.A"
            reveal_type(j)  # N: Revealed type is "Any"
            m.a  # E: "A" has no attribute "a"

        case A(b=j, c=k):  # E: Class "__main__.A" has no attribute "b"  # E: Class "__main__.A" has no attribute "c"
            reveal_type(m)  # N: Revealed type is "__main__.A"
            reveal_type(j)  # N: Revealed type is "Any"
            m.a  # E: "A" has no attribute "a"

[case match_classes_nested_exhaustive]
from typing import assert_never

class A:
    x: str
class B:
    x: int

def f(m: A | B):
    match m:
        case object(x=int(i)):
            reveal_type(i)  # N: Revealed type is "int"
            reveal_type(m)  # N: Revealed type is "__main__.B"

        case object(x=str(i)):
            reveal_type(i)  # N: Revealed type is "str"
            reveal_type(m)  # N: Revealed type is "__main__.A"

        case rest: assert_never(rest)
    reveal_type(m)  # N: Revealed type is "__main__.A | __main__.B"
    reveal_type(i)  # N: Revealed type is "int | str"

[case match_reachability_with_returns]
# flags: --warn-unreachable
def f(x: str | int | bytes):
    if bool():
        match x:
            case int(): return
            case bytes(): return
        reveal_type(x)  # N: Revealed type is "str"

    if bool():
        match x:
            case int(): pass
            case bytes(): return
        reveal_type(x)  # N: Revealed type is "int | str"

    if bool():
        match x:
            case str(): pass
            case int(): pass
            case bytes(): return
        reveal_type(x)  # N: Revealed type is "str | int"

    if bool():
        match x:
            case bytes(): return
            case str(): pass
            case int(): pass
        reveal_type(x)  # N: Revealed type is "str | int"


    if bool():
        match x:
            case str(): pass
            case bytes(): return
            case int(): pass
        reveal_type(x)  # N: Revealed type is "str | int"

    if bool():
        if isinstance(x, str): ...
        elif isinstance(x, int): ...
        else: return
        reveal_type(x)  # N: Revealed type is "str | int"

    if bool():
        if isinstance(x, str): ...
        elif isinstance(x, bytes): return
        elif isinstance(x, int): ...
        reveal_type(x)  # N: Revealed type is "str | int"

[case match_classes_with_guards_should_not_narrow_rest]
from typing import assert_never

def f() -> int | str: return 1

match f():
    case str(s) if s == "foo":
        reveal_type(s)  # N: Revealed type is "str"
    case rest:
        reveal_type(rest)  # N: Revealed type is "int | str"

x = f()
match x:
    case str(s) if s == "foo":
        reveal_type(s)  # N: Revealed type is "str"
    case rest:
        reveal_type(rest)  # N: Revealed type is "int | str"

[case match_float_literal]
def f(x: float | str):
    match x:
        case 1.0:
            reveal_type(x)  # N: Revealed type is "float"
        case rest:
            reveal_type(rest)  # N: Revealed type is "float | str"
            reveal_type(x)  # N: Revealed type is "float | str"

[case match_typed_dict_reachability]
# flags: --no-mypy-compatible
# Copied from testMatchMappingPatternCapturesTypedDict, adapted for non-mypy compatibility
from typing import TypedDict

class A(TypedDict):
    a: str
    b: int

class B(TypedDict, total=False):
    a: str
    b: int

def f(m: A, n: B):
    match m:
        case {"a": v0, "x": _}:
            reveal_type(v0)  # N: Revealed type is "str"
        case {"a": v1}:
            reveal_type(v1)  # N: Revealed type is "str"
        case {"b": v2}:
            reveal_type(v2)  # E: Statement is unreachable

    match n:
        case {"a": v3, "x": _}:
            reveal_type(v3)  # N: Revealed type is "str"
        case {"a": v4}:
            reveal_type(v4)  # N: Revealed type is "str"
        case {"b": v5}:
            reveal_type(v5)  # N: Revealed type is "int"

[case match_subject_keys_tuples_with_parentheses]
# Copied from testMatchSequencePatternNarrowSubjectItems, but with a tuple that has parens around
def f(m: int, n: str, o: bool):
    match (m, n, o):
        case [3, "foo", True]:
            reveal_type(m)  # N: Revealed type is "Literal[3]"
            reveal_type(n)  # N: Revealed type is "Literal['foo']"
            reveal_type(o)  # N: Revealed type is "Literal[True]"
        case [a, b, c]:
            reveal_type(m)  # N: Revealed type is "int"
            reveal_type(n)  # N: Revealed type is "str"
            reveal_type(o)  # N: Revealed type is "bool"

def f2(m: int, n: str, o: bool):
    match (((m, n, o))):
        case [3, "foo", True]:
            reveal_type(m)  # N: Revealed type is "Literal[3]"
            reveal_type(n)  # N: Revealed type is "Literal['foo']"
            reveal_type(o)  # N: Revealed type is "Literal[True]"
        case [a, b, c]:
            reveal_type(m)  # N: Revealed type is "int"
            reveal_type(n)  # N: Revealed type is "str"
            reveal_type(o)  # N: Revealed type is "bool"

[case match_tuple_input_two_stars]
match (int(), str(), bytes()):
    case [a, *foo, *bar, b]:  # E: Two starred expressions in assignment
        reveal_type(a)  # N: Revealed type is "Any"
        reveal_type(b)  # N: Revealed type is "Any"
    case [a, *foo, b, *bar]:  # E: Two starred expressions in assignment
        reveal_type(a)  # N: Revealed type is "Any"
        reveal_type(b)  # N: Revealed type is "Any"
    case [a, b, c]:
        reveal_type(a)  # N: Revealed type is "int"
        reveal_type(b)  # N: Revealed type is "str"
        reveal_type(c)  # N: Revealed type is "bytes"

[case match_args_invalid]
class Foo:
    __match_args__ = "a"  # N: __match_args__ must be a tuple containing string literals for checking of match statements to work
    a: int

x = Foo()
match x:
    case Foo(1): reveal_type(x)  # N: Revealed type is "__main__.Foo"
    case _: reveal_type(x)  # N: Revealed type is "__main__.Foo"

[case match_simple_self_enum]
from enum import Enum

class Repository(Enum):
    Core = 'core'

    def get_repository_list(self) -> list[str]:
        match self:
            case Repository.Core:
                return [Repository.Core.value]
