[case name_used_before_definitions_in_match]
something # E: Name "something" is used before definition

x: int | str = ""

match x:
    case int():
        pass
    case something:
        pass

[case match_closed_typed_dict]
from typing import TypedDict

class TD(TypedDict, closed=True):
    x: int
    y: str

def f(td: TD): 
    match td:
        case { "x": 1, "y": y }:
            reveal_type(y)  # N: Revealed type is "str"
        case { "x": x }:
            reveal_type(x)  # N: Revealed type is "int"

    match td:
        case { "x": 1, "y": y }: pass
        case { **rest }:
            reveal_type(rest)  # N: Revealed type is "dict[str, int | str]"

[case match_extra_items_typed_dict]
from typing import TypedDict

class TD(TypedDict, extra_items=bytes):
    x: int
    y: str

def f(td: TD): 
    match td:
        case { "x": 1, "y": y }:
            reveal_type(y)  # N: Revealed type is "str"
        case { "x": x }:
            reveal_type(x)  # N: Revealed type is "int"

    match td:
        case { "x": 1, "y": y }: pass
        case { **rest }:
            reveal_type(rest)  # N: Revealed type is "dict[str, int | str | bytes]"

[case match_non_mapping_as_mapping]
match 1:
    case { "x": x }:
        reveal_type(x)  # N: Revealed type is "object"

[case multi_assign_pattern]
# flags: --no-mypy-compatible
# Like testMatchCapturePatternMultipleCases but for non-mypy compatibility
m: object

match m:
    case int(x):
        reveal_type(x)  # N: Revealed type is "int"
    case str(x):
        reveal_type(x)  # N: Revealed type is "str"

reveal_type(x)  # N: Revealed type is "int | str"

[case match_narrow_captured_variable_with_guard1]
# Copied partially from testMatchSubjectAssignExprWithGuard
from typing import Optional
def func() -> Optional[str]: ...

match func():
    case _ as m if not m:
        reveal_type(m)  # N: Revealed type is "Union[Literal[''], None]"
    case m:
        reveal_type(m)  # N: Revealed type is "str"

match func():
    case m if not m:
        reveal_type(m)  # N: Revealed type is "Union[Literal[''], None]"
    case m:
        reveal_type(m)  # N: Revealed type is "str"

[case match_narrow_captured_variable_with_guard2]
from typing import Optional
def func() -> Optional[str]: ...

var = func()
match var:
    case _ as m if not m:
        reveal_type(m)  # N: Revealed type is "Union[Literal[''], None]"
        reveal_type(var)  # N: Revealed type is "Union[Literal[''], None]"
    case m:
        reveal_type(m)  # N: Revealed type is "str"
        reveal_type(var)  # N: Revealed type is "str"

match var:
    case m if not m:
        reveal_type(m)  # N: Revealed type is "Union[Literal[''], None]"
        reveal_type(var)  # N: Revealed type is "Union[Literal[''], None]"
    case m:
        reveal_type(m)  # N: Revealed type is "str"
        reveal_type(var)  # N: Revealed type is "str"

[case match_literal_as_int]
# flags: --warn-unreachable
match 0:
    case int(i):
        reveal_type(i)  # N: Revealed type is "Literal[0]?"
    case other:
        other  # E: Statement is unreachable

[case match_classes_with_wrong_attr]
class A: ...

def f(m: object):
    match m:
        case A(a=j):  # E: Class "__main__.A" has no attribute "a"
            reveal_type(m)  # N: Revealed type is "__main__.A"
            reveal_type(j)  # N: Revealed type is "Any"
            m.a  # E: "A" has no attribute "a"

        case A(b=j, c=k):  # E: Class "__main__.A" has no attribute "b"  # E: Class "__main__.A" has no attribute "c"
            reveal_type(m)  # N: Revealed type is "__main__.A"
            reveal_type(j)  # N: Revealed type is "Any"
            m.a  # E: "A" has no attribute "a"

[case match_classes_nested_exhaustive]
from typing import assert_never

class A:
    x: str
class B:
    x: int

def f(m: A | B):
    match m:
        case object(x=int(i)):
            reveal_type(i)  # N: Revealed type is "int"
            reveal_type(m)  # N: Revealed type is "__main__.B"

        case object(x=str(i)):
            reveal_type(i)  # N: Revealed type is "str"
            reveal_type(m)  # N: Revealed type is "__main__.A"

        case rest: assert_never(rest)
    reveal_type(m)  # N: Revealed type is "__main__.A | __main__.B"
    reveal_type(i)  # N: Revealed type is "int | str"
