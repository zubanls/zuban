[case recursive_alias_union_simplifying_with_generics]
# flags: --mode mypy --disable-error-code=used-before-def
from typing import TypeVar, Union, Sequence

S = TypeVar("S")
T = TypeVar("T")

def unite(s: S, t: T) -> S | T: ...

Rec1 = Sequence[Union[Rec1[T], int]]
Rec2 = Sequence[Union[Rec2[T], int, str]]
Rec3 = Sequence[Union[Rec3[T], float]]

i1: Rec1[int]
i2: Rec2[int]
i3: Rec3[int]

s1: Rec1[str]

reveal_type(unite(i1, i1))  # N: Revealed type is "typing.Sequence[... | int]"
reveal_type(unite(i1, i2))  # N: Revealed type is "typing.Sequence[... | int] | typing.Sequence[... | int | str]"
reveal_type(unite(i2, i1))  # N: Revealed type is "typing.Sequence[... | int | str] | typing.Sequence[... | int]"
reveal_type(unite(i1, i3))  # N: Revealed type is "typing.Sequence[... | int] | typing.Sequence[... | float]"
reveal_type(unite(i3, i1))  # N: Revealed type is "typing.Sequence[... | float] | typing.Sequence[... | int]"

u1 = unite(i1, s1)
u2 = unite(s1, i1)
x: str = u1  # E: Incompatible types in assignment (expression has type "Rec1[int] | Rec1[str]", variable has type "str") 
y: str = u2  # E: Incompatible types in assignment (expression has type "Rec1[str] | Rec1[int]", variable has type "str") 
reveal_type(u1)  # N: Revealed type is "typing.Sequence[... | int] | typing.Sequence[... | int]"
reveal_type(u2)  # N: Revealed type is "typing.Sequence[... | int] | typing.Sequence[... | int]"

[case recursive_alias_incorrect_generics_no_restrictions]
# flags: --mode mypy --disable-error-code=used-before-def
from typing import TypeVar, Union

S = TypeVar("S")
T = TypeVar("T")

Rec = list[Union[Rec[T, S], T, S]]

x1: Rec[int, float]
x2: Rec[str, int]
reveal_type(x1)  # N: Revealed type is "list[... | int | float]"
reveal_type(x1[0])  # N: Revealed type is "list[... | int | float] | int | float"
reveal_type(x2)  # N: Revealed type is "list[... | str | int]"
reveal_type(x2[0])  # N: Revealed type is "list[... | str | int] | str | int"

x3: Rec[str]  # E: Bad number of arguments for type alias, expected 2, given 1
x4: Rec[str, int, float]  # E: Bad number of arguments for type alias, expected 2, given 3
reveal_type(x3)  # N: Revealed type is "list[... | Any]"
reveal_type(x3[0])  # N: Revealed type is "list[... | Any] | Any"
reveal_type(x4)  # N: Revealed type is "list[... | Any]"
reveal_type(x4[0])  # N: Revealed type is "list[... | Any] | Any"

[case recursive_alias_incorrect_generics_inside_no_restrictions]
# flags: --mode mypy --disable-error-code=used-before-def
from typing import TypeVar, Union

S = TypeVar("S")
T = TypeVar("T")

Rec1 = list[Union[Rec1[T, S], T, S]]
Rec2 = list[Union[Rec2[T, S, int], T, S]]  # E: Bad number of arguments for type alias, expected 2, given 3
Rec3 = list[Union[Rec3[int], T, S]]  # E: Bad number of arguments for type alias, expected 2, given 1

x1: Rec1[int, str]
x2: Rec2[int, str]
x3: Rec3[int, str]
reveal_type(x1)  # N: Revealed type is "list[... | int | str]"
reveal_type(x1[0])  # N: Revealed type is "list[... | int | str] | int | str"
reveal_type(x2)  # N: Revealed type is "list[list[... | Any] | int | str]"
reveal_type(x2[0])  # N: Revealed type is "list[... | Any] | int | str"
reveal_type(x3)  # N: Revealed type is "list[list[... | Any] | int | str]"
reveal_type(x3[0])  # N: Revealed type is "list[... | Any] | int | str"

[case recursive_type_of_type_attribute_access]
from typing import TypeVar
T = TypeVar("T")
Rec1 = list[type['Rec1'] | int]
Rec2 = list[type['Rec2[T]'] | T]

def f(x: Rec1, y: Rec2[int]):
    x[0].append  # E: Item "int" of "type[list[type[Rec1] | int]] | int" has no attribute "append"
    y[1].append  # E: Item "int" of "type[Rec2[int]] | int" has no attribute "append"

[case recursive_alias_without_generics]
from typing import TypeVar, TypeAlias
T = TypeVar('T')

A: TypeAlias = T | "list[A]"

def f(x: A[int]):
    reveal_type(x)  # N: Revealed type is "int | list[Any | list[...]]"
    if isinstance(x, list):
        reveal_type(x[0])  # N: Revealed type is "Any | list[...]"

[case recursive_alias_via_base_class_with_forward_reference]
# Like testRecursiveAliasViaBaseClass, but with forward references
from typing import List

x: B
B = List["C"]
class C(B): pass

reveal_type(x)  # N: Revealed type is "list[__main__.C]"
reveal_type(x[0][0])  # N: Revealed type is "__main__.C"

[case recursive_alias_via_base_class_with_different_module]
# Like testRecursiveAliasViaBaseClass, but with different modules
import m

[file m.py]
import n
from typing import List

x: B
B = List[n.C]

reveal_type(x)  # N: Revealed type is "list[n.C]"
reveal_type(x[0][0])  # N: Revealed type is "n.C"

[file n.py]
import m
class C(m.B): pass

[case recursive_alias_via_base_class_with_nested_class]
# flags: --disable-error-code used-before-def
# Like testRecursiveAliasViaBaseClass, but with forward references
from typing import List

x: B
B = List[X.C]
class X:
    class C(B): pass  # E: This base class/alias cycle is currently unsupported

reveal_type(x)  # N: Revealed type is "list[__main__.X.C]"
reveal_type(x[0][0])  # E: Value of type "C" is not indexable # N: Revealed type is "Any"

[case recursive_alias_with_isinstance_and_cast_no_stack_overflow]
# flags: --strict
from typing import MutableMapping, MutableSequence, cast, Union

type OT = None | str | int | float | MutableSequence["OT"] | MutableMapping[str, "OT"]

def f(obj: OT) -> bool:
    r = False
    if isinstance(obj, MutableMapping):
        for _, val in obj.items():
            r = f(cast(OT, val)) or r  # E: Redundant cast to "None | str | int | float | MutableSequence[OT] | MutableMapping[str, OT]"
    elif isinstance(obj, MutableSequence):
        for lval in obj:
            r = f(cast(OT, lval)) or r  # E: Redundant cast to "None | str | int | float | MutableSequence[OT] | MutableMapping[str, OT]"
    return r

[case recursive_tuple_should_not_hang]
# From GH #85
type T1 = tuple[T1, bool]
type T2 = tuple[bool, T2]
type T3 = str | tuple[bool, T3]
type T4 = str | tuple[T4, bool]
type T5 = tuple[T5, bool] | str
type T6 = tuple[bool, T6] | str

def f(a: T1):
    a == a
    reveal_type(a[0])  # N: Revealed type is "tuple[..., bool]"

def g(a: T2):
    reveal_type(a[1])  # N: Revealed type is "tuple[bool, ...]"
    a == a

def h(a: T3):
    reveal_type(a[1])  # N: Revealed type is "str | tuple[bool, ...]"
    a == a

def i(a: T4):
    reveal_type(a[0])  # N: Revealed type is "str | tuple[..., bool]"
    a == a

def j(a: T5):
    reveal_type(a[0])  # N: Revealed type is "tuple[..., bool] | str"
    a == a

def k(a: T6):
    reveal_type(a[1])  # N: Revealed type is "tuple[bool, ...] | str"
    a == a

[case recursive_types_and_unions_context_for_set]
# From GH #108
from typing import Mapping, TypeAlias, Union

IncEx: TypeAlias = Union[
    set[int],
    set[str],
    Mapping[int, Union["IncEx", bool]],
    Mapping[str, Union["IncEx", bool]],
]

def foo(a: IncEx | None) -> None: ...

foo(a={"foo"})

[case recursive_type_alias_assert_type]
from typing import assert_type
X = list['X'] | int

def f(x: X):
    assert_type(x, list[X] | int)
    assert_type(x, X)
    if isinstance(x, list):
        assert_type(x[0], list[X] | int)
        assert_type(x[0], X)

[case no_crash_type_var_with_bound_and_alias]
# From GH #281 (second part)
from typing import TypeAlias, TypeVar

class Array[CT: int]: ...

CT = TypeVar("CT", bound="int")
_Array: TypeAlias = Array[CT] | Array["_Array[CT]"]  # E: Type argument "_Array[CT]" of "Array" must be a subtype of "int"

class Array2[CT: int | _Array2[int]]: ...

CT2 = TypeVar("CT2", bound="int")
_Array2: TypeAlias = Array2[CT2] | Array2["_Array2[CT2]"]

[case invalid_alias_no_crash]
# From GH #280
a: c  # E: Variable "__main__.c" is not valid as a type \
      # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#variables-vs-type-aliases
b: c
c = b[int]
