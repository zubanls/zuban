[case recursive_alias_union_simplifying_with_generics]
# flags: --mypy-compatible --disable-error-code=used-before-def
from typing import TypeVar, Union, Sequence

S = TypeVar("S")
T = TypeVar("T")

def unite(s: S, t: T) -> S | T: ...

Rec1 = Sequence[Union[Rec1[T], int]]
Rec2 = Sequence[Union[Rec2[T], int, str]]
Rec3 = Sequence[Union[Rec3[T], float]]

i1: Rec1[int]
i2: Rec2[int]
i3: Rec3[int]

s1: Rec1[str]

reveal_type(unite(i1, i1))  # N: Revealed type is "typing.Sequence[... | int]"
reveal_type(unite(i1, i2))  # N: Revealed type is "typing.Sequence[... | int] | typing.Sequence[... | int | str]"
reveal_type(unite(i2, i1))  # N: Revealed type is "typing.Sequence[... | int | str] | typing.Sequence[... | int]"
reveal_type(unite(i1, i3))  # N: Revealed type is "typing.Sequence[... | int] | typing.Sequence[... | float]"
reveal_type(unite(i3, i1))  # N: Revealed type is "typing.Sequence[... | float] | typing.Sequence[... | int]"

u1 = unite(i1, s1)
u2 = unite(s1, i1)
x: str = u1  # E: Incompatible types in assignment (expression has type "Rec1[int] | Rec1[str]", variable has type "str") 
y: str = u2  # E: Incompatible types in assignment (expression has type "Rec1[str] | Rec1[int]", variable has type "str") 
reveal_type(u1)  # N: Revealed type is "typing.Sequence[... | int] | typing.Sequence[... | int]"
reveal_type(u2)  # N: Revealed type is "typing.Sequence[... | int] | typing.Sequence[... | int]"

[case recursive_alias_incorrect_generics_no_restrictions]
# flags: --mypy-compatible --disable-error-code=used-before-def
from typing import TypeVar, Union

S = TypeVar("S")
T = TypeVar("T")

Rec = list[Union[Rec[T, S], T, S]]

x1: Rec[int, float]
x2: Rec[str, int]
reveal_type(x1)  # N: Revealed type is "list[... | int | float]"
reveal_type(x1[0])  # N: Revealed type is "list[... | int | float] | int | float"
reveal_type(x2)  # N: Revealed type is "list[... | str | int]"
reveal_type(x2[0])  # N: Revealed type is "list[... | str | int] | str | int"

x3: Rec[str]  # E: Bad number of arguments for type alias, expected 2, given 1
x4: Rec[str, int, float]  # E: Bad number of arguments for type alias, expected 2, given 3
reveal_type(x3)  # N: Revealed type is "list[... | Any]"
reveal_type(x3[0])  # N: Revealed type is "list[... | Any] | Any"
reveal_type(x4)  # N: Revealed type is "list[... | Any]"
reveal_type(x4[0])  # N: Revealed type is "list[... | Any] | Any"

[case recursive_alias_incorrect_generics_inside_no_restrictions]
# flags: --mypy-compatible --disable-error-code=used-before-def
from typing import TypeVar, Union

S = TypeVar("S")
T = TypeVar("T")

Rec1 = list[Union[Rec1[T, S], T, S]]
Rec2 = list[Union[Rec2[T, S, int], T, S]]  # E: Bad number of arguments for type alias, expected 2, given 3
Rec3 = list[Union[Rec3[int], T, S]]  # E: Bad number of arguments for type alias, expected 2, given 1

x1: Rec1[int, str]
x2: Rec2[int, str]
x3: Rec3[int, str]
reveal_type(x1)  # N: Revealed type is "list[... | int | str]"
reveal_type(x1[0])  # N: Revealed type is "list[... | int | str] | int | str"
reveal_type(x2)  # N: Revealed type is "list[list[... | Any] | int | str]"
reveal_type(x2[0])  # N: Revealed type is "list[... | Any] | int | str"
reveal_type(x3)  # N: Revealed type is "list[list[... | Any] | int | str]"
reveal_type(x3[0])  # N: Revealed type is "list[... | Any] | int | str"

[case recursive_type_of_type_attribute_access]
from typing import TypeVar
T = TypeVar("T")
Rec1 = list[type['Rec1'] | int]
Rec2 = list[type['Rec2[T]'] | T]

def f(x: Rec1, y: Rec2[int]):
    x[0].append  # E: Item "int" of "type[list[type[Rec1] | int]] | int" has no attribute "append"
    y[1].append  # E: Item "int" of "type[Rec2[int]] | int" has no attribute "append"

[case recursive_alias_without_generics]
from typing import TypeVar, TypeAlias
T = TypeVar('T')

A: TypeAlias = T | "list[A]"

def f(x: A[int]):
    reveal_type(x)  # N: Revealed type is "int | list[Any | list[...]]"
    if isinstance(x, list):
        reveal_type(x[0])  # N: Revealed type is "Any | list[...]"

[case recursive_alias_via_base_class_with_forward_reference]
# Like testRecursiveAliasViaBaseClass, but with forward references
from typing import List

x: B
B = List["C"]
class C(B): pass

reveal_type(x)  # N: Revealed type is "list[__main__.C]"
reveal_type(x[0][0])  # N: Revealed type is "__main__.C"

[case recursive_alias_via_base_class_with_different_module]
# Like testRecursiveAliasViaBaseClass, but with different modules
import m

[file m.py]
import n
from typing import List

x: B
B = List[n.C]

reveal_type(x)  # N: Revealed type is "list[n.C]"
reveal_type(x[0][0])  # N: Revealed type is "n.C"

[file n.py]
import m
class C(m.B): pass

[case recursive_alias_via_base_class_with_nested_class]
# flags: --disable-error-code used-before-def
# Like testRecursiveAliasViaBaseClass, but with forward references
from typing import List

x: B
B = List[X.C]
class X:
    class C(B): pass  # E: This base class/alias cycle is currently unsupported

reveal_type(x)  # N: Revealed type is "list[__main__.X.C]"
reveal_type(x[0][0])  # E: Value of type "C" is not indexable # N: Revealed type is "Any"

[case recursive_alias_with_isinstance_and_cast_no_stack_overflow]
# flags: --strict
from typing import MutableMapping, MutableSequence, cast, Union

type OT = None | str | int | float | MutableSequence["OT"] | MutableMapping[str, "OT"]

def f(obj: OT) -> bool:
    r = False
    if isinstance(obj, MutableMapping):
        for _, val in obj.items():
            r = f(cast(OT, val)) or r  # E: Redundant cast to "None | str | int | float | MutableSequence[OT] | MutableMapping[str, OT]"
    elif isinstance(obj, MutableSequence):
        for lval in obj:
            r = f(cast(OT, lval)) or r  # E: Redundant cast to "None | str | int | float | MutableSequence[OT] | MutableMapping[str, OT]"
    return r

[case recursive_tuple_should_not_hang]
type T1 = tuple[T1, bool]
type T2 = tuple[bool, T2]

def f(a: T1):
    a == a
def g(a: T2):
    a == a
