[case protocol_class_access_with_self_type_check_without_ignoring_params_names]
-- From testProtocolTypeTypeSelfTypeInstanceMethod
from typing import Protocol, Type, TypeVar, Union

T = TypeVar("T")
class P(Protocol):
    def foo(ob, self: T) -> T: ...

class B:
    def foo(self: T) -> T: ...
class C:
    def foo(self: T) -> Union[T, int]: ...

def test(arg: P) -> None: ...
b: Type[B]
c: Type[C]
test(b)  # OK
test(c)  # E: Argument 1 to "test" has incompatible type "Type[C]"; expected "P" \
         # N: Following member(s) of "C" have conflicts: \
         # N:     Expected: \
         # N:         def [T] foo(self: T) -> T \
         # N:     Got: \
         # N:         def [T] foo(self: T) -> Union[T, int]

[case protocol_with_ellipsis_default]
from typing import Protocol
class Foo(Protocol):
    def foo(self, x: int = ...) -> None: ...

[case protocol_class_object_callable_possible]
-- testProtocolClassObjectCallableError a bit modified
from typing import Protocol, Any, Callable

class P(Protocol):
    def __call__(self, app: int) -> Callable[[str], None]:
        ...

class Q(Protocol):
    def __call__(self, app: str) -> Callable[[str], None]:
        ...

class R(Protocol):
    def __call__(self, app: str) -> Callable[[int], None]:
        ...

class C:
    def __init__(self, app: str) -> None:
        pass

    def __call__(self, el: str) -> None:
        return None

p: P = C  # E: Incompatible types in assignment (expression has type "Type[C]", variable has type "P") \
          # N: Following member(s) of "C" have conflicts: \
          # N: "C" has constructor incompatible with "__call__" of "P" \
          # N:     Expected: \
          # N:         def __call__(app: int) -> Callable[[str], None] \
          # N:     Got: \
          # N:         def __init__(app: str) -> C
q: Q = C
r: R = C  # E: Incompatible types in assignment (expression has type "Type[C]", variable has type "R") \
          # N: Following member(s) of "C" have conflicts: \
          # N: "C" has constructor incompatible with "__call__" of "R" \
          # N:     Expected: \
          # N:         def __call__(app: str) -> Callable[[int], None] \
          # N:     Got: \
          # N:         def __init__(app: str) -> C

[case supports_keys_and_getitem_propagation]
from typing import TypeVar, Tuple
from _typeshed import SupportsKeysAndGetItem

S = TypeVar('S')
T = TypeVar('T')
def foo(x: SupportsKeysAndGetItem[S, T]) -> Tuple[S, T]: ...

x: Tuple[int, str] = foo(reveal_type({}))  # N: Revealed type is "dict[int, str]"

[case iterable_propagation]
from typing import TypeVar, Tuple, Iterable

T = TypeVar('T')

def foo(x: Iterable[T]) -> T: ...
def bar(x: Iterable[T]) -> Tuple[T]: ...

x: int = foo(reveal_type([]))  # N: Revealed type is "list[int]"
y: Tuple[int] = bar(reveal_type([]))  # N: Revealed type is "list[int]"

[case join_protocol_both_sides]
# Like testJoinProtocolWithProtocol, but with additional tests
from typing import Protocol

class P(Protocol):
    attr: int
class P2(Protocol):
    attr: int
    attr2: str

x: P
y: P2

l0 = [x, x]
l1 = [y, y]
l = [x, y]
k = [y, x]
reveal_type(l0) # N: Revealed type is "builtins.list[__main__.P]"
reveal_type(l1) # N: Revealed type is "builtins.list[__main__.P2]"
reveal_type(l) # N: Revealed type is "builtins.list[__main__.P]"
reveal_type(k) # N: Revealed type is "builtins.list[__main__.P]"
