[case infer_partial_list_with_changes_to_non_self]
# Like testInferAttributeInitializedToEmptyNonSelf, but with an explicit annotation
from typing import Self

class C:
    def __init__(self) -> None:
        self.a = []  # E: Need type annotation for "a" (hint: "a: List[<type>] = ...")
        if bool():
            a: Self = self
            a.a = [1]
            a.a.append(1)
reveal_type(C().a)  # N: Revealed type is "builtins.list[Any]"

[case partial_list_any_aug_assignment]

x = []
x += [undefined]  # E: Name "undefined" is not defined
reveal_type(x)  # N: Revealed type is "list[Any]"

y = []
y += undefined  # E: Name "undefined" is not defined
reveal_type(y)  # N: Revealed type is "list[Any]"

[case partial_list_any_aug_assignment_in_self]

class Foo:
    def __init__(self) -> None:
        self.x = []
        self.x += [undefined]  # E: Name "undefined" is not defined
        reveal_type(self.x)  # N: Revealed type is "list[Any]"

        self.y = []
        self.y += undefined  # E: Name "undefined" is not defined
        reveal_type(self.y)  # N: Revealed type is "list[Any]"

[case partial_list_aug_assignment_in_self]

class Foo:
    def __init__(self) -> None:
        self.x = []
        self.x += [1]
        reveal_type(self.x)  # N: Revealed type is "list[int]"

[case partial_list_never_aug_assignment]

x = []
x += []
x += [1]
reveal_type(x)  # N: Revealed type is "list[int]"

y = []  # E: Need type annotation for "y" (hint: "y: List[<type>] = ...")
y += []
reveal_type(y)  # N: Revealed type is "list[Any]"

[case module_mutual_flow_analysis_partial_list]
# flags: --warn-unreachable
import a
reveal_type(a.foo)  # N: Revealed type is "list[int]"
[file a.py]
bar = []
bar.append(1)
foo = bar
reveal_type(foo)  # N: Revealed type is "list[int]"

[case walrus_with_partial_list]
# flags: --warn-unreachable
# Like testWalrusPartialTypes, but with a bit of additional code as well
from typing import List

def check_partial_list() -> None:
    if (z := []):
        print(1)  # Theoretically this would be unreachable and could be analyzed as such as well.
    else:
        z.append(4)
    reveal_type(z)  # N: Revealed type is "list[int]"

[case partial_dict]
class A:
    def f(self) -> None:
        self.x = dict()
        self.x[1] = ""
        reveal_type(self.x)  # N: Revealed type is "dict[int, str]"

[case partial_defaultdict_with_set]
from collections import defaultdict
x = defaultdict(set)
x[1].add("")
reveal_type(x)  # N: Revealed type is "collections.defaultdict[int, set[str]]"

y = defaultdict(set)
y[1].update([""])
reveal_type(x)  # N: Revealed type is "collections.defaultdict[int, set[str]]"

[case partial_nullable_defaultdict_with_list_mypy_compatible]
# flags: --mypy-compatible
from collections import defaultdict
class A:
    def __init__(self) -> None:
        self.x = None
        self.x = defaultdict(list)
        self.x[0].extend([""])
        reveal_type(self.x)  # N: Revealed type is "collections.defaultdict[int, list[str]]"

reveal_type(A().x)  # N: Revealed type is "collections.defaultdict[int, list[str]]"

[case partial_nullable_defaultdict_with_list_no_mypy_compatible]
# flags: --no-mypy-compatible
from collections import defaultdict
class A:
    def __init__(self) -> None:
        self.x = None
        self.x = defaultdict(list)
        self.x[0].extend([""])
        reveal_type(self.x)  # N: Revealed type is "collections.defaultdict[int, list[str]]"

reveal_type(A().x)  # N: Revealed type is "collections.defaultdict[int, list[str]] | None"

[case partial_nullable_self_overwrite_mypy_compatible]
# flags: --mypy-compatible
class A:
    def __init__(self) -> None:
        self.x = None
        self.x = []
        self.x = [1]
        reveal_type(self.x)  # N: Revealed type is "list[int]"

reveal_type(A().x)  # N: Revealed type is "list[int]"

[case partial_nullable_self_overwrite_no_mypy_compatible]
# flags: --no-mypy-compatible
class A:
    def __init__(self) -> None:
        self.x = None
        self.x = []
        self.x = [1]
        reveal_type(self.x)  # N: Revealed type is "list[int]"

reveal_type(A().x)  # N: Revealed type is "list[int] | None"

[case partial_nullable_self_augassign_mypy_compatible]
# flags: --mypy-compatible
class A:
    def __init__(self) -> None:
        self.x = None
        self.x = []
        self.x += [1]
        reveal_type(self.x)  # N: Revealed type is "list[int]"

reveal_type(A().x)  # N: Revealed type is "list[int]"

[case partial_nullable_self_augassign_no_mypy_compatible]
# flags: --no-mypy-compatible
class A:
    def __init__(self) -> None:
        self.x = None
        self.x = []
        self.x += [1]
        reveal_type(self.x)  # N: Revealed type is "list[int]"

reveal_type(A().x)  # N: Revealed type is "list[int] | None"

[case partial_nullable_self_dict_assign_mypy_compatible]
# flags: --mypy-compatible
class A:
    def __init__(self) -> None:
        self.x = None
        self.x = {}
        self.x["a"] = 1
        reveal_type(self.x)  # N: Revealed type is "dict[str, int]"

reveal_type(A().x)  # N: Revealed type is "dict[str, int]"

[case partial_nullable_self_dict_assign_no_mypy_compatible]
# flags: --no-mypy-compatible
class A:
    def __init__(self) -> None:
        self.x = None
        self.x = {}
        self.x["a"] = 1
        reveal_type(self.x)  # N: Revealed type is "dict[str, int]"

reveal_type(A().x)  # N: Revealed type is "dict[str, int] | None"

[case narrowed_partial1_mypy_compatible]
# flags: --mypy-compatible
import foo
reveal_type(foo.x)  # N: Revealed type is "list[str]"

[file foo.py]
x = None
x = []
x.append("")
reveal_type(x)  # N: Revealed type is "list[str]"

[case narrowed_partial1_no_mypy_compatible]
# flags: --no-mypy-compatible
import foo
reveal_type(foo.x)  # N: Revealed type is "list[str] | None"

[file foo.py]
x = None
x = []
x.append("")
reveal_type(x)  # N: Revealed type is "list[str]"

[case narrowed_partial2_mypy_compatible]
# flags: --mypy-compatible
import foo
reveal_type(foo.x)  # N: Revealed type is "dict[int, str]"

[file foo.py]
x = None
x = {}
x[0] = ""
reveal_type(x)  # N: Revealed type is "dict[int, str]"

[case narrowed_partial2_no_mypy_compatible]
# flags: --no-mypy-compatible
import foo
reveal_type(foo.x)  # N: Revealed type is "dict[int, str] | None"

[file foo.py]
x = None
x = {}
x[0] = ""
reveal_type(x)  # N: Revealed type is "dict[int, str]"

[case narrowed_partial3_mypy_compatible]
# flags: --mypy-compatible
import foo
reveal_type(foo.x)  # N: Revealed type is "list[int]"

[file foo.py]
x = None
x = []
x = [1]
reveal_type(x)  # N: Revealed type is "list[int]"

[case narrowed_partial3_no_mypy_compatible]
# flags: --no-mypy-compatible
import foo
reveal_type(foo.x)  # N: Revealed type is "list[int] | None"
reveal_type(foo.y)  # N: Revealed type is "set[int] | None"

[file foo.py]
x = None
x = []
x = [1]
reveal_type(x)  # N: Revealed type is "list[int]"

y = None
y = set()
y = {1}
reveal_type(y)  # N: Revealed type is "set[int]"

[case narrowed_partial4_mypy_compatible]
# flags: --mypy-compatible
import foo
reveal_type(foo.x)  # N: Revealed type is "list[int]"
reveal_type(foo.y)  # N: Revealed type is "set[int]"

[file foo.py]
x = None
x = []
x += [1]
reveal_type(x)  # N: Revealed type is "list[int]"

y = None
y = set()
y |= {1}
reveal_type(y)  # N: Revealed type is "set[int]"

[case narrowed_partial4_no_mypy_compatible]
# flags: --no-mypy-compatible
import foo
reveal_type(foo.x)  # N: Revealed type is "list[int] | None"
reveal_type(foo.y)  # N: Revealed type is "set[int] | None"

[file foo.py]
x = None
x = []
x += [1]
reveal_type(x)  # N: Revealed type is "list[int]"

y = None
y = set()
y |= {1}
reveal_type(y)  # N: Revealed type is "set[int]"

[case invalid_aug_partial_change]
x = set()  # E: Need type annotation for "x" (hint: "x: Set[<type>] = ...")
x |= [1]  # E: Argument 1 to "__ior__" of "set" has incompatible type "list[int]"; expected "AbstractSet[Any]"
x |= {1}
reveal_type(x)  # N: Revealed type is "set[int]"

y = set()  # E: Need type annotation for "y" (hint: "y: Set[<type>] = ...")
y *= [1]  # E: Unsupported operand types for * ("set[Any]" and "list[int]")
reveal_type(y)  # N: Revealed type is "set[Any]"

[case walrus_defaultdict_partial1]
from collections import defaultdict
walrus = (x := defaultdict(set))  # E: Need type annotation for "x"
reveal_type(walrus)  # N: Revealed type is "collections.defaultdict[Any, Any]"
x[1].add("")
reveal_type(x)  # N: Revealed type is "collections.defaultdict[int, set[str]]"

[case walrus_defaultdict_partial2]
from collections import defaultdict
walrus = (x := defaultdict(int))  # E: Need type annotation for "x"
reveal_type(walrus)  # N: Revealed type is "collections.defaultdict[Any, int]"
x[""] = 1
reveal_type(x)  # N: Revealed type is "collections.defaultdict[str, int]"
