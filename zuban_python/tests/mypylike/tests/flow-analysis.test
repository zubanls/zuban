[case unreachable_var_definition]
import mod
mod.foo  # E: Module has no attribute "foo"
mod.bar  # E: Module has no attribute "bar"
[file mod.py]
import sys
if sys.platform == 'lol':
    foo = 3
    def bar() -> None: ...

foo  # E: Name "foo" is not defined
bar  # E: Name "bar" is not defined

[case unreachable_var_definition_with_assert]
# flags: --mypy-compatible
import mod
mod.foo  # E: Module has no attribute "foo"
mod.bar  # E: Module has no attribute "bar"
mod.undefined  # E: Module has no attribute "undefined"
[file mod.py]
import sys
assert sys.platform == 'lol'
foo = 3
def bar() -> None: ...

foo
bar
undefined

[case unreachable_var_definition_with_return]
def func() -> None:
    if bool():
        return
        foo = 3
        def bar() -> None: ...

    foo  # E: Name "foo" is not defined
    bar  # E: Name "bar" is not defined
    undefined  # E: Name "undefined" is not defined

[case unreachable_var_definition_with_raise]
def func() -> None:
    if bool():
        raise; foo = 3
        def bar() -> None: ...

    foo  # E: Name "foo" is not defined
    bar  # E: Name "bar" is not defined
    undefined  # E: Name "undefined" is not defined

[case unreachable_var_after_assert_false]
# flags: --warn-unreachable
from typing import Literal, TYPE_CHECKING
x: Literal[False]
def func1() -> None:
    assert False; undefined1  # E: Statement is unreachable
    undefined2
def func2() -> None:
    assert x; undefined1  # E: Statement is unreachable
    undefined2
def func3() -> None:
    assert not TYPE_CHECKING; undefined1  # E: Statement is unreachable
    undefined2

[case conjunction_partial_inference_combination_issue]
# This was an issue, because flow analysis for conjunction can lead to
# multiple times trying to infer partials (which are not even used here).
import os
def foo() -> None:
    x = 1 and os.path.islink("").conjugate(1)  # E: Too many arguments for "conjugate" of "int"

[case avoid_type_computation_recursion]

[file foo.py]
from typing import Generic
from bar import X
class Foo(Generic[X]): ...
[file bar.py]
from typing import TypeVar
import foo

if bool():  # Causes flow analysis to happen
    X = TypeVar("X")

def here() -> None:
    reveal_type(foo.Foo())

[case flow_analysis_should_be_avoided_for_simple_imports]
import foo
for x in [1]:
    foo.bar  # This used to cause "Cannot use Final inside a loop" in foo.py

[file foo.py]
from typing import Final
bar: Final = 1

[case flow_analysis_circular_dependency]
# flags: --warn-unreachable
import foo
[file foo.py]
from bar import X
if bool(): # Causes flow analysis
    def foo() -> X: ...

class Y: ...
[file bar.py]
from foo import Y
if bool(): # Causes flow analysis
    def bar() -> Y: ...

class X: ...

[case flow_analysis_global_context_should_not_be_loop_context]
# flags: --mypy-compatible
import foo

def f(x: foo.X) -> None:
    x.abc

[file foo.py]
from typing import Final

bar: Final = 1

class X:
    def __init__(self) -> None:
        for x in (1,):
            self.abc = bar

[case flow_analysis_circular_import_but_simple_assign_is_fine]
# flags: --warn-unreachable
import foo
[file foo.py]
from bar import x1, x2, x3  # E: Cannot determine type of "x1"
if bool(): # Causes flow analysis
    ...

y1 = str()
y2 = 1
y3: int = 1
[file bar.py]
from foo import y1, y2, y3
if bool(): # Causes flow analysis
    ...

x1 = str()
x2 = 1
x3: int = 1

[case flow_analysis_circular_import_but_import_is_fine]
# flags: --warn-unreachable
import foo
[file foo.py]
from bar import x1, x2
if bool(): # Causes flow analysis
    ...

import other as y1
from other import something as y2

[file bar.py]
from foo import y1, y2
if bool(): # Causes flow analysis
    ...

class X: ...

import other as x1
from other import something as x2

[file other.py]
something = 1

[case flow_analysis_avoid_final_loop_issue_in_simple_case]
# flags: --warn-unreachable
import foo

[file foo.py]
from typing import Final
from bar import X

for _ in [1]:
    X.member

y = str()

[file bar.py]
from typing import Final
from foo import y

x = str()
class X:
    member: Final = 1

[case flow_analysis_member_loops]
from foo import C
C().definition

[file foo.py]
class P:
    def __init__(self) -> None:
        self.x: int = 1

    def foo(self, other: C) -> None:
        other.y

class C:
    def __init__(self) -> None:
        P().x
        self.y = int()
        self.definition = 1

[case flow_analysis_base_class_calculation_should_not_lead_to_recursion]
from x import X
class C(X): ...

[file x.py]
from y import Z
class X(Z): ...

[file y.py]
from z import Z
from z import Z
from x import X
class Y(X): ...

[file z.py]
class Z: ...

[case star_import_overwrite_regression1]
from f import C

[file f.py]
from h import C
from g import *

[file g.py]
from h import C
[file h.py]
class C: ...

[case star_import_overwrite_regression2]
from f import C

[file f.py]
from g import *
from h import C

[file g.py]
from h import C
[file h.py]
class C: ...

[case star_import_overwrite_regression3]
from f import C

[file f.py]
from h import C
from g import *

[file g.py]
class C: ...
[file h.py]
class C: ...

[case avoid_crash_on_aug_assign_access1]
class C:
    x: int
class D(C):
    def f(self) -> None:
        self.x *= 3

reveal_type(D().x)  # N: Revealed type is "int"

[case avoid_crash_on_aug_assign_access2]
class C:
    x: int
class D(C):
    def f(self) -> None:
        self.x *= ""  # E: Incompatible types in assignment (expression has type "str", variable has type "int")

reveal_type(D().x)  # N: Revealed type is "int"
