[case reveal_type_defined_in_untyped_func]
def reveal_type(a: str) -> None: ...
def foo():
    reveal_type(1)

[case union_alias_disallowed_any_expr_simple]
# flags: --disallow-any-explicit
from typing import Any, TypeAlias, Tuple

x1: TypeAlias = Any | int  # E: Explicit "Any" is not allowed
y1: TypeAlias = int | Any  # E: Explicit "Any" is not allowed

x2 = Any | int  # E: Explicit "Any" is not allowed
y2 = int | Any  # E: Explicit "Any" is not allowed

x: Tuple[x1, y1, x2, y2]

[case union_alias_disallowed_any_expr_nested]
# flags: --disallow-any-explicit
from typing import Any, TypeAlias, Tuple

x1: TypeAlias = list[Any] | int  # E: Explicit "Any" is not allowed
y1: TypeAlias = int | list[Any]  # E: Explicit "Any" is not allowed

x2 = list[Any] | int  # E: Explicit "Any" is not allowed
y2 = int | list[Any]  # E: Explicit "Any" is not allowed

x: Tuple[x1, y1, x2, y2]

[case redundant_casts_with_any_nested]
# flags: --warn-redundant-casts
from typing import cast, Any

x: list[int]
cast(list[int], x) # E: Redundant cast to "list[int]"
cast(list[Any], x)

[case unannotated_return_in_method_with_disallow_untyped_defs]
# flags: --disallow-untyped-defs
# Like testUnannotatedReturnWithOnlySelfArgument, but fixed with context
class Foo:
    def f(self): pass
[out]
main:4: error: Function is missing a return type annotation
main:4: note: Use "-> None" if function does not return a value

[case show_error_codes_in_mypy_config]
a: str = 3  # E: Incompatible types in assignment (expression has type "int", variable has type "str")  [assignment]
[file mypy.ini]
[mypy]
show_error_codes = True

[case show_error_codes_in_pyproject_toml]
a: str = 3  # E: Incompatible types in assignment (expression has type "int", variable has type "str")  [assignment]
[file pyproject.toml]
[tool.mypy]
show_error_codes = true

[case show_column_numbers_in_mypy_config]
a: str = 3
[file mypy.ini]
[mypy]
show_column_numbers = True
show_error_end = True
[out]
main:1:10:1:11: error: Incompatible types in assignment (expression has type "int", variable has type "str")

[case show_column_numbers_in_pyproject_toml]
a: str = 3
[file pyproject.toml]
[tool.mypy]
show_column_numbers = true
show_error_end = true
[out]
main:1:10:1:11: error: Incompatible types in assignment (expression has type "int", variable has type "str")

[case strict_allows_explicit_any]
# flags: --strict
from typing import Any
def foo(x: Any) -> None: ...

[case cast_arbitrary_len_tuple_to_fixed_len]
# flags: --warn-redundant-casts
from typing import cast
def foo(x: tuple[int, ...], y: tuple[int, int]) -> tuple[int, int]:
    if bool():
        return cast(tuple[int, int], y)  # E: Redundant cast to "tuple[int, int]"
    return cast(tuple[int, int], x)

[case type_of_none_overlaps_with_object]
# flags: --strict-equality
#x: object = type(None)
def foo(obj: object) -> None:
    if obj is type(None): ...
    if 1 is type(None): ...  # E: Non-overlapping identity check (left operand type: "int", right operand type: "Type[None]")

[case type_overlaps_with_type]
# flags: --strict-equality
from typing import Any

def foo(i: type[int], x: type[Any], y: type, z: type[object]) -> None:
    i == x
    x == i
    x == y
    y == x
    i == y
    y == i

    z == x
    x == z
    z == y
    y == z
    z == i
    i == z

    type == i  # E: Non-overlapping equality check (left operand type: "Type[type]", right operand type: "Type[int]")
    i == type  # E: Non-overlapping equality check (left operand type: "Type[int]", right operand type: "Type[type]")
    type == x
    x == type
    type == y
    y == type
    type == z
    z == type

    type == type(x)
    type(x) == type
    type == type(y)
    type(y) == type
    type == type(z)
    type(z) == type
    type == type(i)
    type(i) == type

[case redundant_cast_with_new_type]
# flags: --warn-redundant-casts
from typing import cast, NewType

A = NewType("A", int)

x = 1
y = cast(A, x)
cast(A, y) # E: Redundant cast to "A"
