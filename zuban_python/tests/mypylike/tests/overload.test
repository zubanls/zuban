[case overload_not_overlapping_none]
@overload
def f(x: None) -> object: ...
@overload
def f(x: str) -> str: ...
@overload
def f(x: Any) -> str: ...
def f(x): pass

[case overload_unmatchable_none_strict_optional]
@overload
def g(x: str) -> object: ...
@overload
def g(x: None) -> str: ...
@overload
def g(x: Any) -> str: ...
def g(x): pass

[case overload_unmatchable_none]
# flags: --no-strict-optional
@overload
def g(x: str) -> object: ...
@overload
def g(x: None) -> str: ...  # E: Overloaded function signature 2 will never be matched: signature 1's parameter type(s) are the same or broader
@overload
def g(x: Any) -> str: ...
def g(x): pass

[case overload_not_overlapping_optional]
from typing import overload, List, Dict, Optional, Sequence, Union, Tuple

@overload
def f(a: List[Dict]) -> List[int]: # E: overloaded function signatures 1 and 2 overlap with incompatible return types
    ...

@overload
def f(a: List[Optional[Dict]]) -> List[Optional[int]]:
    ...

def f(
    a: Union[List[Dict], List[Optional[Dict]]]
) -> Union[List[int], List[Optional[int]]]:
    return [1]

[case overload_overlapping_any]
from typing import overload, TypeVar

T = TypeVar("T")

@overload
def f(x: T) -> T: pass
@overload
def f(x: Any) -> Any: pass
@overload
def f(x: Any) -> Any: pass  # E: Overloaded function signature 3 will never be matched: signature 2's parameter type(s) are the same or broader
def f(x: Any) -> Any: pass

[case overload_merging_nested]
from typing import overload, Any
@overload
def g(x: str) -> list[list[str]]: ...
@overload
def g(x: int) -> list[list[int]]: ...
def g(x): pass

a: Any
reveal_type(g(a)) # N: Revealed type is "list[list[Any]]"

[case overload_merging_triple1]
from typing import overload, Any
@overload
def g(x: str) -> list[str]: ...
@overload
def g(x: int) -> list[int]: ...
@overload
def g(x: bytes) -> list[bytes]: ...
def g(x): pass

a: Any
reveal_type(g(a)) # N: Revealed type is "list[Any]"

[case overload_merging_triple2]
from typing import overload, Any
@overload
def g(x: str) -> str: ...
@overload
def g(x: int) -> int: ...
@overload
def g(x: float) -> bytes: ...
def g(x): pass

a: Any
reveal_type(g(a)) # N: Revealed type is "Any"

[case overload_merging_tuple1]
from typing import overload, Any
@overload
def g(x: str) -> tuple[str, ...]: ...
@overload
def g(x: int) -> tuple[int, ...]: ...
def g(x): pass

a: Any
reveal_type(g(a)) # N: Revealed type is "tuple[Any, ...]"

[case overload_merging_tuple2]
from typing import overload, Any
@overload
def g(x: str) -> tuple[str]: ...
@overload
def g(x: int) -> tuple[int]: ...
def g(x): pass

a: Any
reveal_type(g(a)) # N: Revealed type is "tuple[Any]"

[case overload_merging_tuple3]
from typing import overload, Any
@overload
def g(x: str) -> tuple[str, bytes]: ...
@overload
def g(x: int) -> tuple[int]: ...
def g(x): pass

a: Any
reveal_type(g(a)) # N: Revealed type is "tuple[Any, ...]"

[case overload_merging_tuple4]
from typing import overload, Any
@overload
def g(x: str) -> tuple[int, ...]: ...
@overload
def g(x: int) -> tuple[int, ...]: ...
def g(x): pass

a: Any
reveal_type(g(a)) # N: Revealed type is "tuple[int, ...]"

[case overload_merging_tuple5]
from typing import overload, Any
@overload
def g(x: str) -> tuple[int, str]: ...
@overload
def g(x: int) -> tuple[int, str]: ...
def g(x): pass

a: Any
reveal_type(g(a)) # N: Revealed type is "tuple[int, str]"

[case overload_merging_tuple6]
from typing import overload, Any
@overload
def g(x: str) -> tuple[int, str]: ...
@overload
def g(x: int) -> tuple[int, bytes]: ...
def g(x): pass

a: Any
reveal_type(g(a)) # N: Revealed type is "tuple[int, Any]"

[case overload_with_callable_type_var_mypy_issue_13436]
from typing import Any, Callable, overload, TypeVar
C = TypeVar("C", bound=Callable[..., object])

@overload
def wrapper(arg: C) -> C: ...
@overload
def wrapper(arg: object) -> object: ...
def wrapper(arg: object) -> object: ...

def case_a(x: int) -> None: pass

reveal_type(case_a)           # N: Revealed type is "def (x: builtins.int)"
reveal_type(wrapper(case_a))  # N: Revealed type is "def (x: builtins.int)"

def case_b(x: Any) -> None: pass

reveal_type(case_b)           # N: Revealed type is "def (x: Any)"
reveal_type(wrapper(case_b))  # N: Revealed type is "def (x: Any)"

[case overload_union_math_on_class_init_constrained]
from typing import Callable, Union, overload, Generic
T = TypeVar("T", str, int)

class Foo(Generic[T]):
    @overload
    def __init__(self, x: int, y: T): ...
    @overload
    def __init__(self, x: T, y: str): ...
    def __init__(self, x, y): ...

u1: int | str
reveal_type(Foo(1, "")) # N: Revealed type is "__main__.Foo[builtins.str]"
reveal_type(Foo(1, u1)) # N: Revealed type is "__main__.Foo[builtins.int] | __main__.Foo[builtins.str]"

[case overload_union_math_on_class_init_unconstrained]
from typing import Callable, Union, overload, Generic
T = TypeVar("T")

class Foo(Generic[T]):
    @overload
    def __init__(self, x: int, y: T): ...
    @overload
    def __init__(self, x: T, y: str): ...
    def __init__(self, x, y): ...

u1: int | str
reveal_type(Foo(1, "")) # N: Revealed type is "__main__.Foo[builtins.str]"
reveal_type(Foo(1, u1)) # N: Revealed type is "__main__.Foo[int | str]"

[case multi_dimension_union_math_issue_13595]
# Taken from mypy #13595
from typing import Union, overload

@overload
def f(x: int, y: int) -> None: ...
@overload
def f(x: str, y: int) -> None: ...
@overload
def f(x: int, y: str) -> None: ...
@overload
def f(x: str, y: str) -> None: ...
def f(x, y) -> None: ...

a: Union[int, str]
b: Union[int, str]
f(a, b) # This is valid

[case overload_class_type_var_implementation_match_and_mismatch]
from typing import Callable, Union, overload, Generic, Optional
T = TypeVar("T")
U = TypeVar("U")

class Foo(Generic[T]):
    @overload
    def foo(self, x: int) -> T: ...
    @overload
    def foo(self, x: str) -> Optional[T]: ...
    @overload
    def foo(self, x: U, y: int) -> Optional[U]: ...
    def foo(self, x, y=None) -> Optional[T]: ... # E: Overloaded function implementation cannot produce return type of signature 3

[case overload_michi_valid_implementation]
# Originally raise by Michi. This should theoretically not lead to errors, but
# Mypy and Zuban both just compare the named parameters, which leads to this
# error.
from typing import overload

@overload
def oof(fn: int) -> int: ...

@overload
def oof(fn2: bytes) -> bytes: ...

def oof(fn: int | bytes | None = None, fn2: bytes | None = None) -> bytes | int: raise NotImplementedError # E: Overloaded function implementation does not accept all possible arguments of signature 2

[case overload_check_defaults_for_implementation_only]
from typing import overload

@overload
def foo(x: int) -> int: ...
@overload
def foo(x: str = ...) -> str: ...
def foo(x: int | str = b"") -> str | int: ... # E: Incompatible default for argument "x" (default has type "bytes", argument has type "int | str")
