# Next up
testTypeVarTupleTypeApplicationOverload
testUnionOfNonIterableUnpacking
testPostInitIsNotAFunction
self_annotation_eq_mismatch
mypy_setup_ini_with_multiline_string

# regressions
testIncrementalInvalidNamedTupleInUnannotatedFunction

# callable matching regression
testNoCrashOnNestedGenericCallable

# WTF why is this base type not object/function?
testListLiteralWithNameOnlyArgsDoesNotEraseNames
# join of {1, *some_str_tuple} leads to int | str???
testUnpackInExpression2-only_when_nocache
# Self is confused. matcher needs to know Self from both sides.
testOverloadWithDerivedFromAny
testTypingSelfOverrideVarMulti
# Self remapped, but it shouldn't
testTypingSelfInternalSafe
testTypingSelfClashInBodies
# Any base class now matches everything for union simplification
testUnionSimplificationSpecialCases2
# EnumMeta does not inherit from ABCMeta anymore: https://github.com/python/typeshed/pull/10577
testStrEnumCreation
testRegression12258
testDerivedEnumIterable
testEnumIterMetaInference
# Callable matching positional names ignored, but kwargs is there; mypy wrong?
testProtocolIncompatibilityWithUnionType
# dict questionable decisions
testDictWithStarStarExpr
testDictFromIterableAndStarStarArgs
testDictFromIterableAndStarStarArgs2
# Type variable "C.T" cannot be used as an expression
testClassMemberTypeVarInFunctionBody
testClassScopeImportWithError
# Type variable "__main__.Ts" is invalid as target for type alias
testTypeVarTupleIsNotValidAliasTarget
testGenericTypeAliasesWrongAliases
# Type var used in bound, defined in class body, bound to that class
testGenericClassAlternativeConstructorPreciseOverloaded
# Type var bound cycle
testSuperClassGetItem
testSelfTypeNew
testSelfTypeNew_explicit
testNewAnalyzerDuplicateTypeVar
testNewAnalyzerDuplicateTypeVarImportCycle
testNewAnalyzerDuplicateTypeVarImportCycleWithAliases
# i_s missing current class
testLambdaDeferredSpecialCase
# NewType generics resolving
new_type_with_class_generics
new_type_with_class_generics2
# import recursive usages and therefore "Cannot determine type of "Node""
testTreeShadowingViaParentPackage

# param spec complex nested transitive tests
testParamSpecNestedApplyPosVsNamed
# Callable remapping over overload leads to a mapped overload (this is special cased for only one arg and decorator like behavior, see also is_generic_decorator_overload_call)
testRegularGenericDecoratorOverload
testParamSpecDecoratorOverload
# Weird class type vars passing
testDefaultDict
# list element context inference should probably ignore type vars
testInferenceAgainstGenericCallableGenericNonLinear
# Recursive alias union type var inference where Nested[T] is checked before T
testRecursiveAliasWithRecursiveInstanceInference
# type var backtracking
testUnionInference
testCrashOnComplexCheckWithNamedTupleNext
unite_type_vars_mypy_issue_5874
# type var backtracking for overloads if variant does not match
testMatchProtocolAgainstOverloadWithAmbiguity
# type var with unions and fallback in case solving is not possible
testTypeVarTupleInvariant

# union math vs. type var
testOverloadDetectsPossibleMatchesWithGenerics
testOverloadsAndNoReturnNarrowWhenBlacklistingSubtype
testOverloadsAndNoReturnNarrowWhenBlacklistingSubtype2
testOverloadsAndNoReturnNarrowTypeNoStrictOptional2
testOverloadsAndNoReturnNarrowTypeWithStrictOptional2
testOverloadsAndNoReturnNarrowTypeNoStrictOptional3
testOverloadsAndNoReturnNarrowTypeWithStrictOptional3
# overload Any unclear why Mypy decides like this
testTypeVarTupleOverloadMatch
# overload x should be preferred over an *x alternative
testTupleOverloadZipAny

# Special-case type inference of empty collections https://github.com/python/mypy/pull/16122
testInferenceWorksWithEmptyCollectionsUnion
testWideOuterContextEmptyError
testWideOuterContextNoArgsError
testInferenceWorksWithEmptyCollectionsNested
testCallerVarargsAndComplexTypeInference
# Union/addition of empty lists dicts sets with used ones
testOrOperationWithGenericOperands
testOrOperationInferredFromContext
testInWithInvalidArgs
# [''] + [1] does not generate an error
testAssignmentSubtypes
testRedundantExprTruthiness
# union order issues
testNarrowingEqualityDisabledForCustomEquality
# bool literal type matching
assign_bool_to_false_true_literal
testBoolInTuplesRegression

# Class argument and __init__ as overloaded DbType
testOverloadedToGeneric
# Class __init__ like `def __init__(self: C[Int[S]], x: int, y: S) -> None: ...`
testOverloadedGenericInit
# object.__new__(cls) -> Self where object.__new__(int) leads to Never
testOverride__new__AndCallObject
# __new__ return types with Never
testNewAndInitNoReturn
testOverloadedNewAndInitNoReturn

# list[Any] should not be narrowed to e.g. list[int]
testNewAnalyzerBuiltinAliasesFixed
testInferredTypeIsSimpleNestedList
testInferredTypeIsSimpleNestedIterable
testInferredTypeIsSimpleNestedListLoop
testInferredTypeIsSimpleNestedIterableLoop
# TypeGuard/TypeIs narrowing with Any
testTypeGuardNestedRestrictionAny
testTypeIsNestedRestrictionAny
# or/and boolean logic over multiple terms
testAndOr
testRestrictedBoolAndOrWithGenerics
testOrCases
testAndCases
# isinstance intersections lead sometimes to never?
testIsInstanceAdHocIntersectionIncrementalIntersectionToUnreachable
testIsInstanceAdHocIntersectionIncrementalUnreachaableToIntersection
testIsInstanceAdHocIntersectionFineGrainedIncrementalIntersectionToUnreachable
testIsInstanceAdHocIntersectionFineGrainedIncrementalUnreachaableToIntersection
# "Function "property_decorator_missing" could always be true in boolean context"
testUnreachableFlagMiscTestCaseMissingMethod
testWalrus
# --strict-equality strict equality "Non-overlapping equality check (left operand type: "int", right operand type: "str")"
testStrictEqualityNoPromotePy3
testStrictEqualityAllowlist
testNarrowingEqualityDisabledForCustomEqualityChain
testNarrowingEqualityFlipFlop
testStrictEqualitywithParamSpec
# optional assignment within class
testLocalPartialTypesWithInheritance3
testInheritedAttributeNoStrictOptional
# formatting the wrong class in assignment to member of superclass of superclass
testClassOrderOfError
testClassIgnoreType_RedefinedAttributeAndGrandparentAttributeTypesNotIgnored
# Dynamic functions are ignored in classes and the super class is used?
testInferringTypesFromIterable
testMultipleAssignmentAndGenericSubtyping

# Make x an Optional if else contains `x = None`
testOptionalBackwards1
testOptionalBackwards2
testOptionalBackwards4
# needs error because only reassignments with other partial
testInferenceWithUninhabitedType

# --------------------------- Not first release ---------------------------

# --disallow-any-generics
testDisallowAnyGenericsForAliasesInRuntimeContext
testGenericTypedDictAlias
testNewAnalyzerDisallowAnyGenericsMessages

# Better functools.total_ordering support
testTotalOrderingLambda
testTotalOrderingReturnNotBool
testTotalOrderingAllowsAny

# with scoping is special (Does it need to be??)
testWithStmtScopeBasics
testWithStmtScopeNestedWith1
testWithStmtScopeNestedWith2
testWithStmtScopeInnerAndOuterScopes
testWithStmtScopeMultipleContextManagers
testWithStmtScopeMultipleAssignment
testWithStmtScopeAndClass
testWithStmtScopeAndLambda

# Self definitions different from parent
testSelfTypeOverrideCompatibility
# "Property "x" defined in "Base" is read-only" because of NamedTuple inheritance
testNewNamedTupleMethodInheritance
# Inheritance ClassVar in parent of parent, overwritten in parent and therefore should still be a ClassVar but isn't
testOverrideClassVarManyBases
# Multi inheritance should check both sides
testMultipleInheritance_NestedVariableOverriddenWithIncompatibleType1
testGenericMultipleOverrideReplace
testUseSupertypeAsInferenceContextConflict
# Redefinitions of star imports and builtins
testNewAnalyzerIdentityAssignment1
testNewAnalyzerIdentityAssignment2
testNewAnalyzerIdentityAssignment3

# "Cannot assign multiple types to name "b" without an explicit "Type[...]" annotation"
testAliasesInClassBodyNormalVsSubscripted
# type alias reassignments
testProhibitReassigningSubscriptedAliases
testProhibitReassigningGenericAliases
# overload statements between definitions
testRedefinedOverloadedFunction

# finally must be checked twice
testUnionTryFinally
testUnionTryFinally5
testUnionTryFinally6
# while must be rechecked if type widens
testModifyLoop
testModifyLoopWhile4
testModifyLoopFor4
testModifyLoopLong
testComplicatedBlocks
testIsInstanceSubClassMemberHard
# Narrowing len()
testNarrowingLenTypeVarTupleGreaterThan
testNarrowingLenBareExpressionTypeVarTuple
testNarrowingLenUnionWithUnreachable
testNarrowingLenAnyListElseNotAffected
testNarrowingLenMixWithAnyPrecise
testNarrowingLenMixWithAnyImprecise
# issubclass narrowing leads to Never entries instead of unreachable?
testIssubclassWithMetaclassesStrictOptional
# questionable implicit literal?
testEnumReachabilityChecksIndirect
# narrowing `in` weird overlapping. Mypy correct?
testTupleOverlapDifferentTuples
# isinstance error conditions
testLiteralErrorsWithIsInstanceAndIsSubclass
# isinstance with promotions will change outer types
testIntersectionUsingPromotion2
testIntersectionUsingPromotion5
testIntersectionUsingPromotion6
# type[any] issues
testIsInstanceWithUnknownType
testNarrowingWithTupleOfTypes
testNarrowingWithTupleOfTypesPy310Plus
# narrowing with Any weird cases
testIsinstanceNarrowAny
# isinstance with alias and union literals `isinstance(x, A | B)`
testTypeAliasWithNewUnionIsInstance
testStartUsingPEP604Union
# nonlocal
testNarrowedVariableInNestedFunctionMore1

# partials: OrderedDict
testInferOrderedDictInitializedToEmpty
# partials: defaultdict
testPartialDefaultDict*
# partials: No "Need type annotation for "X"", because untyped update exists
testInferDictInitializedToEmptyAndUpdatedFromMethodUnannotated
testCheckUntypedDefsSelf2
# partial for `x: Final = []`
testLiteralFinalErasureInMutableDatastructures2
# self.x = None in class is not partial anymore after finishing scope
testInferAttributeInitializedToNoneAndAssignedClassBody
# Mypy treats a None partial that is then assigned to a function as the function?? Wrong?
testRedefineFunctionDefinedAsVariableInitializedToNone
testRedefineNestedFunctionDefinedAsVariableInitializedToNone
# explicit any context should lead to Dict[Any, Any]? might be ok?
testGenericDictWithOverload

# self.x = self where self: T
testTypingSelfAttrOldVsNewStyle
# Cannot assign to a method when assigning `self.method = lambda: None`
testSlotsAssignmentWithMethodReassign

# "Value of type "A" must be used"
# "Value of type "Coroutine[Any, Any, None]" must be used"
# "Are you missing an await?"
# --enable-error-code unused-awaitable
testUnusedAwaitable
testForwardRefToBadAsyncShouldNotCrash_newsemanal
# Crazy types.coroutine types/async await matrix
testFullCoroutineMatrix

# "Cannot determine type of" probably fine
testThreePassesRequired
testAccessGlobalVarBeforeItsTypeIsAvailable
testAccessDataAttributeBeforeItsTypeIsAvailable
testMultipassAndTopLevelVariable
testForwardReferenceToDecoratedClassMethod
testAccessingClassAttributeWithTypeInferenceIssue
testClassObjectsNotUnpackableWithoutIterableMetaclass
testErrorCodeCannotDetermineType
testCannotDetermineTypeFromOtherModule
testColumnCannotDetermineType
testWalrusUsedBeforeDef
# "Cannot determine type of "X" in base class"
testCannotDetermineTypeInMultipleInheritance
# subtyping arbitrary length unpacks
testVariadicTupleSubtyping
# TypeVarTuple as unpacked varargs
testVariadicStarArgsCallNoCrash

# Name defined in parent scope
testListAssignmentUnequalAmountToUnpack
# Builtin overrides (Exception = Exception)
testConditionalExceptionAliasOverride

# "Type of TypedDict is ambiguous, none of ("A", "B") matches cleanly"
testUnionOfEquivalentTypedDictsDistinct
testUnionOfEquivalentTypedDictsNested
testTypedDictUnionAmbiguousCaseNoMatch
# TypedDict --extra-checks
testTypedDictUnpackStrictMode
testTypedDictStrictUpdate
testTypedDictFlexibleUpdateUnionStrict
testParamSpecConcatenateNamedArgs
testParamSpecPrefixSubtypingInvalidStrict
# TypedDict |
testTypedDictWith__or__method
testTypedDictWith__or__method_error
testTypedDictWith__ror__method
testTypedDictWith__ior__method
# Functional TypedDict in class def
testCanCreateClassWithFunctionBasedTypedDictBase
# TypedDict definition circle: A = TypedDict('A', {'a': 'A'})
testCrashOnSelfRecursiveTypedDictVar
testBasicRecursiveTypedDictCall
testRecursiveTypedDictWithList

# enum member gathering
testFinalWithMethodAssignment

# dataclass classmethod
testDataclassesClassmethods
testClassmethodShadowingFieldDoesNotCrash
testDeferredDataclassInitSignature
# dataclasses __slots__
testDataclassWithSlotsArg
# InitVar set default
testDataclassInitVarCannotBeSet
# dataclass weird replace case
testReplaceIsDataclass
# dataclass transform
updateDataclassTransformParameterViaDecorator
updateDataclassTransformParameterViaParentClass
updateBaseClassToUseDataclassTransform
frozenInheritanceViaDefault
testDataclassReplaceOptional
# dataclass __replace__
testDunderReplacePresent

# TypedDict Recursive definitions
testRecursiveNamedTupleTypedDict
# TypedDict Unpack
testUnpackKwargsInference
testUnpackKwargsParamSpec
# TypedDict dict unpacking
testTypedDictUnpackFromUnion
testTypedDictUnpackUnionRequiredMissing
testTypedDictUnpackIncompatible
# TypedDict Lookups
testTypedDictAsStarStarArgCalleeKwargs
testTypedDictAsStarStarAndDictAsStarStar
testTypedDictNonMappingMethods
# Nested typed dict formatting
testSerializeTypedDictInMethod
# TypedDict unions
testTypedDictChainedGetWithEmptyDictDefault

# multiline annotations
testMultilineQuotedAnnotation

# TypeAliasType
testTypeAliasType
testTypeAliasTypeInvalid
testTypeAliasTypeGeneric
testTypeAliasTypeInvalidGeneric
testTypeAliasTypeNoUnpackInTypeParams311
testTypeAliasTypePython311
# "Type aliases are prohibited in protocol bodies"
testTypeAliasInProtocolBody
# Weird and unsound mypy cases for x: typing.TypeAlias = ...
testClassLevelTypeAliasesInUnusualContexts
testMalformedTypeAliasRuntimeReassignments

# Protocol Self binding for metaclasses
testInferenceViaTypeTypeMetaclass
# Metaclass descriptor
metaclass_descriptor
# Metaclass iter/getitem/addition
testIterableProtocolOnMetaclass
# Metaclass instance vs. class members
testMetaclassConflictingInstanceVars
testInferenceOfDunderDictOnClassObjects

# Star import override of local scope
testImportStarWithinFunction
# Star import check what we override
testAssignAndConditionalStarImport
testStarImportOverlappingMismatch
# Star import redefinitions
testNewAnalyzerImportStarForwardRef1
testNewAnalyzerImportStarForwardRef2
testNewAnalyzerImportOverExistingInCycleStar1
testNewAnalyzerImportOverExistingInCycleStar2

# TypeVar defaults
testTypeVarDefaultsInvalid3
testTypeVarDefaultsClassRecursive1
testTypeVarDefaultsClassRecursiveMultipleFiles
testTypeVarDefaultsTypeAliasRecursive1
testTypeVarDefaultsTypeAliasRecursive2
# dataclass circles with bound
testDataclassGenericWithBound
testDataclassFactory

# lambda with generics
testInferenceAgainstGenericLambdas
testGenericLambdaGenericMethodNoCrash
testUninferableLambda
testUninferableLambdaWithTypeError
# lambda inferred: Cannot use a covariant type variable as a parameter
testRejectCovariantArgumentInLambda

# match statement
testValuePattern
testCapturePattern
testCapturePatternOutliving
testNestedCapturePatterns
testMappingPatternRest
testAsPattern
testGuard
testCapturePatternInGuard
testAsPatternInGuard
testMatchUndefinedSubject
testMatchUndefinedValuePattern
testMatchUndefinedClassPattern
testNoneBindingWildcardPattern
testNoneBindingStarredWildcardPattern

# TypeVar Values in func
testErrorCodeInvalidTypeArg
testCheckGenericFunctionBodyWithTypeVarValues
testCheckGenericFunctionBodyWithTypeVarValues2
testTypeInferenceAndTypeVarValues
testTypeDeclaredBasedOnTypeVarWithValues
testTypeVarValuesAndNestedCalls
testGenericTypeWithTypevarValuesAndTypevarArgument
testGenericTypeBodyWithTypevarValues
testAttributeInGenericTypeWithTypevarValues*
testMultipleClassTypevarsWithValues1
testGenericFunctionWithNormalAndRestrictedTypevar
testDefineAttributeInGenericMethodUsingTypeVarWithValues
testTypevarValuesSpecialCase1
testGenericTypeAliasesTypeVarConstraints
testWideOuterContextValuesOverlapping
testTypevarValuesWithOverloadedFunctionSpecialCase
testReferenceToDecoratedFunctionAndTypeVarValues
testLiteralAndGenericsRespectsValueRestriction
testTypeVarValuesFunction
testTypeVarValuesMethod1
testTypeVarValuesMethod2
testTypingSelfWithValuesExpansion
testOverloadingInferUnionReturnWithTypevarsAndValueRestrictions
testColumnFunctionWithTypeVarValues
testSuperWithTypeVarValues1
testSuperWithTypeVarValues2
testInnerFunctionWithTypevarValues
testInnerFunctionMutualRecursionWithTypevarValues
testNestedDecoratedCoroutineAndTypeVarValues
testAnyStr
testTypeVarWithTypedDictValueInIndexExpression
testReverseOperatorTypeVar2b
testIsinstanceAndTypeVarValues*
testIsinstanceWithUserDefinedTypeAndTypeVarValues
testIsinstanceWithUserDefinedTypeAndTypeVarValues
testIsinstanceWithUserDefinedTypeAndTypeVarValues2
testNarrowingIsSubclassFinalSubclassWithTypeVar
testTypeCheckOverloadImplementationTypeVarWithValueRestriction
testOperatorContainsNarrowsTypedDicts_total
testUnreachableFlagWithGenerics
testNarrowOnSelfInGeneric
testStrictEqualityDisabledWithTypeVarRestrictions
testIsInstanceAdHocIntersectionGenericsWithValues
testIsInstanceAdHocIntersectionGenericsWithValuesDirectReturn
testCallableTypeVarUnion

# ini config multiline
mypy_ini_exclude_multi_line_verbose_regex
mypy_ini_exclude_multi_line_verbose_regex_not_working

# ------------- Additional unimportant, but would be nice -----------------

# strict optional with config file
testPerFileStrictOptionalBasic
testPerFileStrictOptionalBasicImportStandard
testPerFileStrictOptionalListItemImportOptional
testPerFileStrictOptionalBasicPyProjectTOML
testPerFileStrictOptionalBasicImportStandardPyProjectTOML
testPerFileStrictOptionalListItemImportOptionalPyProjectTOML
testPerFileStrictOptionalModuleOnly
testPerFileStrictOptionalFunction
testPerFileStrictOptionalMethod
testNewAnalyzerTypeArgBoundCheckWithStrictOptional
testNewAnalyzerTypeArgBoundCheckWithStrictOptionalPyProjectTOML
testPerFileStrictOptionalModule
testStrictOptionalCovarianceCrossModule
# Uses an environment variable in mypy.ini files=$MYPY_CONFIG_FILE_DIR/good.py
testEnvvar_MYPY_CONFIG_FILE_DIR

# "NamedTuple type as an attribute is not supported"
testAssignNamedTupleAsAttribute
testNoCrashUnsupportedNamedTuple
# "Enum type as attribute is not supported"
testAssignEnumAsAttribute
# "TypedDict type as attribute is not supported"
testAssignTypedDictAsAttribute

# Tuple type comment definitions with list assignment
testMultipleAssignmentWithListsInInitialization
testAssignmentToStarAnnotation
# Tuple type comment with None should not be checked like x, y = None, None  # type: int, str
testMultipleAssignmentNoneClassVariableInInit
# star input for tuple
testTupleWithStarExpr
# List literal inference that works like a tuple? (x, y) = [1, ""]
testInferringLvarTypesInNestedListAssignment
testNestedListAssignment
testNestedListAssignmentToTuple
testMultiModuleAlias
# Tuple a, *li = ta: "List item 0 has incompatible type "A"; expected "int""
testAssignmentToStarFromTupleType
# empty tuple as iterator ("Need type annotation for "x"")
testAssignmentToStarMissingAnnotation
testForLoopOverEmptyTuple
# tuple call tuple() leads to tuple[Any, ..] in Mypy, but is probably not technically wrong here
testTupleCompatibleWithSequence

# Type var constraints not enforced in type alias
testValidTypeAliasValues

# functools.partial
testFunctoolsPartialBasic
testFunctoolsPartialStar
testFunctoolsPartialGeneric
testFunctoolsPartialCallable
testFunctoolsPartialTypeGuard
testFunctoolsPartialType
testFunctoolsPartialTypeVarTuple
testFunctoolsPartialUnion
testFunctoolsPartialTypeObject
testIncrementalFunctoolsPartial
testFunctoolsPartialTypedDictUnpack
testFunctoolsPartialExplicitType
testFunctoolsPartialNestedPartial
testFunctoolsPartialNestedGeneric
testFunctoolsPartialClassObjectMatchingPartial
testFineGrainedFunctoolsPartial

# 3.12 type var syntax
test695TypeAlias
test695Class
test695Function
test695TypeVar
test695TypeAliasType
testPEP695*
testCurrentClassWorksAsBound

# enum.member / enum.nonmember
testEnumNonMemberSupport
testEnumMemberSupport

# Forward name binder reference in class
testNewAnalyzerNamedTupleCallNested
# class binder questionable types in class body
testRefMethodWithDecorator
# str methods vs. str annotations, when do we use which type
testNewAnalyzerAnnotationConflictsWithAttributeSinglePass
testNewAnalyzerAnnotationConflictsWithAttributeTwoPasses
testNewAnalyzerNameConflictsAndMultiLineDefinition
# forwards references/type comments name binding of type definitions within function scopes
testForwardBoundFunctionScopeWorks
testIncrementalNestedTypeAlias
testSerializeNamedTupleInMethod4
testDeclarationReferenceToNestedClass
testNewAnalyzerNamedTupleCallNestedMethod
testGenericClassWithinFunction
testGenericClassWithInvalidTypevarUseWithinFunction
# Recursive alias forward reference in class scope
testRecursiveClassLevelAlias

# Assignment like ac[b] += c with both __getitem__ and __setitem__ has same error twice
testOperatorAssignmentWithIndexLvalue1

# NotImplemented
testReturnAnyForNotImplementedInNormalMethods

# NewType in function "A@6" as qualified name
testNewTypeInLocalScope
# qualified name in function contains class path: __main__.Cls.FooEnum@4
testAnonymousFunctionalEnum
testNewAnalyzerIncrementalMethodNamedTuple
testNewAnalyzerNamedTupleClassNestedMethod
testNoIncrementalCrashOnTypedDictMethod
# Nicer Callable Errors
testCallableParsingFromExpr
testCallableParsing
testCallableTooManyVarArg
testCallableKindsOrdering
testCallableFastParseBadArgArgName
# Separate formatting for ambigous names???
testIncompatibleAssignmentAmbiguousShortnames
# for long tuples: "Expression tuple item 8 has type "str"; "int" expected;"
testAssigningWithLongTupleInitializer
# large union formatting like "Incompatible types in assignment (expression has type "C1 | C2 | C3 | C4 | C5 | <6 more items>", variable has type "int")"
testLargeUnionsShort
testLargeUnionsLongIfNeeded
testLargeUnionsNoneShown

# "Call to abstract method "meth" of "Proto" with trivial body via super() is unsafe"
testEmptyBodyUnsafeAbstractSuper
testEmptyBodyUnsafeAbstractSuperOverloads
testEmptyBodyUnsafeAbstractSuperProperty
testErrorCodeUnsafeSuper_no_empty
testAbstractBodyTurnsEmpty
testAbstractBodyTurnsEmptyProtocol
testAbstractBodyTurnsEmptyCoarse
testSuperWithAbstractProperty
testEmptyBodyNoSuperWarningWithoutStrict
testEmptyBodyNoSuperWarningOptionalReturn
testIgnoreErrorsWithUnsafeSuperCall_no_empty
testMixinProtocolSuper
# "Only concrete class can be given where "Type[C]" is expected"
testDedicatedErrorCodeTypeAbstract
testAbstractTypeInADict
testInstantiationAbstractsInTypeForFunctions
testInstantiationAbstractsInTypeForAliases
# "Can only assign concrete classes to a variable of type "Type[A]""
testInstantiationAbstractsInTypeForVariables
testInstantiationProtocolInTypeForVariables
# Dictionary part of abstract class: "Cannot instantiate abstract class "C" with abstract attribute "f""
testSubclassOfABCFromDictionary
# Mapping[str, str](): "Cannot instantiate abstract class "Mapping" with abstract attribute "...""
testAbstractNewTypeAllowed

# Module <M> has no attribute <missing_name>; maybe <name>
testNewAnalyzerTypeAnnotationCycle3
testModuleAttributeTwoSuggestions
testModuleAttributeThreeSuggestions
testImportMisspellingSingleCandidate
testImportMisspellingMultipleCandidates
testImportMisspellingMultipleCandidatesTruncated
testColumnHasNoAttribute
testErrorCodeNoAttribute
testDequeWrongCase
# "C" has no attribute "__aenter__"; maybe "__enter__"?
testAsyncWithError
# Unexpected keyword argument "otter" for "f"; did you mean "other"?
testMultipleKeywordsForMisspelling
testKeywordMisspelling*
# "TypedDict "XXX" has no key "xxx" note: Did you mean "type"?"
testCannotGetItemOfTypedDictWithInvalidStringLiteralKey
# "Perhaps you need a type annotation for "x"? Suggestion: "List[str | int]""
testInferredTypeSubTypeOfReturnType

# `import a.b # type: ignore` means that the attribute is later Any without error
testAddedMissingStubsIgnorePackagePartial
testFineAddedMissingStubsIgnorePackagePartial
# ignore_missing_imports in Mypy overrides ignores import errors if those modules are not presents
testModuleGetattrInit10
testIgnoreErrorFromMissingStubs2
testModuleGetattrInit10PyProjectTOML
testMultipleModulesInOverridePyProjectTOML

# __init__ None needed
testInitReturnTypeError
# "Accessing "__init__" on an instance is unsound, since instance.__init__ could be from an incompatible subclass"
testAccessingInit
# "Unsupported decorated constructor type"
testDecoratedConstructorsBad
# type.__init__ where self is implicitly Any
testTypeEquivalentTypeAnyEdgeCase

# __init_subclass__
testOverride__init_subclass__WithDifferentSignature
testInitSubclassWrongType
testInitSubclassTooFewArgs
testInitSubclassTooFewArgs2
testInitSubclassWithImports
testTooManyArgsForObject
testNoClassKeywordsForNamedTuple
testTypedDictWithClassLevelKeywords

# - The implementation for an overloaded function must come last
testInconsistentOverload
testInconsistentOverload2
# Non consecutive overloads
testNonconsecutiveOverloads
testNonconsecutiveOverloadsMissingFirstOverload
testNonconsecutiveOverloadsMissingLaterOverload
# @overload: "Condition cannot be inferred, unable to merge overloads"
testOverloadIfSplitFunctionDef
testOverloadIfMixed
testOverloadIfUnconditionalFuncDef
testOverloadIfBasic
testOverloadIfNotMerging
testOverloadIfElse
testOverloadIfElse2
testOverloadIfElse3
testOverloadIfSkipUnknownExecution
testOverloadIfDontSkipUnrelatedOverload
testOverloadIfNotMergingDifferentNames
testOverloadIfNestedOk
testOverloadIfNestedFailure

# type ignore leads to "Revealed type is "A?""
testSerializeIgnoredInvalidType
# bad type: ignore
testErrorCodeBadIgnore
testErrorCodeBadIgnoreNoExtraComment
# --warn-unused-ignores
# "Unused "type: ignore" comment"
testErrorCodeWarnUnusedIgnores1
testErrorCodeWarnUnusedIgnores2
testErrorCodeWarnUnusedIgnores3
testErrorCodeWarnUnusedIgnores4
testErrorCodeWarnUnusedIgnores5
testErrorCodeWarnUnusedIgnores6_NoDetailWhenSingleErrorCode
testMethodAssignCoveredByAssignmentUnused
testUnusedIgnoreTryExcept
testUnusedIgnoreEnableCode
testIgnoreDecoratedFunction1
testIgnoreScopeUnused1
testIgnoreScopeUnused2
testIgnoreScopeUnused3
testUnusedIgnoreVersionCheck
testUnusedTypeIgnore
testUnusedTypeIgnoreImport
# --warn-unused-ignores whole module
testIgnoreWholeModule1
testImportUnusedIgnore2
# --enable-error-code ignore-without-code
testErrorCodeMissingWhenRequired
testErrorCodeMissingDoesntTrampleUnusedIgnoresWarning
testErrorCodeMissingWholeFileIgnores
testErrorCodeMissingMultiple
testInlineErrorCodes
testInlineErrorCodesMultipleCodes
testInlineErrorCodesOverrideConfig
testPerModuleErrorCodesOverride
# type: ignore blocking errors cannot be ignored: ""yield" outside function"
testCannotIgnoreBlockingError
# type: ignore on forward reference
testErrorCodeSyntaxErrorIgnoreNote
# type: ignore on call silences errors in call, even if not on same line?!
testMultiLineMethodOverridingWithIncompatibleTypesIgnorableAtDefinition
# Error code "literal-required" not covered by "type: ignore" comment
testNoteAboutChangedTypedDictErrorCode

# "mypy: "tmp/typing.py" shadows library module "typing""
testShadowTypingModule

# Module __all__
testAllMustBeSequenceStr

# --show-column-numbers and tuple targets
testColumnsAssignment

# --enable-error-code explicit-override "Method "prop" is not using @override but is overriding a method in class "__main__.A""
requireExplicitOverrideOverload

# "Static methods cannot use Self type"
testTypingSelfClassMethod

# "Incompatible types in string interpolation (expression has type "str", placeholder has type "int")"
testErrorCodeFormatCall

# "Duplicate argument "x" in function definition"
testFastParserDuplicateNames
# Lambda inferred like (lambda x: x)(1)
testInferLambdaTypeUsingContext
# Generator in lambda
testNoCrashOnLambdaGenerator

# tuple type is not initializable (though it probably should)
testTypeUsingTypeCErrorUnsupportedType
testTypeUsingTypeCTuple

# ""break" outside loop" for untyped functions
testBreakOutsideLoop
testNoCrashOnBreakOutsideLoopFunction
testNoCrashOnBreakOutsideLoopClass
testContinueOutsideLoop

# "Maybe you forgot to use "await"?" (currently ignored)
#testAsyncForErrorNote
#testAwaitMissingNote
#testAsyncForErrorNote

# - (with type vars) Overloaded function signatures 2 and 3 overlap with incompatible return types
#testOverloadMultipleVarargDefinitionComplex
#testOverloadPartialOverlapWithUnrestrictedTypeVar
#testOverloadPartialOverlapWithUnrestrictedTypeVarNested
#testOverloadedPartiallyOverlappingTypeVarsAndUnion
# Overlapping general
#testManyUnionsInOverload
#testOverloadInferUnionReturnFunctionsWithKwargs
#testOverloadWithOverlappingItemsAndAnyArgument5
#testIntersectionTypesAndVarArgs
#testLiteralInferredInOverloadContextWithTypevars
#testLiteralSubtypeOverlap
#testOverloadsAndNoneWithoutStrictOptional
#testOverloadsAndNoneWithStrictOptional
#testTypeTypeOverlapsWithObjectAndType
#testTypeOverlapsWithObject
#testAccessingGenericDescriptorFromInferredClass
#testAccessingGenericDescriptorFromClass
#testOverloadWithNonGenericDescriptorLookalike
#testOverloadWithGenericDescriptor
#testUnpackIterableClassWithOverloadedIter2
testOverloadOverlapWithTypeVarsWithValues
testUnsafeOverlappingNotWithAny
# Overlap + "N: Flipping the order of overloads will fix this error"
#testTypeCheckOverloadImplementationTypeVarDifferingUsage2
#testOverloadPossibleOverlapMixingNamedArgsWithKwargs3
#testOverloadWithPartiallyOverlappingUnionsNested
#testOverloadedPartiallyOverlappingTypeVarsAndUnion
#testAwaitOverloadSpecialCase

# ------------------- priority? tests -----------------------

# All members in a union lead to the enum again
testEnumTypeCompatibleWithLiteralUnion
# Enum Dict value inferred is int instead of Literal[1]
testFunctionalEnumListOfPairs

# Recursive aliases that fail to resolve because imports are calculating
check-incremental:testRecursiveAliasImported
check-recursive-types:testRecursiveAliasImported
testTypeAliasUpdateNonRecursiveToRecursiveFine
testTypeAliasUpdateNonRecursiveToRecursiveCoarse

# future imports (future is not part of stubs)
testNewAnalyzerMetaclassFuture1
testNewAnalyzerMetaclassFuture3
testNewAnalyzerMetaclassFuture4
testFutureMetaclass
testFromFutureMetaclass
testFutureMetaclassImportFrom
testFutureMetaclassImport
testFutureMetaclassAndBase
testFutureMetaclassGenerics
testFutureMetaclassErrors
testFutureMetaclassAny
# six imports
testNewAnalyzerMetaclassSix1
testNewAnalyzerMetaclassSix2
testNewAnalyzerMetaclassSix3
testNewAnalyzerMetaclassSix4
testSixMetaclassImportFrom
testSixMetaclassImport
testSixMetaclassAndBase
testSixMetaclassGenerics
testSixMetaclassErrors
testSixMetaclassAny
testSixMetaclass
testFromSixMetaclass
testSixMetaclassGenericBase
testIgnoreInsideClassDoesntAffectWhole
# import of typeshed stubs
testErrorFromGoogleCloud

# typing.assert_type in untyped functions
testAssertTypeUncheckedFunction
testAssertTypeUncheckedFunctionWithUntypedCheck
# "Only @runtime_checkable protocols can be used with instance and class checks" in untyped functions
testOverloadOnProtocol
# function type mismatch when untyped
testSubtypingFunctionsImplicitNames

# Probably fixed eventually by updating mypy or typeshed
testDecoratorTypeAfterReprocessing

# attrs
testAttrs*
updateMagicField
magicAttributeConsistency
magicAttributeConsistency2-only_when_cache
testDisallowIncompleteDefsAttrsNoAnnotations
testDisallowIncompleteDefsAttrsWithAnnotations
testDisallowIncompleteDefsAttrsPartialAnnotations

# ctypes
testCtypesArrayStandardElementType
testCtypesArrayCustomElementType
testCtypesArrayUnionElementType
testCtypesCharArrayAttrs
testCtypesWcharArrayAttrs
testCtypesCharUnionArrayAttrs
testCtypesAnyUnionArrayAttrs
testCtypesOtherUnionArrayAttrs
testCtypesOtherArrayAttrs

# singledispatch
testIncorrectDispatchArgumentWhenDoesntMatchFallback
testCheckNonDispatchArgumentsWithTypeAlwaysTheSame
testImplementationHasSameDispatchTypeAsFallback-xfail
testRegisterHasDifferentTypeThanTypeSignature-xfail
testTypePassedAsArgumentToRegister
testCustomClassPassedAsTypeToRegister
testOnePartOfUnionDoesNotHaveCorrespondingImplementation
testIncorrectArgumentsInSingledispatchFunctionDefinition
testDispatchTypeIsNotASubtypeOfFallbackFirstArgument
testAnyInConstructorArgsWithClassPassedToRegister
testIncorrectArgumentTypeWhenCallingRegisteredImplDirectly
testDontCrashWhenRegisteringAfterError

# OrderedDict = _Alias()
testTypingExtensionsOrderedDictAlias

# --enable-incomplete-feature=PreciseTupleTypes
testTupleWithStarExpr2Precise
testTupleWithStarExpr3Precise
testVariadicTupleConcatenation
testPackingVariadicTuplesHomogeneous
testVariadicTupleContextNoCrash
testVariadicTupleInTupleContext

# Not all modules are checked in mypy: `# cmd: mypy -m m`
testTypeCheckNamedModule4
testTypeCheckNamedModule5
testTypeCheckNamedModuleWithImportCycle
testStubImportNonStubWhileSilent
# cmd: mypy a.py
testErrorInReAddedModule
testFollowImportsNormalPackageInitFileStub
# Not all modules are checked even in default mypy
testPreferPackageOverFile
testPreferPackageOverFile2
testNotPreferPackageOverFileCase
testFollowImportsNormalDeleteFile4
testFollowImportsNormalDeleteFile5
testFollowImportsNormalDeleteFile6
testFollowImportsNormalDeleteFile7
testSubmoduleMixingImportFromAndImport
testSubmoduleImportFromDoesNotAddParents

# import missing --follow-imports=normal
testIncrementalNestedBrokenCascade
# --follow-imports=error
testImportSuppressedWhileAlmostSilent
testAncestorSuppressedWhileAlmostSilent
testErrorButDontIgnore1
testErrorButDontIgnore2
testErrorButDontIgnore3-skip
testErrorButDontIgnore4
testIncrementalFollowImportsError
testFollowImportsError
# --follow-imports=silent
testIncrementalFollowImportsSilent
testIncrementalWithSilentImports
testFollowImportsSilent
# --follow-imports=skip
testIncrementalUnsilencingModule
testIncrementalWithSilentImportsAndIgnore
testIncrementalSilentImportsWithBlatantError
testIncrementalImportIsNewlySilenced
testIncrementalSilencedModuleNoLongerCausesError
testIncrementalFollowImportsSkip
testFollowImportSkipNotInvalidatedOnAddedStubOnFollowForStubs
testAddedSkippedStubsPackageFrom
testAddPackage6
testAddPackage7
testSkipImports
testSkipImportsWithinPackage
testSkipButDontIgnore1
testSkipButDontIgnore2
testFineFollowImportSkipInvalidatedOnAddedStub-skip
testFineAddedSkippedStubsPackageFrom
testFileAddedAndImported
testFileAddedAndImported2
testDeleteFileWithErrors
testDoNotFollowImportToNonStubFile
testFollowImportsSkip
testSubclassingAnySilentImports
testSubclassingAnySilentImports2
testIncrementalFollowImportsVariable
testIncrementalFollowImportsVariablePyProjectTOML
testClassScopeImportWithFollowImports
testMissingSubmoduleImportedWithIgnoreMissingImportsStub
# --no-site-packages
testTypedPkg_config_nositepackages
testTypedPkg_args_nositepackages
testTypedPkgNoSitePkgsIgnoredImports
# "Skipping analyzing "typedpkg_ns.b.bbb": module is installed, but missing library stubs or py.typed marker"
testNamespacePkgWStubs
# __import__("pkg_resources").declare_namespace(__name__)
testNamespacePkgWStubsWithNamespacePackagesFlag

# --enable-error-code redundant-self
# "Redundant "Self" annotation for the first method argument"
testTypingSelfRedundantWarning
testTypingSelfRedundantWarning_pep585
# --enable-error-code redundant-expr
# "If condition is always false"
testRedundantExpressions
# flags: --enable-error-code truthy-bool
testTruthyBool
testTruthyFunctions
testTruthyIterable
# flags: --disable-error-code truthy-bool
testDisableEnableErrorCodesIncremental
# flags: --enable-error-code=mutable-override: "Covariant override of a mutable attribute (base class "C" defined the type as "float", expressi on has type "int")"
testCovariantMutableOverride
# flags: --allow-untyped-globals
testPermissiveAttributeOverride1

# "Method cannot have explicit self annotation and Self type"
testTypingSelfConflict

# ------------------- start of low-prio/won't do tests -----------------------

# "Name "C" is used before definition"
testBanPathologicalRecursiveTuples
testDefinedDifferentBranchUsedBeforeDef
testUsedBeforeDefBuiltinsGlobal
testUsedBeforeDefBuiltinsMultipass
testUsedBeforeDefImplicitModuleAttrs
# --enable-error-code possibly-undefined "Name "x" may be undefined"
testPossiblyUndefinedWithAssignmentExpr
check-possibly-undefined:testDefinedInOneBranch
check-possibly-undefined:testElif
check-possibly-undefined:testUsedInIf
check-possibly-undefined:testOmittedElse
check-possibly-undefined:testUpdatedInIf
check-possibly-undefined:testNestedIf
check-possibly-undefined:testVeryNestedIf
check-possibly-undefined:testTupleUnpack
check-possibly-undefined:testIndexExpr
check-possibly-undefined:testFunction
check-possibly-undefined:testLambda
check-possibly-undefined:testUsedBeforeDefClass
check-possibly-undefined:testGenerator
check-possibly-undefined:testScope
check-possibly-undefined:testVarFromOuterScopeRedefined
check-possibly-undefined:testWhile
check-possibly-undefined:testForLoop
check-possibly-undefined:testReturn
check-possibly-undefined:testPossiblyUndefinedLoop
check-possibly-undefined:testAssert
check-possibly-undefined:testRaise
check-possibly-undefined:testContinue
check-possibly-undefined:testBreak
check-possibly-undefined:testTryBasic
check-possibly-undefined:testTryMultiExcept
check-possibly-undefined:testTryFinally
check-possibly-undefined:testTryElse
check-possibly-undefined:testDictComprehension
check-possibly-undefined:testUntypedDefCheckUntypedDefs
check-possibly-undefined:testClassBody
check-possibly-undefined:testUntypedDef
check-possibly-undefined:testNoReturn

# `for ... in` type comment
testRefreshForWithTypeComment1
testRefreshForWithTypeComment2
testForStatementTypeComments
testForStatementMultipleTypeComments
testForIndex
testForIndexInClassBody
testErrorCodeSyntaxError3
testAsyncForTypeComments
# with type comment
testWithStmt
testWithStmtInClassBody
testWithStmtTypeComment
testWithStmtTupleTypeComment
testWithStmtComplexTypeComment
testAsyncWithTypeComments
testNewAnalyzerTypeArgBoundCheckDifferentNodes
testForwardRefsInWithStatement

# binder probably deferred issues
testLocalPartialTypesWithNestedFunction3

# "note: "f" is implicitly abstract because it has an empty function body. If it is not meant to be abstract, explicitly `return` or `return None`."
testEmptyBodyNoneCompatibleProtocol
# "note: Looks like the first special argument in a method is not named "self", "cls", or "mcs", maybe it is missing?"
testErrorMessageAboutSelf

# "unknown encoding: uft-8"
testInvalidEncoding
testInvalidEncoding2
testInvalidEncoding3
testDoubleEncoding
testDoubleEncoding2
# coding: ascii
testDecodeErrorBlocker1-posix
testDecodeErrorBlocker2-windows
testDecodeErrorBlockerOnInitialRun-posix

# "Syntax error in type annotation"
# Suggestion: Use tuple[T1, ..., Tn] instead of (T1, ..., Tn)
testImplicitTuple2
# "Suggestion: Use tuple[()] instead of () for an empty tuple, or None for a function without a return value"
testReturnEmptyTuple
# "Suggestion: Is there a spurious trailing comma?"
testColumnSyntaxErrorInTypeAnnotation
# Syntax error in type comment, because used `# type:` twice
testErrorCodeTypeIgnoreMisspelled2
# SyntaxError "Assignment expression within a comprehension cannot be used in a class body"
testNoCrashOnAssignmentExprClass

# invalid syntax, and therefore name errors, names should probably be Any
testModifyTwoFilesOneWithBlockingError1
testModifyTwoFilesOneWithBlockingError2
testModifyTwoFilesIntroduceTwoBlockingErrors

# All of these are really not important at all, because there are syntax
# errors, just not the fancy ones.
# Too many invalid syntax errors?
testInvalidFunction
testInvalidFuncDefArgs3
testInvalidFuncDefArgs4
testExceptCommaInPython3
# "unexpected indent"
testUnexpectedIndent
testInconsistentIndent
# "unindent does not match any outer indentation level"
testInconsistentIndent2
# "unexpected EOF while parsing"
testUnexpectedEof
testParseErrorInExtendedSlicing
testParseErrorInExtendedSlicing2
testParseErrorInExtendedSlicing3
# "positional argument follows keyword argument"
testInvalidKeywordArguments1
# "positional argument follows keyword argument unpacking"
testInvalidKeywordArguments2
# "named arguments must follow bare *"
testInvalidBareAsteriskAndVarArgs4
testInvalidBareAsterisk1
testInvalidBareAsterisk2
# "non-default argument follows default argument"
testInvalidFuncDefArgs1
# "invalid syntax. Perhaps you forgot a comma?"
testNotAsBinaryOp
testBinaryNegAsBinaryOp
testErrorCodeSyntaxError
testUpdateClassReferenceAcrossBlockingError
testAddFileWithBlockingError
testBlockingErrorRemainsUnfixed
testDeleteFileWithBlockingError-only_when_nocache
testDeleteFileWithBlockingError2-only_when_cache
testModifyFileWhileBlockingErrorElsewhere
testInitialBlocker
# "cannot delete function call"
testInvalidDel1
# "cannot delete expression"
testInvalidDel2
# "cannot assign to function call here. Maybe you meant '==' instead of '='?"
testInvalidLvalueWithExplicitType
testInvalidTypeDeclaration
# "Cannot assign to literal"
testInvalidWithTarget
# "cannot assign to literal here. Maybe you meant '==' instead of '='?"
testInvalidLvalues*
testInvalidTypeAnnotation2
# "cannot delete expression"
testDelMultipleThingsInvalid
# "Missing parentheses in call to 'print'. Did you mean print(1)?"
testPrintStatementInPython3
# "invalid character in identifier"
testSmartQuotes
# "expected ':'"
testParseError
testParseErrorMultipleTimes
testBlockingErrorWithPreviousError

# Needs lib-stub/blocker.pyi
testImportBringsAnotherFileWithBlockingError1
testImportBringsAnotherFileWithSemanticAnalysisBlockingError
testFixingBlockingErrorBringsInAnotherModuleWithBlocker

# "Not all union combinations were tried because there are too many unions"
testTooManyUnionsException

# Note ""<Foo>.__call__" has type "Callable[[Arg(str, 'x'), VarArg(int)], None]"
# Curently ignored

# Additional questionable cases of "Signatures of "__ior__" and "__or__" are incompatible"
testGenericOperatorMethodOverlapping2
testOverloadedNormalAndInplaceOperatorMethod

# Mypy is probably wrong here, but we might need to revisit
testConstructorJoinsWithCustomMetaclass

# Final Literal[str] = "foo" is suddenly a Literal['foo']?
testEnumCreatedFromFinalValue

# "Access to generic class variables is ambiguous" (unimportant, because similar lint exists)
testClassVarWithGeneric
testClassVarWithNestedGeneric
# ""foo" is considered instance variable, to make it class variable use ClassVar[...]"
testSuggestClassVarOnTooFewArgumentsMethod

# Create a class with a base class based on Type[..] of self.foo
testNewAnalyzerUnsupportedBaseClassInsideFunction

# type checking ok, priority low "Cannot assign multiple modules to name "..." without explicit "types.ModuleType" annotation"
testModuleAliasRepeated
testModuleAliasRepeatedComplex
testModuleAliasToOtherModule
testModuleAliasToQualifiedImport2

# NameBinder questionable unreachable usages
testRaiseStatement
reachability_no_mypy_compatible

# My own hard/special tests
class_context_super_class
namedtuple__new__
generic_method_on_class_access_no_overload
generic_method_on_class_access_overload
type_type_alias_circular

# Weird native types of mypy like `from mypy_extensions import i64, i32`
testNativeIntTypes

# --enable-incomplete-feature=InlineTypedDict
testTypedDictInlineYesNewStyleAlias
testCannotCreateTypedDictInstanceWithInlineTypedDict
testTypedDictInlineNoOldStyleAlias
testTypedDictInlineYesMidStyleAlias
testTypedDictInlineNotRequired
testTypedDictInlineNestedSchema
testTypedDictInlineMergeAnother

# Mypy plugins
testChangedPluginsInvalidateCache
testChangedPluginsInvalidateCache2
testAddedPluginsInvalidateCache
testRemovedPluginsInvalidateCache
testPluginConfigData
testIncrementalAddClassMethodPlugin
testIncrementalAddOverloadedMethodPlugin

# Won't support for now --show-error-code-links
testShowErrorCodeLinks

# --allow-redefinition
testUnusedTargetNotClass
testFinalReassignModuleVar
testFinalReassignModuleVar2
testReusingInferredForIndex2
# module __getattr__ is considered a redefinition
testModuleLevelGetattrImportFromAsTwice

# --no-strict-optional details
testUnreachableWhenSuperclassIsAnyNoStrictOptional
testUnreachableWithStdlibContextManagersNoStrictOptional
testInitializationWithMultipleValues
testNoneAndGenericTypesOverlapNoStrictOptional
testNamedTupleAsConditionalStrictOptionalDisabled
testOptionalIterator
testDescriptorAccessForUnionOfTypesWithNoStrictOptional
testMeetOfIncompatibleProtocols
testIssubclassWithMetaclasses
testImportAndAssignToModule
testSerializeDummyType

# --untyped-calls-exclude=bar.A
testDisallowUntypedCallsAllowListFlags
testDisallowUntypedCallsAllowListConfig

# --disallow-any-expr
testDoNotLimitErrorVolumeIfNotImportErrors
testDisallowAnyExprIncremental
testDisallowAnyExprUnannotatedFunction
testDisallowAnyExprSimple
testDisallowAnyExprExplicitAnyParam
testDisallowAnyExprAllowsAnyInCast
testDisallowAnyExprAllowsAnyInVariableAssignmentWithExplicitTypeAnnotation
testDisallowAnyExprGeneric

# --disallow-any-unimported
testErrorCodeAnyFromUnfollowedImport
testDisallowImplicitTypesIgnoreMissingTypes
testDisallowImplicitTypes
testDisallowImplicitAnyVariableDefinition
testDisallowImplicitAnyGeneric
testDisallowImplicitAnyInherit
testDisallowImplicitAnyAlias
testDisallowImplicitAnyCast
testDisallowImplicitAnyNamedTuple
testDisallowImplicitAnyTypeVarConstraints
testDisallowImplicitAnyNewType
testDisallowImplicitAnyCallableAndTuple
testDisallowImplicitAnySubclassingExplicitAny
testDisallowImplicitAnyVarDeclaration
testDisallowUnimportedAnyTypedDictSimple
testDisallowUnimportedAnyTypedDictGeneric
testNoCrashOnUnImportedAnyNotRequired
testTypedDictRequiredUnimportedAny

# --no-namespace-packages
testClassicNotPackage
testPackageWithoutInitFile
testDeletePackage4
testDeletePackage5
testDeletePackage6

# --soft-error-limit
testLimitLegacyStubErrorVolume

# --show-error-context
testNewAnalyzerTypeArgBoundCheckWithContext
testShowErrorContextFunction
testShowErrorContextClass
testShowErrorContextMember
testShowErrorContextModule
testShowErrorContextTopLevel
testShowErrorContextFromHere

# --pretty
testReprocessMethodShowSource
testGenericTypeAliasesWithNestedArgs
testPrettyMessageSorting
testParseErrorShowSource
testDictExpressionErrorLocations

# --no-silence-site-packages
testAddFileWhichImportsLibModuleWithErrors

# Probably won't support: Special mypy extensions
testFlexibleAlias1
testFlexibleAlias2
testFlexibleAlias3

# Won't support for now: "t" is a type variable and only valid in type context
testExpressionRefersToTypeVariable

# Won't support for now: "Use `from typing_extensions import _FutureFeatureFixture` instead"
testTypingExtensionsSuggestion

# Probably won't support: invalid version numbers for # flags: --python-version 3.99
testFeatureVersionSuggestion

# Probably won't support: NamedTuple subclass narrowing, this won't be
# supported, once PreciseTupleTypes is a complete feature.
testNarrowingLenTupleSubclass

# Probably won't support: typing._promote
testListWithDucktypeCompatibility
testListWithDucktypeCompatibilityAndTransitivity
testSimpleDucktypeDecorator
testDucktypeTransitivityDecorator
testOverloadingAndDucktypeCompatibility

# Probably won't support: Type comments for params
testFastParsePerArgumentAnnotations
testFastParsePerArgumentAnnotationsWithReturn
testFastParsePerArgumentAnnotationsWithAnnotatedBareStar
testFastParsePerArgumentAnnotationsWithReturnAndBareStar

# Tuple comment syntax: Incompatible number of tuple items
testVariableDeclWithInvalidNumberOfTypes
testVariableDeclWithInvalidNumberOfTypesNested
testVariableDeclWithInvalidNumberOfTypesNested2
testVariableDeclWithInvalidNumberOfTypesNested4
# Tuple comment syntax: tuple type expected for multiple variables
testVariableDeclWithInvalidType
testVariableDeclWithInvalidNumberOfTypesNested3
testVariableDeclWithInvalidNumberOfTypesNested5
# Won't support: Signature Comments
testIncompatibleSignatureInComment
testFunctionSignatureAsComment
testMethodSignatureAsComment
testVarArgsAndCommentSignature
testKeywordArgumentAndCommentSignature
testKeywordArgumentAndCommentSignature2
testKeywordVarArgsAndCommentSignature
testWrongNumberOfArguments
testNestedFunctionInMethodWithTooFewArgumentsInTypeComment
testDeepNestedFunctionWithTooFewArgumentsInTypeComment
testDeepNestedMethodInTypeComment
testEllipsisWithArbitraryArgsOnBareFunctionWithKwargs
testEllipsisWithArbitraryArgsOnBareFunctionWithVarargs
testEllipsisWithSomethingAfterItFails
testEllipsisWithSomethingBeforeItFails
testMethodDefaultArgumentsAndSignatureAsComment
testDefaultArgumentsAndSignatureAsComment
testLiteralInsideOtherTypesTypeCommentsPython3
testLiteralInvalidTypeComment
testLiteralInvalidTypeComment2
testInferOptionalFromDefaultNoneComment
testNoInferOptionalFromDefaultNoneComment
testCheckUntypedDefsSelf1
testOperatorDoubleUnionDivision
testFasterParseTooManyArgumentsAnnotation
testFasterParseTooFewArgumentsAnnotation
testFastParserShowsMultipleErrors
testFastParserConsistentFunctionTypes
testErrorCodeInvalidCommentSignature
testErrorCodeIgnoreAfterArgComment
testColumnsMethodDefaultArgumentsAndSignatureAsComment
testColumnTypeSignatureHasTooFewArguments
testInvalidSignatureInComment*
testDuplicateSignatures1
testDuplicateSignatures2
testTooManyTypes
testTooFewTypes
testCommentFunctionAnnotationVarArgMispatch-skip
testCommentFunctionAnnotationVarArgMispatch2-skip
testErrorCodeSyntaxError2
testFastParseFunctionAnnotationSyntaxError
testFastParseFunctionAnnotationSyntaxErrorSpaces
testFastParseInvalidFunctionAnnotation

# --scripts-are-modules
testScriptsAreModules

# --custom-typeshed-dir 
testIgnoreErrorsFromTypeshed

# cmd: mypy ...
testNonExistentFileOnCommandLine1
testInlineConfigFineGrained1
testInlineConfigFineGrained2
testNoCrashOnDeletedWithCacheOnCmdline
testFollowImportsNormalSearchPathUpdate-only_when_nocache
testFollowImportsNormalSearchPathUpdate2-only_when_cache
testAddNonPackageSubdir
testAddPackage5
testScriptsAreNotModules

# Won't do: Type Vars qualified names -> comes from visit_Attribute and is not really qualified, but the expr name
testQualifiedTypeVariableName
testPartiallyQualifiedTypeVariableName
testSerializeSimpleTypeVar
testSerializeBoundedTypeVar
testSerializeTypeVarWithValues
testSerializeTypeVarInClassBody

# Won't support: __eq__ called directly with a keyword argument (which is actually legal)
testMagicMethodPositionalOnlyArg
testMagicMethodPositionalOnlyArgFastparse

# Won't support: reveal_locals
testRevealLocalsFunction
testRevealLocalsOnClassVars
testRevealLocals
testUnimportedRevealLocals

# Won't support: Warning about wrong usage of type var values
testObsoleteTypevarValuesSyntax

# Won't support ever: Union Pipe "|" not allowed in 3.9
testUnionOrSyntaxWithinRuntimeContextNotAllowed
testUnionOrSyntaxWithinRuntimeContextNotAllowed2
testUnionOrSyntaxMissingFutureImport
testTypeAliasNotSupportedWithNewStyleUnion

# Probably won't support `# flags2: ` in tests
testInlineIncremental2
# Won't support ever: Mypy test case details
testNewAnalyzerIncompleteFixture

# Won't support ever: python 2
testMypyPathAndPython2Dir
# Won't support: Python 3.7 specialties
testGenericBuiltinWarning
testGenericBuiltinSetWarning
testGenericCollectionsWarning
testNoSubcriptionOfStdlibCollections
# Won't support: Python 3.8 specialties
testTupleWithDifferentArgsPy38
# Won't support Python 3.9 specialities
testDataclassWithMatchArgsOldVersion
testUnionOrSyntaxInIsinstanceNotSupported
# "Subscripting classes that are not generic at runtime may require escaping"
testCheckDisallowAnyGenericsStubOnly

# Won't support list/dict/tuple "is not subscriptable" (python <3.10)
testNoSubscriptionOfBuiltinAliases
testDataclassWithSlotsArgBefore310

# Won't support --disable-recursive-aliases
testNewAnalyzerAliasToNotReadyDirectBase
testNewAnalyzerAliasToNotReadyDirectBaseFunction
testNewAnalyzerNewTypeForwardClassAliasDirect
testNewAnalyzerForwardTypeAliasInBase
testRecursiveForwardReferenceInUnion
testRecursiveAliasesErrors1
testRecursiveAliasesErrors2
testJSONAliasApproximation
testCrashOnSelfRecursiveNamedTupleVar
testSimpleSelfReferentialNamedTuple
testSelfRefNT1
testSelfRefNT2
testSelfRefNT3
testSelfRefNT4
testSelfRefNT5
testRecursiveNamedTupleInBases
testSubclassOfRecursiveNamedTuple
testSelfRecursiveTypedDictInheriting
testSubclassOfRecursiveTypedDict
testCorrectJoinOfSelfRecursiveTypedDicts

# Won't support --force-union-syntax
testOptionalErrorSyntax
testLiteralUnionErrorSyntax
testLiteralOptionalErrorSyntax

# Are generics in self types always bound to the function?
# https://github.com/python/typing/discussions/1340
# https://github.com/python/mypy/issues/14729
testSelfTypeRestrictedMethodOverloadInit
# Callable override https://github.com/python/mypy/issues/16549
testClassSpec
testClassSpecError
# Mypy test case issues
# https://github.com/python/mypy/issues/13102
testNewAnalyzerMoreInvalidTypeVarArgumentsDeferred

# Not working in interpreter
# Recursive class inheritance
testNewAnalyzerAliasToNotReadyNestedClass

# "Recursive types are not allowed at function scope"
testNoRecursiveTuplesAtFunctionScope
testRecursiveBoundFunctionScopeNoCrash
testNewAnalyzerReportLoopInMRO2

# Won't support: Mypy internals
testIncrCacheBustedProtocol
testIncrementalBustedFineGrainedCache1
testIncrementalBustedFineGrainedCache3
testInvalidateCachePart

# Won't do, because too many differences because of different stubs
testDivmod
# xfail
testOpWithInheritedFromAny-xfail
testTypeGuardMultipleCondition-xfail
# Skips
testSubtypingWithTypeImplementingGenericABCViaInheritance2-skip
testOverloadInferringArgumentsUsingContext2-skip
testUnionTwoPassInference-skip
testWeirdRecursiveInferenceForProtocols-skip
testPartiallyInitializedToNoneAndThenToIncompleteType-skip
